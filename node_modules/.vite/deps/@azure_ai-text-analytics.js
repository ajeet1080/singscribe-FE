import {
  RestError,
  bearerTokenAuthenticationPolicy,
  createClientLogger,
  createDefaultHttpClient,
  createPipelineFromOptions,
  createPipelineRequest
} from "./chunk-KKJHZEF7.js";
import {
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __rest
} from "./chunk-ZDQUMZSZ.js";
import {
  __export
} from "./chunk-AUZ3RYOM.js";

// node_modules/@azure/core-asynciterator-polyfill/dist/index.js
if (typeof Symbol === void 0 || !Symbol.asyncIterator) {
  Symbol.asyncIterator = Symbol.for("Symbol.asyncIterator");
}

// node_modules/@azure/core-auth/dist-esm/src/azureKeyCredential.js
var AzureKeyCredential = class {
  /**
   * The value of the key to be used in authentication
   */
  get key() {
    return this._key;
  }
  /**
   * Create an instance of an AzureKeyCredential for use
   * with a service client.
   *
   * @param key - The initial value of the key to use in authentication
   */
  constructor(key) {
    if (!key) {
      throw new Error("key must be a non-empty string");
    }
    this._key = key;
  }
  /**
   * Change the value of the key.
   *
   * Updates will take effect upon the next request after
   * updating the key value.
   *
   * @param newKey - The new key value to be used
   */
  update(newKey) {
    this._key = newKey;
  }
};

// node_modules/@azure/core-auth/dist-esm/src/tokenCredential.js
function isTokenCredential(credential) {
  const castCredential = credential;
  return castCredential && typeof castCredential.getToken === "function" && (castCredential.signRequest === void 0 || castCredential.getToken.length > 0);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/constants.js
var SDK_VERSION = "5.1.0";

// node_modules/@azure/core-client/dist-esm/src/base64.browser.js
function encodeByteArray(value) {
  let str = "";
  for (let i = 0; i < value.length; i++) {
    str += String.fromCharCode(value[i]);
  }
  return btoa(str);
}
function decodeString(value) {
  const byteString = atob(value);
  const arr = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    arr[i] = byteString.charCodeAt(i);
  }
  return arr;
}

// node_modules/@azure/core-client/dist-esm/src/interfaces.js
var XML_ATTRKEY = "$";
var XML_CHARKEY = "_";

// node_modules/@azure/core-client/dist-esm/src/utils.js
function isPrimitiveBody(value, mapperTypeName) {
  return mapperTypeName !== "Composite" && mapperTypeName !== "Dictionary" && (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || (mapperTypeName === null || mapperTypeName === void 0 ? void 0 : mapperTypeName.match(/^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i)) !== null || value === void 0 || value === null);
}
var validateISODuration = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function isDuration(value) {
  return validateISODuration.test(value);
}
var validUuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
function isValidUuid(uuid) {
  return validUuidRegex.test(uuid);
}
function handleNullableResponseAndWrappableBody(responseObject) {
  const combinedHeadersAndBody = Object.assign(Object.assign({}, responseObject.headers), responseObject.body);
  if (responseObject.hasNullableType && Object.getOwnPropertyNames(combinedHeadersAndBody).length === 0) {
    return responseObject.shouldWrapBody ? { body: null } : null;
  } else {
    return responseObject.shouldWrapBody ? Object.assign(Object.assign({}, responseObject.headers), { body: responseObject.body }) : combinedHeadersAndBody;
  }
}
function flattenResponse(fullResponse, responseSpec) {
  var _a, _b;
  const parsedHeaders = fullResponse.parsedHeaders;
  if (fullResponse.request.method === "HEAD") {
    return Object.assign(Object.assign({}, parsedHeaders), { body: fullResponse.parsedBody });
  }
  const bodyMapper = responseSpec && responseSpec.bodyMapper;
  const isNullable = Boolean(bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.nullable);
  const expectedBodyTypeName = bodyMapper === null || bodyMapper === void 0 ? void 0 : bodyMapper.type.name;
  if (expectedBodyTypeName === "Stream") {
    return Object.assign(Object.assign({}, parsedHeaders), { blobBody: fullResponse.blobBody, readableStreamBody: fullResponse.readableStreamBody });
  }
  const modelProperties = expectedBodyTypeName === "Composite" && bodyMapper.type.modelProperties || {};
  const isPageableResponse = Object.keys(modelProperties).some((k) => modelProperties[k].serializedName === "");
  if (expectedBodyTypeName === "Sequence" || isPageableResponse) {
    const arrayResponse = (_a = fullResponse.parsedBody) !== null && _a !== void 0 ? _a : [];
    for (const key of Object.keys(modelProperties)) {
      if (modelProperties[key].serializedName) {
        arrayResponse[key] = (_b = fullResponse.parsedBody) === null || _b === void 0 ? void 0 : _b[key];
      }
    }
    if (parsedHeaders) {
      for (const key of Object.keys(parsedHeaders)) {
        arrayResponse[key] = parsedHeaders[key];
      }
    }
    return isNullable && !fullResponse.parsedBody && !parsedHeaders && Object.getOwnPropertyNames(modelProperties).length === 0 ? null : arrayResponse;
  }
  return handleNullableResponseAndWrappableBody({
    body: fullResponse.parsedBody,
    headers: parsedHeaders,
    hasNullableType: isNullable,
    shouldWrapBody: isPrimitiveBody(fullResponse.parsedBody, expectedBodyTypeName)
  });
}

// node_modules/@azure/core-client/dist-esm/src/serializer.js
var SerializerImpl = class {
  constructor(modelMappers = {}, isXML = false) {
    this.modelMappers = modelMappers;
    this.isXML = isXML;
  }
  /**
   * @deprecated Removing the constraints validation on client side.
   */
  validateConstraints(mapper, value, objectName) {
    const failValidation = (constraintName, constraintValue) => {
      throw new Error(`"${objectName}" with value "${value}" should satisfy the constraint "${constraintName}": ${constraintValue}.`);
    };
    if (mapper.constraints && value !== void 0 && value !== null) {
      const { ExclusiveMaximum, ExclusiveMinimum, InclusiveMaximum, InclusiveMinimum, MaxItems, MaxLength, MinItems, MinLength, MultipleOf, Pattern, UniqueItems } = mapper.constraints;
      if (ExclusiveMaximum !== void 0 && value >= ExclusiveMaximum) {
        failValidation("ExclusiveMaximum", ExclusiveMaximum);
      }
      if (ExclusiveMinimum !== void 0 && value <= ExclusiveMinimum) {
        failValidation("ExclusiveMinimum", ExclusiveMinimum);
      }
      if (InclusiveMaximum !== void 0 && value > InclusiveMaximum) {
        failValidation("InclusiveMaximum", InclusiveMaximum);
      }
      if (InclusiveMinimum !== void 0 && value < InclusiveMinimum) {
        failValidation("InclusiveMinimum", InclusiveMinimum);
      }
      if (MaxItems !== void 0 && value.length > MaxItems) {
        failValidation("MaxItems", MaxItems);
      }
      if (MaxLength !== void 0 && value.length > MaxLength) {
        failValidation("MaxLength", MaxLength);
      }
      if (MinItems !== void 0 && value.length < MinItems) {
        failValidation("MinItems", MinItems);
      }
      if (MinLength !== void 0 && value.length < MinLength) {
        failValidation("MinLength", MinLength);
      }
      if (MultipleOf !== void 0 && value % MultipleOf !== 0) {
        failValidation("MultipleOf", MultipleOf);
      }
      if (Pattern) {
        const pattern = typeof Pattern === "string" ? new RegExp(Pattern) : Pattern;
        if (typeof value !== "string" || value.match(pattern) === null) {
          failValidation("Pattern", Pattern);
        }
      }
      if (UniqueItems && value.some((item, i, ar) => ar.indexOf(item) !== i)) {
        failValidation("UniqueItems", UniqueItems);
      }
    }
  }
  /**
   * Serialize the given object based on its metadata defined in the mapper
   *
   * @param mapper - The mapper which defines the metadata of the serializable object
   *
   * @param object - A valid Javascript object to be serialized
   *
   * @param objectName - Name of the serialized object
   *
   * @param options - additional options to serialization
   *
   * @returns A valid serialized Javascript object
   */
  serialize(mapper, object, objectName, options = { xml: {} }) {
    var _a, _b, _c;
    const updatedOptions = {
      xml: {
        rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : "",
        includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
        xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
      }
    };
    let payload = {};
    const mapperType = mapper.type.name;
    if (!objectName) {
      objectName = mapper.serializedName;
    }
    if (mapperType.match(/^Sequence$/i) !== null) {
      payload = [];
    }
    if (mapper.isConstant) {
      object = mapper.defaultValue;
    }
    const { required, nullable } = mapper;
    if (required && nullable && object === void 0) {
      throw new Error(`${objectName} cannot be undefined.`);
    }
    if (required && !nullable && (object === void 0 || object === null)) {
      throw new Error(`${objectName} cannot be null or undefined.`);
    }
    if (!required && nullable === false && object === null) {
      throw new Error(`${objectName} cannot be null.`);
    }
    if (object === void 0 || object === null) {
      payload = object;
    } else {
      if (mapperType.match(/^any$/i) !== null) {
        payload = object;
      } else if (mapperType.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null) {
        payload = serializeBasicTypes(mapperType, objectName, object);
      } else if (mapperType.match(/^Enum$/i) !== null) {
        const enumMapper = mapper;
        payload = serializeEnumType(objectName, enumMapper.type.allowedValues, object);
      } else if (mapperType.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null) {
        payload = serializeDateTypes(mapperType, object, objectName);
      } else if (mapperType.match(/^ByteArray$/i) !== null) {
        payload = serializeByteArrayType(objectName, object);
      } else if (mapperType.match(/^Base64Url$/i) !== null) {
        payload = serializeBase64UrlType(objectName, object);
      } else if (mapperType.match(/^Sequence$/i) !== null) {
        payload = serializeSequenceType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      } else if (mapperType.match(/^Dictionary$/i) !== null) {
        payload = serializeDictionaryType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      } else if (mapperType.match(/^Composite$/i) !== null) {
        payload = serializeCompositeType(this, mapper, object, objectName, Boolean(this.isXML), updatedOptions);
      }
    }
    return payload;
  }
  /**
   * Deserialize the given object based on its metadata defined in the mapper
   *
   * @param mapper - The mapper which defines the metadata of the serializable object
   *
   * @param responseBody - A valid Javascript entity to be deserialized
   *
   * @param objectName - Name of the deserialized object
   *
   * @param options - Controls behavior of XML parser and builder.
   *
   * @returns A valid deserialized Javascript object
   */
  deserialize(mapper, responseBody, objectName, options = { xml: {} }) {
    var _a, _b, _c, _d;
    const updatedOptions = {
      xml: {
        rootName: (_a = options.xml.rootName) !== null && _a !== void 0 ? _a : "",
        includeRoot: (_b = options.xml.includeRoot) !== null && _b !== void 0 ? _b : false,
        xmlCharKey: (_c = options.xml.xmlCharKey) !== null && _c !== void 0 ? _c : XML_CHARKEY
      },
      ignoreUnknownProperties: (_d = options.ignoreUnknownProperties) !== null && _d !== void 0 ? _d : false
    };
    if (responseBody === void 0 || responseBody === null) {
      if (this.isXML && mapper.type.name === "Sequence" && !mapper.xmlIsWrapped) {
        responseBody = [];
      }
      if (mapper.defaultValue !== void 0) {
        responseBody = mapper.defaultValue;
      }
      return responseBody;
    }
    let payload;
    const mapperType = mapper.type.name;
    if (!objectName) {
      objectName = mapper.serializedName;
    }
    if (mapperType.match(/^Composite$/i) !== null) {
      payload = deserializeCompositeType(this, mapper, responseBody, objectName, updatedOptions);
    } else {
      if (this.isXML) {
        const xmlCharKey = updatedOptions.xml.xmlCharKey;
        if (responseBody[XML_ATTRKEY] !== void 0 && responseBody[xmlCharKey] !== void 0) {
          responseBody = responseBody[xmlCharKey];
        }
      }
      if (mapperType.match(/^Number$/i) !== null) {
        payload = parseFloat(responseBody);
        if (isNaN(payload)) {
          payload = responseBody;
        }
      } else if (mapperType.match(/^Boolean$/i) !== null) {
        if (responseBody === "true") {
          payload = true;
        } else if (responseBody === "false") {
          payload = false;
        } else {
          payload = responseBody;
        }
      } else if (mapperType.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null) {
        payload = responseBody;
      } else if (mapperType.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null) {
        payload = new Date(responseBody);
      } else if (mapperType.match(/^UnixTime$/i) !== null) {
        payload = unixTimeToDate(responseBody);
      } else if (mapperType.match(/^ByteArray$/i) !== null) {
        payload = decodeString(responseBody);
      } else if (mapperType.match(/^Base64Url$/i) !== null) {
        payload = base64UrlToByteArray(responseBody);
      } else if (mapperType.match(/^Sequence$/i) !== null) {
        payload = deserializeSequenceType(this, mapper, responseBody, objectName, updatedOptions);
      } else if (mapperType.match(/^Dictionary$/i) !== null) {
        payload = deserializeDictionaryType(this, mapper, responseBody, objectName, updatedOptions);
      }
    }
    if (mapper.isConstant) {
      payload = mapper.defaultValue;
    }
    return payload;
  }
};
function createSerializer(modelMappers = {}, isXML = false) {
  return new SerializerImpl(modelMappers, isXML);
}
function trimEnd(str, ch) {
  let len = str.length;
  while (len - 1 >= 0 && str[len - 1] === ch) {
    --len;
  }
  return str.substr(0, len);
}
function bufferToBase64Url(buffer) {
  if (!buffer) {
    return void 0;
  }
  if (!(buffer instanceof Uint8Array)) {
    throw new Error(`Please provide an input of type Uint8Array for converting to Base64Url.`);
  }
  const str = encodeByteArray(buffer);
  return trimEnd(str, "=").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64UrlToByteArray(str) {
  if (!str) {
    return void 0;
  }
  if (str && typeof str.valueOf() !== "string") {
    throw new Error("Please provide an input of type string for converting to Uint8Array");
  }
  str = str.replace(/-/g, "+").replace(/_/g, "/");
  return decodeString(str);
}
function splitSerializeName(prop) {
  const classes = [];
  let partialclass = "";
  if (prop) {
    const subwords = prop.split(".");
    for (const item of subwords) {
      if (item.charAt(item.length - 1) === "\\") {
        partialclass += item.substr(0, item.length - 1) + ".";
      } else {
        partialclass += item;
        classes.push(partialclass);
        partialclass = "";
      }
    }
  }
  return classes;
}
function dateToUnixTime(d) {
  if (!d) {
    return void 0;
  }
  if (typeof d.valueOf() === "string") {
    d = new Date(d);
  }
  return Math.floor(d.getTime() / 1e3);
}
function unixTimeToDate(n) {
  if (!n) {
    return void 0;
  }
  return new Date(n * 1e3);
}
function serializeBasicTypes(typeName, objectName, value) {
  if (value !== null && value !== void 0) {
    if (typeName.match(/^Number$/i) !== null) {
      if (typeof value !== "number") {
        throw new Error(`${objectName} with value ${value} must be of type number.`);
      }
    } else if (typeName.match(/^String$/i) !== null) {
      if (typeof value.valueOf() !== "string") {
        throw new Error(`${objectName} with value "${value}" must be of type string.`);
      }
    } else if (typeName.match(/^Uuid$/i) !== null) {
      if (!(typeof value.valueOf() === "string" && isValidUuid(value))) {
        throw new Error(`${objectName} with value "${value}" must be of type string and a valid uuid.`);
      }
    } else if (typeName.match(/^Boolean$/i) !== null) {
      if (typeof value !== "boolean") {
        throw new Error(`${objectName} with value ${value} must be of type boolean.`);
      }
    } else if (typeName.match(/^Stream$/i) !== null) {
      const objectType = typeof value;
      if (objectType !== "string" && typeof value.pipe !== "function" && // NodeJS.ReadableStream
      typeof value.tee !== "function" && // browser ReadableStream
      !(value instanceof ArrayBuffer) && !ArrayBuffer.isView(value) && // File objects count as a type of Blob, so we want to use instanceof explicitly
      !((typeof Blob === "function" || typeof Blob === "object") && value instanceof Blob) && objectType !== "function") {
        throw new Error(`${objectName} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`);
      }
    }
  }
  return value;
}
function serializeEnumType(objectName, allowedValues, value) {
  if (!allowedValues) {
    throw new Error(`Please provide a set of allowedValues to validate ${objectName} as an Enum Type.`);
  }
  const isPresent = allowedValues.some((item) => {
    if (typeof item.valueOf() === "string") {
      return item.toLowerCase() === value.toLowerCase();
    }
    return item === value;
  });
  if (!isPresent) {
    throw new Error(`${value} is not a valid value for ${objectName}. The valid values are: ${JSON.stringify(allowedValues)}.`);
  }
  return value;
}
function serializeByteArrayType(objectName, value) {
  if (value !== void 0 && value !== null) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    value = encodeByteArray(value);
  }
  return value;
}
function serializeBase64UrlType(objectName, value) {
  if (value !== void 0 && value !== null) {
    if (!(value instanceof Uint8Array)) {
      throw new Error(`${objectName} must be of type Uint8Array.`);
    }
    value = bufferToBase64Url(value);
  }
  return value;
}
function serializeDateTypes(typeName, value, objectName) {
  if (value !== void 0 && value !== null) {
    if (typeName.match(/^Date$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value = value instanceof Date ? value.toISOString().substring(0, 10) : new Date(value).toISOString().substring(0, 10);
    } else if (typeName.match(/^DateTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in ISO8601 format.`);
      }
      value = value instanceof Date ? value.toISOString() : new Date(value).toISOString();
    } else if (typeName.match(/^DateTimeRfc1123$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123 format.`);
      }
      value = value instanceof Date ? value.toUTCString() : new Date(value).toUTCString();
    } else if (typeName.match(/^UnixTime$/i) !== null) {
      if (!(value instanceof Date || typeof value.valueOf() === "string" && !isNaN(Date.parse(value)))) {
        throw new Error(`${objectName} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`);
      }
      value = dateToUnixTime(value);
    } else if (typeName.match(/^TimeSpan$/i) !== null) {
      if (!isDuration(value)) {
        throw new Error(`${objectName} must be a string in ISO 8601 format. Instead was "${value}".`);
      }
    }
  }
  return value;
}
function serializeSequenceType(serializer2, mapper, object, objectName, isXml, options) {
  var _a;
  if (!Array.isArray(object)) {
    throw new Error(`${objectName} must be of type Array.`);
  }
  let elementType = mapper.type.element;
  if (!elementType || typeof elementType !== "object") {
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}.`);
  }
  if (elementType.type.name === "Composite" && elementType.type.className) {
    elementType = (_a = serializer2.modelMappers[elementType.type.className]) !== null && _a !== void 0 ? _a : elementType;
  }
  const tempArray = [];
  for (let i = 0; i < object.length; i++) {
    const serializedValue = serializer2.serialize(elementType, object[i], objectName, options);
    if (isXml && elementType.xmlNamespace) {
      const xmlnsKey = elementType.xmlNamespacePrefix ? `xmlns:${elementType.xmlNamespacePrefix}` : "xmlns";
      if (elementType.type.name === "Composite") {
        tempArray[i] = Object.assign({}, serializedValue);
        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
      } else {
        tempArray[i] = {};
        tempArray[i][options.xml.xmlCharKey] = serializedValue;
        tempArray[i][XML_ATTRKEY] = { [xmlnsKey]: elementType.xmlNamespace };
      }
    } else {
      tempArray[i] = serializedValue;
    }
  }
  return tempArray;
}
function serializeDictionaryType(serializer2, mapper, object, objectName, isXml, options) {
  if (typeof object !== "object") {
    throw new Error(`${objectName} must be of type object.`);
  }
  const valueType = mapper.type.value;
  if (!valueType || typeof valueType !== "object") {
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}.`);
  }
  const tempDictionary = {};
  for (const key of Object.keys(object)) {
    const serializedValue = serializer2.serialize(valueType, object[key], objectName, options);
    tempDictionary[key] = getXmlObjectValue(valueType, serializedValue, isXml, options);
  }
  if (isXml && mapper.xmlNamespace) {
    const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
    const result = tempDictionary;
    result[XML_ATTRKEY] = { [xmlnsKey]: mapper.xmlNamespace };
    return result;
  }
  return tempDictionary;
}
function resolveAdditionalProperties(serializer2, mapper, objectName) {
  const additionalProperties = mapper.type.additionalProperties;
  if (!additionalProperties && mapper.type.className) {
    const modelMapper = resolveReferencedMapper(serializer2, mapper, objectName);
    return modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.additionalProperties;
  }
  return additionalProperties;
}
function resolveReferencedMapper(serializer2, mapper, objectName) {
  const className = mapper.type.className;
  if (!className) {
    throw new Error(`Class name for model "${objectName}" is not provided in the mapper "${JSON.stringify(mapper, void 0, 2)}".`);
  }
  return serializer2.modelMappers[className];
}
function resolveModelProperties(serializer2, mapper, objectName) {
  let modelProps = mapper.type.modelProperties;
  if (!modelProps) {
    const modelMapper = resolveReferencedMapper(serializer2, mapper, objectName);
    if (!modelMapper) {
      throw new Error(`mapper() cannot be null or undefined for model "${mapper.type.className}".`);
    }
    modelProps = modelMapper === null || modelMapper === void 0 ? void 0 : modelMapper.type.modelProperties;
    if (!modelProps) {
      throw new Error(`modelProperties cannot be null or undefined in the mapper "${JSON.stringify(modelMapper)}" of type "${mapper.type.className}" for object "${objectName}".`);
    }
  }
  return modelProps;
}
function serializeCompositeType(serializer2, mapper, object, objectName, isXml, options) {
  if (getPolymorphicDiscriminatorRecursively(serializer2, mapper)) {
    mapper = getPolymorphicMapper(serializer2, mapper, object, "clientName");
  }
  if (object !== void 0 && object !== null) {
    const payload = {};
    const modelProps = resolveModelProperties(serializer2, mapper, objectName);
    for (const key of Object.keys(modelProps)) {
      const propertyMapper = modelProps[key];
      if (propertyMapper.readOnly) {
        continue;
      }
      let propName;
      let parentObject = payload;
      if (serializer2.isXML) {
        if (propertyMapper.xmlIsWrapped) {
          propName = propertyMapper.xmlName;
        } else {
          propName = propertyMapper.xmlElementName || propertyMapper.xmlName;
        }
      } else {
        const paths = splitSerializeName(propertyMapper.serializedName);
        propName = paths.pop();
        for (const pathName of paths) {
          const childObject = parentObject[pathName];
          if ((childObject === void 0 || childObject === null) && (object[key] !== void 0 && object[key] !== null || propertyMapper.defaultValue !== void 0)) {
            parentObject[pathName] = {};
          }
          parentObject = parentObject[pathName];
        }
      }
      if (parentObject !== void 0 && parentObject !== null) {
        if (isXml && mapper.xmlNamespace) {
          const xmlnsKey = mapper.xmlNamespacePrefix ? `xmlns:${mapper.xmlNamespacePrefix}` : "xmlns";
          parentObject[XML_ATTRKEY] = Object.assign(Object.assign({}, parentObject[XML_ATTRKEY]), { [xmlnsKey]: mapper.xmlNamespace });
        }
        const propertyObjectName = propertyMapper.serializedName !== "" ? objectName + "." + propertyMapper.serializedName : objectName;
        let toSerialize = object[key];
        const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer2, mapper);
        if (polymorphicDiscriminator && polymorphicDiscriminator.clientName === key && (toSerialize === void 0 || toSerialize === null)) {
          toSerialize = mapper.serializedName;
        }
        const serializedValue = serializer2.serialize(propertyMapper, toSerialize, propertyObjectName, options);
        if (serializedValue !== void 0 && propName !== void 0 && propName !== null) {
          const value = getXmlObjectValue(propertyMapper, serializedValue, isXml, options);
          if (isXml && propertyMapper.xmlIsAttribute) {
            parentObject[XML_ATTRKEY] = parentObject[XML_ATTRKEY] || {};
            parentObject[XML_ATTRKEY][propName] = serializedValue;
          } else if (isXml && propertyMapper.xmlIsWrapped) {
            parentObject[propName] = { [propertyMapper.xmlElementName]: value };
          } else {
            parentObject[propName] = value;
          }
        }
      }
    }
    const additionalPropertiesMapper = resolveAdditionalProperties(serializer2, mapper, objectName);
    if (additionalPropertiesMapper) {
      const propNames = Object.keys(modelProps);
      for (const clientPropName in object) {
        const isAdditionalProperty = propNames.every((pn) => pn !== clientPropName);
        if (isAdditionalProperty) {
          payload[clientPropName] = serializer2.serialize(additionalPropertiesMapper, object[clientPropName], objectName + '["' + clientPropName + '"]', options);
        }
      }
    }
    return payload;
  }
  return object;
}
function getXmlObjectValue(propertyMapper, serializedValue, isXml, options) {
  if (!isXml || !propertyMapper.xmlNamespace) {
    return serializedValue;
  }
  const xmlnsKey = propertyMapper.xmlNamespacePrefix ? `xmlns:${propertyMapper.xmlNamespacePrefix}` : "xmlns";
  const xmlNamespace = { [xmlnsKey]: propertyMapper.xmlNamespace };
  if (["Composite"].includes(propertyMapper.type.name)) {
    if (serializedValue[XML_ATTRKEY]) {
      return serializedValue;
    } else {
      const result2 = Object.assign({}, serializedValue);
      result2[XML_ATTRKEY] = xmlNamespace;
      return result2;
    }
  }
  const result = {};
  result[options.xml.xmlCharKey] = serializedValue;
  result[XML_ATTRKEY] = xmlNamespace;
  return result;
}
function isSpecialXmlProperty(propertyName, options) {
  return [XML_ATTRKEY, options.xml.xmlCharKey].includes(propertyName);
}
function deserializeCompositeType(serializer2, mapper, responseBody, objectName, options) {
  var _a, _b;
  const xmlCharKey = (_a = options.xml.xmlCharKey) !== null && _a !== void 0 ? _a : XML_CHARKEY;
  if (getPolymorphicDiscriminatorRecursively(serializer2, mapper)) {
    mapper = getPolymorphicMapper(serializer2, mapper, responseBody, "serializedName");
  }
  const modelProps = resolveModelProperties(serializer2, mapper, objectName);
  let instance = {};
  const handledPropertyNames = [];
  for (const key of Object.keys(modelProps)) {
    const propertyMapper = modelProps[key];
    const paths = splitSerializeName(modelProps[key].serializedName);
    handledPropertyNames.push(paths[0]);
    const { serializedName, xmlName, xmlElementName } = propertyMapper;
    let propertyObjectName = objectName;
    if (serializedName !== "" && serializedName !== void 0) {
      propertyObjectName = objectName + "." + serializedName;
    }
    const headerCollectionPrefix = propertyMapper.headerCollectionPrefix;
    if (headerCollectionPrefix) {
      const dictionary = {};
      for (const headerKey of Object.keys(responseBody)) {
        if (headerKey.startsWith(headerCollectionPrefix)) {
          dictionary[headerKey.substring(headerCollectionPrefix.length)] = serializer2.deserialize(propertyMapper.type.value, responseBody[headerKey], propertyObjectName, options);
        }
        handledPropertyNames.push(headerKey);
      }
      instance[key] = dictionary;
    } else if (serializer2.isXML) {
      if (propertyMapper.xmlIsAttribute && responseBody[XML_ATTRKEY]) {
        instance[key] = serializer2.deserialize(propertyMapper, responseBody[XML_ATTRKEY][xmlName], propertyObjectName, options);
      } else if (propertyMapper.xmlIsMsText) {
        if (responseBody[xmlCharKey] !== void 0) {
          instance[key] = responseBody[xmlCharKey];
        } else if (typeof responseBody === "string") {
          instance[key] = responseBody;
        }
      } else {
        const propertyName = xmlElementName || xmlName || serializedName;
        if (propertyMapper.xmlIsWrapped) {
          const wrapped = responseBody[xmlName];
          const elementList = (_b = wrapped === null || wrapped === void 0 ? void 0 : wrapped[xmlElementName]) !== null && _b !== void 0 ? _b : [];
          instance[key] = serializer2.deserialize(propertyMapper, elementList, propertyObjectName, options);
          handledPropertyNames.push(xmlName);
        } else {
          const property = responseBody[propertyName];
          instance[key] = serializer2.deserialize(propertyMapper, property, propertyObjectName, options);
          handledPropertyNames.push(propertyName);
        }
      }
    } else {
      let propertyInstance;
      let res = responseBody;
      let steps = 0;
      for (const item of paths) {
        if (!res)
          break;
        steps++;
        res = res[item];
      }
      if (res === null && steps < paths.length) {
        res = void 0;
      }
      propertyInstance = res;
      const polymorphicDiscriminator = mapper.type.polymorphicDiscriminator;
      if (polymorphicDiscriminator && key === polymorphicDiscriminator.clientName && (propertyInstance === void 0 || propertyInstance === null)) {
        propertyInstance = mapper.serializedName;
      }
      let serializedValue;
      if (Array.isArray(responseBody[key]) && modelProps[key].serializedName === "") {
        propertyInstance = responseBody[key];
        const arrayInstance = serializer2.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        for (const [k, v] of Object.entries(instance)) {
          if (!Object.prototype.hasOwnProperty.call(arrayInstance, k)) {
            arrayInstance[k] = v;
          }
        }
        instance = arrayInstance;
      } else if (propertyInstance !== void 0 || propertyMapper.defaultValue !== void 0) {
        serializedValue = serializer2.deserialize(propertyMapper, propertyInstance, propertyObjectName, options);
        instance[key] = serializedValue;
      }
    }
  }
  const additionalPropertiesMapper = mapper.type.additionalProperties;
  if (additionalPropertiesMapper) {
    const isAdditionalProperty = (responsePropName) => {
      for (const clientPropName in modelProps) {
        const paths = splitSerializeName(modelProps[clientPropName].serializedName);
        if (paths[0] === responsePropName) {
          return false;
        }
      }
      return true;
    };
    for (const responsePropName in responseBody) {
      if (isAdditionalProperty(responsePropName)) {
        instance[responsePropName] = serializer2.deserialize(additionalPropertiesMapper, responseBody[responsePropName], objectName + '["' + responsePropName + '"]', options);
      }
    }
  } else if (responseBody && !options.ignoreUnknownProperties) {
    for (const key of Object.keys(responseBody)) {
      if (instance[key] === void 0 && !handledPropertyNames.includes(key) && !isSpecialXmlProperty(key, options)) {
        instance[key] = responseBody[key];
      }
    }
  }
  return instance;
}
function deserializeDictionaryType(serializer2, mapper, responseBody, objectName, options) {
  const value = mapper.type.value;
  if (!value || typeof value !== "object") {
    throw new Error(`"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${objectName}`);
  }
  if (responseBody) {
    const tempDictionary = {};
    for (const key of Object.keys(responseBody)) {
      tempDictionary[key] = serializer2.deserialize(value, responseBody[key], objectName, options);
    }
    return tempDictionary;
  }
  return responseBody;
}
function deserializeSequenceType(serializer2, mapper, responseBody, objectName, options) {
  var _a;
  let element = mapper.type.element;
  if (!element || typeof element !== "object") {
    throw new Error(`element" metadata for an Array must be defined in the mapper and it must of type "object" in ${objectName}`);
  }
  if (responseBody) {
    if (!Array.isArray(responseBody)) {
      responseBody = [responseBody];
    }
    if (element.type.name === "Composite" && element.type.className) {
      element = (_a = serializer2.modelMappers[element.type.className]) !== null && _a !== void 0 ? _a : element;
    }
    const tempArray = [];
    for (let i = 0; i < responseBody.length; i++) {
      tempArray[i] = serializer2.deserialize(element, responseBody[i], `${objectName}[${i}]`, options);
    }
    return tempArray;
  }
  return responseBody;
}
function getIndexDiscriminator(discriminators, discriminatorValue, typeName) {
  const typeNamesToCheck = [typeName];
  while (typeNamesToCheck.length) {
    const currentName = typeNamesToCheck.shift();
    const indexDiscriminator = discriminatorValue === currentName ? discriminatorValue : currentName + "." + discriminatorValue;
    if (Object.prototype.hasOwnProperty.call(discriminators, indexDiscriminator)) {
      return discriminators[indexDiscriminator];
    } else {
      for (const [name, mapper] of Object.entries(discriminators)) {
        if (name.startsWith(currentName + ".") && mapper.type.uberParent === currentName && mapper.type.className) {
          typeNamesToCheck.push(mapper.type.className);
        }
      }
    }
  }
  return void 0;
}
function getPolymorphicMapper(serializer2, mapper, object, polymorphicPropertyName) {
  var _a;
  const polymorphicDiscriminator = getPolymorphicDiscriminatorRecursively(serializer2, mapper);
  if (polymorphicDiscriminator) {
    let discriminatorName = polymorphicDiscriminator[polymorphicPropertyName];
    if (discriminatorName) {
      if (polymorphicPropertyName === "serializedName") {
        discriminatorName = discriminatorName.replace(/\\/gi, "");
      }
      const discriminatorValue = object[discriminatorName];
      const typeName = (_a = mapper.type.uberParent) !== null && _a !== void 0 ? _a : mapper.type.className;
      if (typeof discriminatorValue === "string" && typeName) {
        const polymorphicMapper = getIndexDiscriminator(serializer2.modelMappers.discriminators, discriminatorValue, typeName);
        if (polymorphicMapper) {
          mapper = polymorphicMapper;
        }
      }
    }
  }
  return mapper;
}
function getPolymorphicDiscriminatorRecursively(serializer2, mapper) {
  return mapper.type.polymorphicDiscriminator || getPolymorphicDiscriminatorSafely(serializer2, mapper.type.uberParent) || getPolymorphicDiscriminatorSafely(serializer2, mapper.type.className);
}
function getPolymorphicDiscriminatorSafely(serializer2, typeName) {
  return typeName && serializer2.modelMappers[typeName] && serializer2.modelMappers[typeName].type.polymorphicDiscriminator;
}
var MapperTypeNames = {
  Base64Url: "Base64Url",
  Boolean: "Boolean",
  ByteArray: "ByteArray",
  Composite: "Composite",
  Date: "Date",
  DateTime: "DateTime",
  DateTimeRfc1123: "DateTimeRfc1123",
  Dictionary: "Dictionary",
  Enum: "Enum",
  Number: "Number",
  Object: "Object",
  Sequence: "Sequence",
  String: "String",
  Stream: "Stream",
  TimeSpan: "TimeSpan",
  UnixTime: "UnixTime"
};

// node_modules/@azure/core-client/dist-esm/src/operationHelpers.js
function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {
  let parameterPath = parameter.parameterPath;
  const parameterMapper = parameter.mapper;
  let value;
  if (typeof parameterPath === "string") {
    parameterPath = [parameterPath];
  }
  if (Array.isArray(parameterPath)) {
    if (parameterPath.length > 0) {
      if (parameterMapper.isConstant) {
        value = parameterMapper.defaultValue;
      } else {
        let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);
        if (!propertySearchResult.propertyFound && fallbackObject) {
          propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);
        }
        let useDefaultValue = false;
        if (!propertySearchResult.propertyFound) {
          useDefaultValue = parameterMapper.required || parameterPath[0] === "options" && parameterPath.length === 2;
        }
        value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;
      }
    }
  } else {
    if (parameterMapper.required) {
      value = {};
    }
    for (const propertyName in parameterPath) {
      const propertyMapper = parameterMapper.type.modelProperties[propertyName];
      const propertyPath = parameterPath[propertyName];
      const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {
        parameterPath: propertyPath,
        mapper: propertyMapper
      }, fallbackObject);
      if (propertyValue !== void 0) {
        if (!value) {
          value = {};
        }
        value[propertyName] = propertyValue;
      }
    }
  }
  return value;
}
function getPropertyFromParameterPath(parent, parameterPath) {
  const result = { propertyFound: false };
  let i = 0;
  for (; i < parameterPath.length; ++i) {
    const parameterPathPart = parameterPath[i];
    if (parent && parameterPathPart in parent) {
      parent = parent[parameterPathPart];
    } else {
      break;
    }
  }
  if (i === parameterPath.length) {
    result.propertyValue = parent;
    result.propertyFound = true;
  }
  return result;
}
var operationRequestMap = /* @__PURE__ */ new WeakMap();
var originalRequestSymbol = Symbol.for("@azure/core-client original request");
function hasOriginalRequest(request) {
  return originalRequestSymbol in request;
}
function getOperationRequestInfo(request) {
  if (hasOriginalRequest(request)) {
    return getOperationRequestInfo(request[originalRequestSymbol]);
  }
  let info = operationRequestMap.get(request);
  if (!info) {
    info = {};
    operationRequestMap.set(request, info);
  }
  return info;
}

// node_modules/@azure/core-client/dist-esm/src/deserializationPolicy.js
var defaultJsonContentTypes = ["application/json", "text/json"];
var defaultXmlContentTypes = ["application/xml", "application/atom+xml"];
var deserializationPolicyName = "deserializationPolicy";
function deserializationPolicy(options = {}) {
  var _a, _b, _c, _d, _e, _f, _g;
  const jsonContentTypes = (_b = (_a = options.expectedContentTypes) === null || _a === void 0 ? void 0 : _a.json) !== null && _b !== void 0 ? _b : defaultJsonContentTypes;
  const xmlContentTypes = (_d = (_c = options.expectedContentTypes) === null || _c === void 0 ? void 0 : _c.xml) !== null && _d !== void 0 ? _d : defaultXmlContentTypes;
  const parseXML = options.parseXML;
  const serializerOptions = options.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_e = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _e !== void 0 ? _e : "",
      includeRoot: (_f = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _f !== void 0 ? _f : false,
      xmlCharKey: (_g = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _g !== void 0 ? _g : XML_CHARKEY
    }
  };
  return {
    name: deserializationPolicyName,
    async sendRequest(request, next) {
      const response = await next(request);
      return deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, updatedOptions, parseXML);
    }
  };
}
function getOperationResponseMap(parsedResponse) {
  let result;
  const request = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (operationSpec) {
    if (!(operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter)) {
      result = operationSpec.responses[parsedResponse.status];
    } else {
      result = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationResponseGetter(operationSpec, parsedResponse);
    }
  }
  return result;
}
function shouldDeserializeResponse(parsedResponse) {
  const request = parsedResponse.request;
  const operationInfo = getOperationRequestInfo(request);
  const shouldDeserialize = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.shouldDeserialize;
  let result;
  if (shouldDeserialize === void 0) {
    result = true;
  } else if (typeof shouldDeserialize === "boolean") {
    result = shouldDeserialize;
  } else {
    result = shouldDeserialize(parsedResponse);
  }
  return result;
}
async function deserializeResponseBody(jsonContentTypes, xmlContentTypes, response, options, parseXML) {
  const parsedResponse = await parse(jsonContentTypes, xmlContentTypes, response, options, parseXML);
  if (!shouldDeserializeResponse(parsedResponse)) {
    return parsedResponse;
  }
  const operationInfo = getOperationRequestInfo(parsedResponse.request);
  const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
  if (!operationSpec || !operationSpec.responses) {
    return parsedResponse;
  }
  const responseSpec = getOperationResponseMap(parsedResponse);
  const { error, shouldReturnResponse } = handleErrorResponse(parsedResponse, operationSpec, responseSpec, options);
  if (error) {
    throw error;
  } else if (shouldReturnResponse) {
    return parsedResponse;
  }
  if (responseSpec) {
    if (responseSpec.bodyMapper) {
      let valueToDeserialize = parsedResponse.parsedBody;
      if (operationSpec.isXML && responseSpec.bodyMapper.type.name === MapperTypeNames.Sequence) {
        valueToDeserialize = typeof valueToDeserialize === "object" ? valueToDeserialize[responseSpec.bodyMapper.xmlElementName] : [];
      }
      try {
        parsedResponse.parsedBody = operationSpec.serializer.deserialize(responseSpec.bodyMapper, valueToDeserialize, "operationRes.parsedBody", options);
      } catch (deserializeError) {
        const restError = new RestError(`Error ${deserializeError} occurred in deserializing the responseBody - ${parsedResponse.bodyAsText}`, {
          statusCode: parsedResponse.status,
          request: parsedResponse.request,
          response: parsedResponse
        });
        throw restError;
      }
    } else if (operationSpec.httpMethod === "HEAD") {
      parsedResponse.parsedBody = response.status >= 200 && response.status < 300;
    }
    if (responseSpec.headersMapper) {
      parsedResponse.parsedHeaders = operationSpec.serializer.deserialize(responseSpec.headersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders", { xml: {}, ignoreUnknownProperties: true });
    }
  }
  return parsedResponse;
}
function isOperationSpecEmpty(operationSpec) {
  const expectedStatusCodes = Object.keys(operationSpec.responses);
  return expectedStatusCodes.length === 0 || expectedStatusCodes.length === 1 && expectedStatusCodes[0] === "default";
}
function handleErrorResponse(parsedResponse, operationSpec, responseSpec, options) {
  var _a;
  const isSuccessByStatus = 200 <= parsedResponse.status && parsedResponse.status < 300;
  const isExpectedStatusCode = isOperationSpecEmpty(operationSpec) ? isSuccessByStatus : !!responseSpec;
  if (isExpectedStatusCode) {
    if (responseSpec) {
      if (!responseSpec.isError) {
        return { error: null, shouldReturnResponse: false };
      }
    } else {
      return { error: null, shouldReturnResponse: false };
    }
  }
  const errorResponseSpec = responseSpec !== null && responseSpec !== void 0 ? responseSpec : operationSpec.responses.default;
  const initialErrorMessage = ((_a = parsedResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(parsedResponse.status)) ? `Unexpected status code: ${parsedResponse.status}` : parsedResponse.bodyAsText;
  const error = new RestError(initialErrorMessage, {
    statusCode: parsedResponse.status,
    request: parsedResponse.request,
    response: parsedResponse
  });
  if (!errorResponseSpec) {
    throw error;
  }
  const defaultBodyMapper = errorResponseSpec.bodyMapper;
  const defaultHeadersMapper = errorResponseSpec.headersMapper;
  try {
    if (parsedResponse.parsedBody) {
      const parsedBody = parsedResponse.parsedBody;
      let deserializedError;
      if (defaultBodyMapper) {
        let valueToDeserialize = parsedBody;
        if (operationSpec.isXML && defaultBodyMapper.type.name === MapperTypeNames.Sequence) {
          valueToDeserialize = [];
          const elementName = defaultBodyMapper.xmlElementName;
          if (typeof parsedBody === "object" && elementName) {
            valueToDeserialize = parsedBody[elementName];
          }
        }
        deserializedError = operationSpec.serializer.deserialize(defaultBodyMapper, valueToDeserialize, "error.response.parsedBody", options);
      }
      const internalError = parsedBody.error || deserializedError || parsedBody;
      error.code = internalError.code;
      if (internalError.message) {
        error.message = internalError.message;
      }
      if (defaultBodyMapper) {
        error.response.parsedBody = deserializedError;
      }
    }
    if (parsedResponse.headers && defaultHeadersMapper) {
      error.response.parsedHeaders = operationSpec.serializer.deserialize(defaultHeadersMapper, parsedResponse.headers.toJSON(), "operationRes.parsedHeaders");
    }
  } catch (defaultError) {
    error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody - "${parsedResponse.bodyAsText}" for the default response.`;
  }
  return { error, shouldReturnResponse: false };
}
async function parse(jsonContentTypes, xmlContentTypes, operationResponse, opts, parseXML) {
  var _a;
  if (!((_a = operationResponse.request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(operationResponse.status)) && operationResponse.bodyAsText) {
    const text = operationResponse.bodyAsText;
    const contentType2 = operationResponse.headers.get("Content-Type") || "";
    const contentComponents = !contentType2 ? [] : contentType2.split(";").map((component) => component.toLowerCase());
    try {
      if (contentComponents.length === 0 || contentComponents.some((component) => jsonContentTypes.indexOf(component) !== -1)) {
        operationResponse.parsedBody = JSON.parse(text);
        return operationResponse;
      } else if (contentComponents.some((component) => xmlContentTypes.indexOf(component) !== -1)) {
        if (!parseXML) {
          throw new Error("Parsing XML not supported.");
        }
        const body2 = await parseXML(text, opts.xml);
        operationResponse.parsedBody = body2;
        return operationResponse;
      }
    } catch (err) {
      const msg = `Error "${err}" occurred while parsing the response body - ${operationResponse.bodyAsText}.`;
      const errCode = err.code || RestError.PARSE_ERROR;
      const e = new RestError(msg, {
        code: errCode,
        statusCode: operationResponse.status,
        request: operationResponse.request,
        response: operationResponse
      });
      throw e;
    }
  }
  return operationResponse;
}

// node_modules/@azure/core-client/dist-esm/src/interfaceHelpers.js
function getStreamingResponseStatusCodes(operationSpec) {
  const result = /* @__PURE__ */ new Set();
  for (const statusCode in operationSpec.responses) {
    const operationResponse = operationSpec.responses[statusCode];
    if (operationResponse.bodyMapper && operationResponse.bodyMapper.type.name === MapperTypeNames.Stream) {
      result.add(Number(statusCode));
    }
  }
  return result;
}
function getPathStringFromParameter(parameter) {
  const { parameterPath, mapper } = parameter;
  let result;
  if (typeof parameterPath === "string") {
    result = parameterPath;
  } else if (Array.isArray(parameterPath)) {
    result = parameterPath.join(".");
  } else {
    result = mapper.serializedName;
  }
  return result;
}

// node_modules/@azure/core-client/dist-esm/src/serializationPolicy.js
var serializationPolicyName = "serializationPolicy";
function serializationPolicy(options = {}) {
  const stringifyXML = options.stringifyXML;
  return {
    name: serializationPolicyName,
    async sendRequest(request, next) {
      const operationInfo = getOperationRequestInfo(request);
      const operationSpec = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationSpec;
      const operationArguments = operationInfo === null || operationInfo === void 0 ? void 0 : operationInfo.operationArguments;
      if (operationSpec && operationArguments) {
        serializeHeaders(request, operationArguments, operationSpec);
        serializeRequestBody(request, operationArguments, operationSpec, stringifyXML);
      }
      return next(request);
    }
  };
}
function serializeHeaders(request, operationArguments, operationSpec) {
  var _a, _b;
  if (operationSpec.headerParameters) {
    for (const headerParameter of operationSpec.headerParameters) {
      let headerValue = getOperationArgumentValueFromParameter(operationArguments, headerParameter);
      if (headerValue !== null && headerValue !== void 0 || headerParameter.mapper.required) {
        headerValue = operationSpec.serializer.serialize(headerParameter.mapper, headerValue, getPathStringFromParameter(headerParameter));
        const headerCollectionPrefix = headerParameter.mapper.headerCollectionPrefix;
        if (headerCollectionPrefix) {
          for (const key of Object.keys(headerValue)) {
            request.headers.set(headerCollectionPrefix + key, headerValue[key]);
          }
        } else {
          request.headers.set(headerParameter.mapper.serializedName || getPathStringFromParameter(headerParameter), headerValue);
        }
      }
    }
  }
  const customHeaders = (_b = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.requestOptions) === null || _b === void 0 ? void 0 : _b.customHeaders;
  if (customHeaders) {
    for (const customHeaderName of Object.keys(customHeaders)) {
      request.headers.set(customHeaderName, customHeaders[customHeaderName]);
    }
  }
}
function serializeRequestBody(request, operationArguments, operationSpec, stringifyXML = function() {
  throw new Error("XML serialization unsupported!");
}) {
  var _a, _b, _c, _d, _e;
  const serializerOptions = (_a = operationArguments.options) === null || _a === void 0 ? void 0 : _a.serializerOptions;
  const updatedOptions = {
    xml: {
      rootName: (_b = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.rootName) !== null && _b !== void 0 ? _b : "",
      includeRoot: (_c = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.includeRoot) !== null && _c !== void 0 ? _c : false,
      xmlCharKey: (_d = serializerOptions === null || serializerOptions === void 0 ? void 0 : serializerOptions.xml.xmlCharKey) !== null && _d !== void 0 ? _d : XML_CHARKEY
    }
  };
  const xmlCharKey = updatedOptions.xml.xmlCharKey;
  if (operationSpec.requestBody && operationSpec.requestBody.mapper) {
    request.body = getOperationArgumentValueFromParameter(operationArguments, operationSpec.requestBody);
    const bodyMapper = operationSpec.requestBody.mapper;
    const { required, serializedName, xmlName, xmlElementName, xmlNamespace, xmlNamespacePrefix, nullable } = bodyMapper;
    const typeName = bodyMapper.type.name;
    try {
      if (request.body !== void 0 && request.body !== null || nullable && request.body === null || required) {
        const requestBodyParameterPathString = getPathStringFromParameter(operationSpec.requestBody);
        request.body = operationSpec.serializer.serialize(bodyMapper, request.body, requestBodyParameterPathString, updatedOptions);
        const isStream = typeName === MapperTypeNames.Stream;
        if (operationSpec.isXML) {
          const xmlnsKey = xmlNamespacePrefix ? `xmlns:${xmlNamespacePrefix}` : "xmlns";
          const value = getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, request.body, updatedOptions);
          if (typeName === MapperTypeNames.Sequence) {
            request.body = stringifyXML(prepareXMLRootList(value, xmlElementName || xmlName || serializedName, xmlnsKey, xmlNamespace), { rootName: xmlName || serializedName, xmlCharKey });
          } else if (!isStream) {
            request.body = stringifyXML(value, {
              rootName: xmlName || serializedName,
              xmlCharKey
            });
          }
        } else if (typeName === MapperTypeNames.String && (((_e = operationSpec.contentType) === null || _e === void 0 ? void 0 : _e.match("text/plain")) || operationSpec.mediaType === "text")) {
          return;
        } else if (!isStream) {
          request.body = JSON.stringify(request.body);
        }
      }
    } catch (error) {
      throw new Error(`Error "${error.message}" occurred in serializing the payload - ${JSON.stringify(serializedName, void 0, "  ")}.`);
    }
  } else if (operationSpec.formDataParameters && operationSpec.formDataParameters.length > 0) {
    request.formData = {};
    for (const formDataParameter of operationSpec.formDataParameters) {
      const formDataParameterValue = getOperationArgumentValueFromParameter(operationArguments, formDataParameter);
      if (formDataParameterValue !== void 0 && formDataParameterValue !== null) {
        const formDataParameterPropertyName = formDataParameter.mapper.serializedName || getPathStringFromParameter(formDataParameter);
        request.formData[formDataParameterPropertyName] = operationSpec.serializer.serialize(formDataParameter.mapper, formDataParameterValue, getPathStringFromParameter(formDataParameter), updatedOptions);
      }
    }
  }
}
function getXmlValueWithNamespace(xmlNamespace, xmlnsKey, typeName, serializedValue, options) {
  if (xmlNamespace && !["Composite", "Sequence", "Dictionary"].includes(typeName)) {
    const result = {};
    result[options.xml.xmlCharKey] = serializedValue;
    result[XML_ATTRKEY] = { [xmlnsKey]: xmlNamespace };
    return result;
  }
  return serializedValue;
}
function prepareXMLRootList(obj, elementName, xmlNamespaceKey, xmlNamespace) {
  if (!Array.isArray(obj)) {
    obj = [obj];
  }
  if (!xmlNamespaceKey || !xmlNamespace) {
    return { [elementName]: obj };
  }
  const result = { [elementName]: obj };
  result[XML_ATTRKEY] = { [xmlNamespaceKey]: xmlNamespace };
  return result;
}

// node_modules/@azure/core-client/dist-esm/src/pipeline.js
function createClientPipeline(options = {}) {
  const pipeline = createPipelineFromOptions(options !== null && options !== void 0 ? options : {});
  if (options.credentialOptions) {
    pipeline.addPolicy(bearerTokenAuthenticationPolicy({
      credential: options.credentialOptions.credential,
      scopes: options.credentialOptions.credentialScopes
    }));
  }
  pipeline.addPolicy(serializationPolicy(options.serializationOptions), { phase: "Serialize" });
  pipeline.addPolicy(deserializationPolicy(options.deserializationOptions), {
    phase: "Deserialize"
  });
  return pipeline;
}

// node_modules/@azure/core-client/dist-esm/src/httpClientCache.js
var cachedHttpClient;
function getCachedDefaultHttpClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = createDefaultHttpClient();
  }
  return cachedHttpClient;
}

// node_modules/@azure/core-client/dist-esm/src/urlHelpers.js
var CollectionFormatToDelimiterMap = {
  CSV: ",",
  SSV: " ",
  Multi: "Multi",
  TSV: "	",
  Pipes: "|"
};
function getRequestUrl(baseUri, operationSpec, operationArguments, fallbackObject) {
  const urlReplacements = calculateUrlReplacements(operationSpec, operationArguments, fallbackObject);
  let isAbsolutePath = false;
  let requestUrl = replaceAll(baseUri, urlReplacements);
  if (operationSpec.path) {
    let path = replaceAll(operationSpec.path, urlReplacements);
    if (operationSpec.path === "/{nextLink}" && path.startsWith("/")) {
      path = path.substring(1);
    }
    if (isAbsoluteUrl(path)) {
      requestUrl = path;
      isAbsolutePath = true;
    } else {
      requestUrl = appendPath(requestUrl, path);
    }
  }
  const { queryParams, sequenceParams } = calculateQueryParameters(operationSpec, operationArguments, fallbackObject);
  requestUrl = appendQueryParams(requestUrl, queryParams, sequenceParams, isAbsolutePath);
  return requestUrl;
}
function replaceAll(input2, replacements) {
  let result = input2;
  for (const [searchValue, replaceValue] of replacements) {
    result = result.split(searchValue).join(replaceValue);
  }
  return result;
}
function calculateUrlReplacements(operationSpec, operationArguments, fallbackObject) {
  var _a;
  const result = /* @__PURE__ */ new Map();
  if ((_a = operationSpec.urlParameters) === null || _a === void 0 ? void 0 : _a.length) {
    for (const urlParameter of operationSpec.urlParameters) {
      let urlParameterValue = getOperationArgumentValueFromParameter(operationArguments, urlParameter, fallbackObject);
      const parameterPathString = getPathStringFromParameter(urlParameter);
      urlParameterValue = operationSpec.serializer.serialize(urlParameter.mapper, urlParameterValue, parameterPathString);
      if (!urlParameter.skipEncoding) {
        urlParameterValue = encodeURIComponent(urlParameterValue);
      }
      result.set(`{${urlParameter.mapper.serializedName || parameterPathString}}`, urlParameterValue);
    }
  }
  return result;
}
function isAbsoluteUrl(url2) {
  return url2.includes("://");
}
function appendPath(url2, pathToAppend) {
  if (!pathToAppend) {
    return url2;
  }
  const parsedUrl = new URL(url2);
  let newPath = parsedUrl.pathname;
  if (!newPath.endsWith("/")) {
    newPath = `${newPath}/`;
  }
  if (pathToAppend.startsWith("/")) {
    pathToAppend = pathToAppend.substring(1);
  }
  const searchStart = pathToAppend.indexOf("?");
  if (searchStart !== -1) {
    const path = pathToAppend.substring(0, searchStart);
    const search = pathToAppend.substring(searchStart + 1);
    newPath = newPath + path;
    if (search) {
      parsedUrl.search = parsedUrl.search ? `${parsedUrl.search}&${search}` : search;
    }
  } else {
    newPath = newPath + pathToAppend;
  }
  parsedUrl.pathname = newPath;
  return parsedUrl.toString();
}
function calculateQueryParameters(operationSpec, operationArguments, fallbackObject) {
  var _a;
  const result = /* @__PURE__ */ new Map();
  const sequenceParams = /* @__PURE__ */ new Set();
  if ((_a = operationSpec.queryParameters) === null || _a === void 0 ? void 0 : _a.length) {
    for (const queryParameter of operationSpec.queryParameters) {
      if (queryParameter.mapper.type.name === "Sequence" && queryParameter.mapper.serializedName) {
        sequenceParams.add(queryParameter.mapper.serializedName);
      }
      let queryParameterValue = getOperationArgumentValueFromParameter(operationArguments, queryParameter, fallbackObject);
      if (queryParameterValue !== void 0 && queryParameterValue !== null || queryParameter.mapper.required) {
        queryParameterValue = operationSpec.serializer.serialize(queryParameter.mapper, queryParameterValue, getPathStringFromParameter(queryParameter));
        const delimiter = queryParameter.collectionFormat ? CollectionFormatToDelimiterMap[queryParameter.collectionFormat] : "";
        if (Array.isArray(queryParameterValue)) {
          queryParameterValue = queryParameterValue.map((item) => {
            if (item === null || item === void 0) {
              return "";
            }
            return item;
          });
        }
        if (queryParameter.collectionFormat === "Multi" && queryParameterValue.length === 0) {
          continue;
        } else if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "SSV" || queryParameter.collectionFormat === "TSV")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        if (!queryParameter.skipEncoding) {
          if (Array.isArray(queryParameterValue)) {
            queryParameterValue = queryParameterValue.map((item) => {
              return encodeURIComponent(item);
            });
          } else {
            queryParameterValue = encodeURIComponent(queryParameterValue);
          }
        }
        if (Array.isArray(queryParameterValue) && (queryParameter.collectionFormat === "CSV" || queryParameter.collectionFormat === "Pipes")) {
          queryParameterValue = queryParameterValue.join(delimiter);
        }
        result.set(queryParameter.mapper.serializedName || getPathStringFromParameter(queryParameter), queryParameterValue);
      }
    }
  }
  return {
    queryParams: result,
    sequenceParams
  };
}
function simpleParseQueryParams(queryString) {
  const result = /* @__PURE__ */ new Map();
  if (!queryString || queryString[0] !== "?") {
    return result;
  }
  queryString = queryString.slice(1);
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const [name, value] = pair.split("=", 2);
    const existingValue = result.get(name);
    if (existingValue) {
      if (Array.isArray(existingValue)) {
        existingValue.push(value);
      } else {
        result.set(name, [existingValue, value]);
      }
    } else {
      result.set(name, value);
    }
  }
  return result;
}
function appendQueryParams(url2, queryParams, sequenceParams, noOverwrite = false) {
  if (queryParams.size === 0) {
    return url2;
  }
  const parsedUrl = new URL(url2);
  const combinedParams = simpleParseQueryParams(parsedUrl.search);
  for (const [name, value] of queryParams) {
    const existingValue = combinedParams.get(name);
    if (Array.isArray(existingValue)) {
      if (Array.isArray(value)) {
        existingValue.push(...value);
        const valueSet = new Set(existingValue);
        combinedParams.set(name, Array.from(valueSet));
      } else {
        existingValue.push(value);
      }
    } else if (existingValue) {
      if (Array.isArray(value)) {
        value.unshift(existingValue);
      } else if (sequenceParams.has(name)) {
        combinedParams.set(name, [existingValue, value]);
      }
      if (!noOverwrite) {
        combinedParams.set(name, value);
      }
    } else {
      combinedParams.set(name, value);
    }
  }
  const searchPieces = [];
  for (const [name, value] of combinedParams) {
    if (typeof value === "string") {
      searchPieces.push(`${name}=${value}`);
    } else if (Array.isArray(value)) {
      for (const subValue of value) {
        searchPieces.push(`${name}=${subValue}`);
      }
    } else {
      searchPieces.push(`${name}=${value}`);
    }
  }
  parsedUrl.search = searchPieces.length ? `?${searchPieces.join("&")}` : "";
  return parsedUrl.toString();
}

// node_modules/@azure/core-client/dist-esm/src/log.js
var logger = createClientLogger("core-client");

// node_modules/@azure/core-client/dist-esm/src/serviceClient.js
var ServiceClient = class {
  /**
   * The ServiceClient constructor
   * @param credential - The credentials used for authentication with the service.
   * @param options - The service client options that govern the behavior of the client.
   */
  constructor(options = {}) {
    var _a, _b;
    this._requestContentType = options.requestContentType;
    this._endpoint = (_a = options.endpoint) !== null && _a !== void 0 ? _a : options.baseUri;
    if (options.baseUri) {
      logger.warning("The baseUri option for SDK Clients has been deprecated, please use endpoint instead.");
    }
    this._allowInsecureConnection = options.allowInsecureConnection;
    this._httpClient = options.httpClient || getCachedDefaultHttpClient();
    this.pipeline = options.pipeline || createDefaultPipeline(options);
    if ((_b = options.additionalPolicies) === null || _b === void 0 ? void 0 : _b.length) {
      for (const { policy, position } of options.additionalPolicies) {
        const afterPhase = position === "perRetry" ? "Sign" : void 0;
        this.pipeline.addPolicy(policy, {
          afterPhase
        });
      }
    }
  }
  /**
   * Send the provided httpRequest.
   */
  async sendRequest(request) {
    return this.pipeline.sendRequest(this._httpClient, request);
  }
  /**
   * Send an HTTP request that is populated using the provided OperationSpec.
   * @typeParam T - The typed result of the request, based on the OperationSpec.
   * @param operationArguments - The arguments that the HTTP request's templated values will be populated from.
   * @param operationSpec - The OperationSpec to use to populate the httpRequest.
   */
  async sendOperationRequest(operationArguments, operationSpec) {
    const endpoint2 = operationSpec.baseUrl || this._endpoint;
    if (!endpoint2) {
      throw new Error("If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.");
    }
    const url2 = getRequestUrl(endpoint2, operationSpec, operationArguments, this);
    const request = createPipelineRequest({
      url: url2
    });
    request.method = operationSpec.httpMethod;
    const operationInfo = getOperationRequestInfo(request);
    operationInfo.operationSpec = operationSpec;
    operationInfo.operationArguments = operationArguments;
    const contentType2 = operationSpec.contentType || this._requestContentType;
    if (contentType2 && operationSpec.requestBody) {
      request.headers.set("Content-Type", contentType2);
    }
    const options = operationArguments.options;
    if (options) {
      const requestOptions = options.requestOptions;
      if (requestOptions) {
        if (requestOptions.timeout) {
          request.timeout = requestOptions.timeout;
        }
        if (requestOptions.onUploadProgress) {
          request.onUploadProgress = requestOptions.onUploadProgress;
        }
        if (requestOptions.onDownloadProgress) {
          request.onDownloadProgress = requestOptions.onDownloadProgress;
        }
        if (requestOptions.shouldDeserialize !== void 0) {
          operationInfo.shouldDeserialize = requestOptions.shouldDeserialize;
        }
        if (requestOptions.allowInsecureConnection) {
          request.allowInsecureConnection = true;
        }
      }
      if (options.abortSignal) {
        request.abortSignal = options.abortSignal;
      }
      if (options.tracingOptions) {
        request.tracingOptions = options.tracingOptions;
      }
    }
    if (this._allowInsecureConnection) {
      request.allowInsecureConnection = true;
    }
    if (request.streamResponseStatusCodes === void 0) {
      request.streamResponseStatusCodes = getStreamingResponseStatusCodes(operationSpec);
    }
    try {
      const rawResponse = await this.sendRequest(request);
      const flatResponse = flattenResponse(rawResponse, operationSpec.responses[rawResponse.status]);
      if (options === null || options === void 0 ? void 0 : options.onResponse) {
        options.onResponse(rawResponse, flatResponse);
      }
      return flatResponse;
    } catch (error) {
      if (typeof error === "object" && (error === null || error === void 0 ? void 0 : error.response)) {
        const rawResponse = error.response;
        const flatResponse = flattenResponse(rawResponse, operationSpec.responses[error.statusCode] || operationSpec.responses["default"]);
        error.details = flatResponse;
        if (options === null || options === void 0 ? void 0 : options.onResponse) {
          options.onResponse(rawResponse, flatResponse, error);
        }
      }
      throw error;
    }
  }
};
function createDefaultPipeline(options) {
  const credentialScopes = getCredentialScopes(options);
  const credentialOptions = options.credential && credentialScopes ? { credentialScopes, credential: options.credential } : void 0;
  return createClientPipeline(Object.assign(Object.assign({}, options), { credentialOptions }));
}
function getCredentialScopes(options) {
  if (options.credentialScopes) {
    return options.credentialScopes;
  }
  if (options.endpoint) {
    return `${options.endpoint}/.default`;
  }
  if (options.baseUri) {
    return `${options.baseUri}/.default`;
  }
  if (options.credential && !options.credentialScopes) {
    throw new Error(`When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy`);
  }
  return void 0;
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/generated/models/mappers.js
var mappers_exports = {};
__export(mappers_exports, {
  AnalysisInput: () => AnalysisInput,
  AnalyzeBatchInput: () => AnalyzeBatchInput,
  AnalyzeJobDisplayName: () => AnalyzeJobDisplayName,
  AnalyzeJobErrorsAndStatistics: () => AnalyzeJobErrorsAndStatistics,
  AnalyzeJobMetadata: () => AnalyzeJobMetadata,
  AnalyzeJobState: () => AnalyzeJobState,
  DetectLanguageInput: () => DetectLanguageInput,
  DetectedLanguage: () => DetectedLanguage,
  DocumentEntities: () => DocumentEntities,
  DocumentError: () => DocumentError,
  DocumentHealthcareEntities: () => DocumentHealthcareEntities,
  DocumentKeyPhrases: () => DocumentKeyPhrases,
  DocumentLanguage: () => DocumentLanguage,
  DocumentLinkedEntities: () => DocumentLinkedEntities,
  DocumentSentiment: () => DocumentSentiment,
  EntitiesResult: () => EntitiesResult,
  EntitiesTask: () => EntitiesTask,
  EntitiesTaskParameters: () => EntitiesTaskParameters,
  EntitiesTaskResult: () => EntitiesTaskResult,
  Entity: () => Entity,
  EntityLinkingResult: () => EntityLinkingResult,
  EntityLinkingTask: () => EntityLinkingTask,
  EntityLinkingTaskParameters: () => EntityLinkingTaskParameters,
  EntityLinkingTaskResult: () => EntityLinkingTaskResult,
  ErrorResponse: () => ErrorResponse,
  GeneratedClientAnalyzeHeaders: () => GeneratedClientAnalyzeHeaders,
  GeneratedClientCancelHealthJobHeaders: () => GeneratedClientCancelHealthJobHeaders,
  GeneratedClientHealthHeaders: () => GeneratedClientHealthHeaders,
  HealthcareAssertion: () => HealthcareAssertion,
  HealthcareEntity: () => HealthcareEntity,
  HealthcareEntityLink: () => HealthcareEntityLink,
  HealthcareEntityProperties: () => HealthcareEntityProperties,
  HealthcareJobState: () => HealthcareJobState,
  HealthcareLinkingProperties: () => HealthcareLinkingProperties,
  HealthcareRelation: () => HealthcareRelation,
  HealthcareRelationEntity: () => HealthcareRelationEntity,
  HealthcareResult: () => HealthcareResult,
  HealthcareTaskResult: () => HealthcareTaskResult,
  InnerError: () => InnerError,
  JobDescriptor: () => JobDescriptor,
  JobManifest: () => JobManifest,
  JobManifestTasks: () => JobManifestTasks,
  JobMetadata: () => JobMetadata,
  KeyPhraseResult: () => KeyPhraseResult,
  KeyPhraseTaskResult: () => KeyPhraseTaskResult,
  KeyPhrasesTask: () => KeyPhrasesTask,
  KeyPhrasesTaskParameters: () => KeyPhrasesTaskParameters,
  LanguageBatchInput: () => LanguageBatchInput,
  LanguageResult: () => LanguageResult,
  LinkedEntity: () => LinkedEntity,
  Match: () => Match,
  MultiLanguageBatchInput: () => MultiLanguageBatchInput,
  Pagination: () => Pagination,
  PiiDocumentEntities: () => PiiDocumentEntities,
  PiiResult: () => PiiResult,
  PiiTask: () => PiiTask,
  PiiTaskParameters: () => PiiTaskParameters,
  PiiTaskResult: () => PiiTaskResult,
  SentenceAssessment: () => SentenceAssessment,
  SentenceSentiment: () => SentenceSentiment,
  SentenceTarget: () => SentenceTarget,
  SentimentAnalysisTask: () => SentimentAnalysisTask,
  SentimentAnalysisTaskParameters: () => SentimentAnalysisTaskParameters,
  SentimentConfidenceScores: () => SentimentConfidenceScores,
  SentimentResponse: () => SentimentResponse,
  SentimentTaskResult: () => SentimentTaskResult,
  TargetConfidenceScoreLabel: () => TargetConfidenceScoreLabel,
  TargetRelation: () => TargetRelation,
  TaskState: () => TaskState,
  TasksState: () => TasksState,
  TasksStateTasks: () => TasksStateTasks,
  TasksStateTasksEntityLinkingTasksItem: () => TasksStateTasksEntityLinkingTasksItem,
  TasksStateTasksEntityRecognitionPiiTasksItem: () => TasksStateTasksEntityRecognitionPiiTasksItem,
  TasksStateTasksEntityRecognitionTasksItem: () => TasksStateTasksEntityRecognitionTasksItem,
  TasksStateTasksKeyPhraseExtractionTasksItem: () => TasksStateTasksKeyPhraseExtractionTasksItem,
  TasksStateTasksSentimentAnalysisTasksItem: () => TasksStateTasksSentimentAnalysisTasksItem,
  TextAnalyticsError: () => TextAnalyticsError,
  TextAnalyticsWarning: () => TextAnalyticsWarning,
  TextDocumentBatchStatistics: () => TextDocumentBatchStatistics,
  TextDocumentInput: () => TextDocumentInput,
  TextDocumentStatistics: () => TextDocumentStatistics
});
var JobDescriptor = {
  type: {
    name: "Composite",
    className: "JobDescriptor",
    modelProperties: {
      displayName: {
        serializedName: "displayName",
        type: {
          name: "String"
        }
      }
    }
  }
};
var AnalysisInput = {
  type: {
    name: "Composite",
    className: "AnalysisInput",
    modelProperties: {
      analysisInput: {
        serializedName: "analysisInput",
        type: {
          name: "Composite",
          className: "MultiLanguageBatchInput"
        }
      }
    }
  }
};
var MultiLanguageBatchInput = {
  type: {
    name: "Composite",
    className: "MultiLanguageBatchInput",
    modelProperties: {
      documents: {
        serializedName: "documents",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TextDocumentInput"
            }
          }
        }
      }
    }
  }
};
var TextDocumentInput = {
  type: {
    name: "Composite",
    className: "TextDocumentInput",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      text: {
        serializedName: "text",
        required: true,
        type: {
          name: "String"
        }
      },
      language: {
        serializedName: "language",
        type: {
          name: "String"
        }
      }
    }
  }
};
var JobManifest = {
  type: {
    name: "Composite",
    className: "JobManifest",
    modelProperties: {
      tasks: {
        serializedName: "tasks",
        type: {
          name: "Composite",
          className: "JobManifestTasks"
        }
      }
    }
  }
};
var JobManifestTasks = {
  type: {
    name: "Composite",
    className: "JobManifestTasks",
    modelProperties: {
      entityRecognitionTasks: {
        serializedName: "entityRecognitionTasks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "EntitiesTask"
            }
          }
        }
      },
      entityRecognitionPiiTasks: {
        serializedName: "entityRecognitionPiiTasks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "PiiTask"
            }
          }
        }
      },
      keyPhraseExtractionTasks: {
        serializedName: "keyPhraseExtractionTasks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "KeyPhrasesTask"
            }
          }
        }
      },
      entityLinkingTasks: {
        serializedName: "entityLinkingTasks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "EntityLinkingTask"
            }
          }
        }
      },
      sentimentAnalysisTasks: {
        serializedName: "sentimentAnalysisTasks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SentimentAnalysisTask"
            }
          }
        }
      }
    }
  }
};
var EntitiesTask = {
  type: {
    name: "Composite",
    className: "EntitiesTask",
    modelProperties: {
      parameters: {
        serializedName: "parameters",
        type: {
          name: "Composite",
          className: "EntitiesTaskParameters"
        }
      }
    }
  }
};
var EntitiesTaskParameters = {
  type: {
    name: "Composite",
    className: "EntitiesTaskParameters",
    modelProperties: {
      modelVersion: {
        defaultValue: "latest",
        serializedName: "model-version",
        type: {
          name: "String"
        }
      },
      loggingOptOut: {
        serializedName: "loggingOptOut",
        type: {
          name: "Boolean"
        }
      },
      stringIndexType: {
        serializedName: "stringIndexType",
        type: {
          name: "String"
        }
      }
    }
  }
};
var PiiTask = {
  type: {
    name: "Composite",
    className: "PiiTask",
    modelProperties: {
      parameters: {
        serializedName: "parameters",
        type: {
          name: "Composite",
          className: "PiiTaskParameters"
        }
      }
    }
  }
};
var PiiTaskParameters = {
  type: {
    name: "Composite",
    className: "PiiTaskParameters",
    modelProperties: {
      domain: {
        defaultValue: "none",
        serializedName: "domain",
        type: {
          name: "String"
        }
      },
      modelVersion: {
        defaultValue: "latest",
        serializedName: "model-version",
        type: {
          name: "String"
        }
      },
      loggingOptOut: {
        defaultValue: true,
        serializedName: "loggingOptOut",
        type: {
          name: "Boolean"
        }
      },
      piiCategories: {
        constraints: {
          UniqueItems: true
        },
        serializedName: "piiCategories",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      stringIndexType: {
        serializedName: "stringIndexType",
        type: {
          name: "String"
        }
      }
    }
  }
};
var KeyPhrasesTask = {
  type: {
    name: "Composite",
    className: "KeyPhrasesTask",
    modelProperties: {
      parameters: {
        serializedName: "parameters",
        type: {
          name: "Composite",
          className: "KeyPhrasesTaskParameters"
        }
      }
    }
  }
};
var KeyPhrasesTaskParameters = {
  type: {
    name: "Composite",
    className: "KeyPhrasesTaskParameters",
    modelProperties: {
      modelVersion: {
        defaultValue: "latest",
        serializedName: "model-version",
        type: {
          name: "String"
        }
      },
      loggingOptOut: {
        serializedName: "loggingOptOut",
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
var EntityLinkingTask = {
  type: {
    name: "Composite",
    className: "EntityLinkingTask",
    modelProperties: {
      parameters: {
        serializedName: "parameters",
        type: {
          name: "Composite",
          className: "EntityLinkingTaskParameters"
        }
      }
    }
  }
};
var EntityLinkingTaskParameters = {
  type: {
    name: "Composite",
    className: "EntityLinkingTaskParameters",
    modelProperties: {
      modelVersion: {
        defaultValue: "latest",
        serializedName: "model-version",
        type: {
          name: "String"
        }
      },
      loggingOptOut: {
        serializedName: "loggingOptOut",
        type: {
          name: "Boolean"
        }
      },
      stringIndexType: {
        serializedName: "stringIndexType",
        type: {
          name: "String"
        }
      }
    }
  }
};
var SentimentAnalysisTask = {
  type: {
    name: "Composite",
    className: "SentimentAnalysisTask",
    modelProperties: {
      parameters: {
        serializedName: "parameters",
        type: {
          name: "Composite",
          className: "SentimentAnalysisTaskParameters"
        }
      }
    }
  }
};
var SentimentAnalysisTaskParameters = {
  type: {
    name: "Composite",
    className: "SentimentAnalysisTaskParameters",
    modelProperties: {
      modelVersion: {
        defaultValue: "latest",
        serializedName: "model-version",
        type: {
          name: "String"
        }
      },
      loggingOptOut: {
        serializedName: "loggingOptOut",
        type: {
          name: "Boolean"
        }
      },
      opinionMining: {
        serializedName: "opinionMining",
        type: {
          name: "Boolean"
        }
      },
      stringIndexType: {
        serializedName: "stringIndexType",
        type: {
          name: "String"
        }
      }
    }
  }
};
var ErrorResponse = {
  type: {
    name: "Composite",
    className: "ErrorResponse",
    modelProperties: {
      error: {
        serializedName: "error",
        type: {
          name: "Composite",
          className: "TextAnalyticsError"
        }
      }
    }
  }
};
var TextAnalyticsError = {
  type: {
    name: "Composite",
    className: "TextAnalyticsError",
    modelProperties: {
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      message: {
        serializedName: "message",
        required: true,
        type: {
          name: "String"
        }
      },
      target: {
        serializedName: "target",
        type: {
          name: "String"
        }
      },
      innererror: {
        serializedName: "innererror",
        type: {
          name: "Composite",
          className: "InnerError"
        }
      },
      details: {
        serializedName: "details",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TextAnalyticsError"
            }
          }
        }
      }
    }
  }
};
var InnerError = {
  type: {
    name: "Composite",
    className: "InnerError",
    modelProperties: {
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      message: {
        serializedName: "message",
        required: true,
        type: {
          name: "String"
        }
      },
      details: {
        serializedName: "details",
        type: {
          name: "Dictionary",
          value: { type: { name: "String" } }
        }
      },
      target: {
        serializedName: "target",
        type: {
          name: "String"
        }
      },
      innererror: {
        serializedName: "innererror",
        type: {
          name: "Composite",
          className: "InnerError"
        }
      }
    }
  }
};
var JobMetadata = {
  type: {
    name: "Composite",
    className: "JobMetadata",
    modelProperties: {
      createdDateTime: {
        serializedName: "createdDateTime",
        required: true,
        type: {
          name: "DateTime"
        }
      },
      expirationDateTime: {
        serializedName: "expirationDateTime",
        type: {
          name: "DateTime"
        }
      },
      jobId: {
        serializedName: "jobId",
        required: true,
        type: {
          name: "Uuid"
        }
      },
      lastUpdateDateTime: {
        serializedName: "lastUpdateDateTime",
        required: true,
        type: {
          name: "DateTime"
        }
      },
      status: {
        serializedName: "status",
        required: true,
        type: {
          name: "Enum",
          allowedValues: [
            "notStarted",
            "running",
            "succeeded",
            "failed",
            "rejected",
            "cancelled",
            "cancelling"
          ]
        }
      }
    }
  }
};
var AnalyzeJobDisplayName = {
  type: {
    name: "Composite",
    className: "AnalyzeJobDisplayName",
    modelProperties: {
      displayName: {
        serializedName: "displayName",
        type: {
          name: "String"
        }
      }
    }
  }
};
var TasksState = {
  type: {
    name: "Composite",
    className: "TasksState",
    modelProperties: {
      tasks: {
        serializedName: "tasks",
        type: {
          name: "Composite",
          className: "TasksStateTasks"
        }
      }
    }
  }
};
var TasksStateTasks = {
  type: {
    name: "Composite",
    className: "TasksStateTasks",
    modelProperties: {
      completed: {
        serializedName: "completed",
        required: true,
        type: {
          name: "Number"
        }
      },
      failed: {
        serializedName: "failed",
        required: true,
        type: {
          name: "Number"
        }
      },
      inProgress: {
        serializedName: "inProgress",
        required: true,
        type: {
          name: "Number"
        }
      },
      total: {
        serializedName: "total",
        required: true,
        type: {
          name: "Number"
        }
      },
      entityRecognitionTasks: {
        serializedName: "entityRecognitionTasks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TasksStateTasksEntityRecognitionTasksItem"
            }
          }
        }
      },
      entityRecognitionPiiTasks: {
        serializedName: "entityRecognitionPiiTasks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TasksStateTasksEntityRecognitionPiiTasksItem"
            }
          }
        }
      },
      keyPhraseExtractionTasks: {
        serializedName: "keyPhraseExtractionTasks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TasksStateTasksKeyPhraseExtractionTasksItem"
            }
          }
        }
      },
      entityLinkingTasks: {
        serializedName: "entityLinkingTasks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TasksStateTasksEntityLinkingTasksItem"
            }
          }
        }
      },
      sentimentAnalysisTasks: {
        serializedName: "sentimentAnalysisTasks",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TasksStateTasksSentimentAnalysisTasksItem"
            }
          }
        }
      }
    }
  }
};
var TaskState = {
  type: {
    name: "Composite",
    className: "TaskState",
    modelProperties: {
      lastUpdateDateTime: {
        serializedName: "lastUpdateDateTime",
        required: true,
        type: {
          name: "DateTime"
        }
      },
      status: {
        serializedName: "status",
        required: true,
        type: {
          name: "Enum",
          allowedValues: [
            "notStarted",
            "running",
            "succeeded",
            "failed",
            "rejected",
            "cancelled",
            "cancelling"
          ]
        }
      }
    }
  }
};
var EntitiesTaskResult = {
  type: {
    name: "Composite",
    className: "EntitiesTaskResult",
    modelProperties: {
      results: {
        serializedName: "results",
        type: {
          name: "Composite",
          className: "EntitiesResult"
        }
      }
    }
  }
};
var EntitiesResult = {
  type: {
    name: "Composite",
    className: "EntitiesResult",
    modelProperties: {
      documents: {
        serializedName: "documents",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentEntities"
            }
          }
        }
      },
      errors: {
        serializedName: "errors",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentError"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentBatchStatistics"
        }
      },
      modelVersion: {
        serializedName: "modelVersion",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var DocumentEntities = {
  type: {
    name: "Composite",
    className: "DocumentEntities",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      entities: {
        serializedName: "entities",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Entity"
            }
          }
        }
      },
      warnings: {
        serializedName: "warnings",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TextAnalyticsWarning"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentStatistics"
        }
      }
    }
  }
};
var Entity = {
  type: {
    name: "Composite",
    className: "Entity",
    modelProperties: {
      text: {
        serializedName: "text",
        required: true,
        type: {
          name: "String"
        }
      },
      category: {
        serializedName: "category",
        required: true,
        type: {
          name: "String"
        }
      },
      subCategory: {
        serializedName: "subcategory",
        type: {
          name: "String"
        }
      },
      offset: {
        serializedName: "offset",
        required: true,
        type: {
          name: "Number"
        }
      },
      length: {
        serializedName: "length",
        required: true,
        type: {
          name: "Number"
        }
      },
      confidenceScore: {
        serializedName: "confidenceScore",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
var TextAnalyticsWarning = {
  type: {
    name: "Composite",
    className: "TextAnalyticsWarning",
    modelProperties: {
      code: {
        serializedName: "code",
        required: true,
        type: {
          name: "String"
        }
      },
      message: {
        serializedName: "message",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var TextDocumentStatistics = {
  type: {
    name: "Composite",
    className: "TextDocumentStatistics",
    modelProperties: {
      characterCount: {
        serializedName: "charactersCount",
        required: true,
        type: {
          name: "Number"
        }
      },
      transactionCount: {
        serializedName: "transactionsCount",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
var DocumentError = {
  type: {
    name: "Composite",
    className: "DocumentError",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      error: {
        serializedName: "error",
        type: {
          name: "Composite",
          className: "TextAnalyticsError"
        }
      }
    }
  }
};
var TextDocumentBatchStatistics = {
  type: {
    name: "Composite",
    className: "TextDocumentBatchStatistics",
    modelProperties: {
      documentCount: {
        serializedName: "documentsCount",
        required: true,
        type: {
          name: "Number"
        }
      },
      validDocumentCount: {
        serializedName: "validDocumentsCount",
        required: true,
        type: {
          name: "Number"
        }
      },
      erroneousDocumentCount: {
        serializedName: "erroneousDocumentsCount",
        required: true,
        type: {
          name: "Number"
        }
      },
      transactionCount: {
        serializedName: "transactionsCount",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
var PiiTaskResult = {
  type: {
    name: "Composite",
    className: "PiiTaskResult",
    modelProperties: {
      results: {
        serializedName: "results",
        type: {
          name: "Composite",
          className: "PiiResult"
        }
      }
    }
  }
};
var PiiResult = {
  type: {
    name: "Composite",
    className: "PiiResult",
    modelProperties: {
      documents: {
        serializedName: "documents",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "PiiDocumentEntities"
            }
          }
        }
      },
      errors: {
        serializedName: "errors",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentError"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentBatchStatistics"
        }
      },
      modelVersion: {
        serializedName: "modelVersion",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var PiiDocumentEntities = {
  type: {
    name: "Composite",
    className: "PiiDocumentEntities",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      redactedText: {
        serializedName: "redactedText",
        required: true,
        type: {
          name: "String"
        }
      },
      entities: {
        serializedName: "entities",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Entity"
            }
          }
        }
      },
      warnings: {
        serializedName: "warnings",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TextAnalyticsWarning"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentStatistics"
        }
      }
    }
  }
};
var KeyPhraseTaskResult = {
  type: {
    name: "Composite",
    className: "KeyPhraseTaskResult",
    modelProperties: {
      results: {
        serializedName: "results",
        type: {
          name: "Composite",
          className: "KeyPhraseResult"
        }
      }
    }
  }
};
var KeyPhraseResult = {
  type: {
    name: "Composite",
    className: "KeyPhraseResult",
    modelProperties: {
      documents: {
        serializedName: "documents",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentKeyPhrases"
            }
          }
        }
      },
      errors: {
        serializedName: "errors",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentError"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentBatchStatistics"
        }
      },
      modelVersion: {
        serializedName: "modelVersion",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var DocumentKeyPhrases = {
  type: {
    name: "Composite",
    className: "DocumentKeyPhrases",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      keyPhrases: {
        serializedName: "keyPhrases",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "String"
            }
          }
        }
      },
      warnings: {
        serializedName: "warnings",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TextAnalyticsWarning"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentStatistics"
        }
      }
    }
  }
};
var EntityLinkingTaskResult = {
  type: {
    name: "Composite",
    className: "EntityLinkingTaskResult",
    modelProperties: {
      results: {
        serializedName: "results",
        type: {
          name: "Composite",
          className: "EntityLinkingResult"
        }
      }
    }
  }
};
var EntityLinkingResult = {
  type: {
    name: "Composite",
    className: "EntityLinkingResult",
    modelProperties: {
      documents: {
        serializedName: "documents",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentLinkedEntities"
            }
          }
        }
      },
      errors: {
        serializedName: "errors",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentError"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentBatchStatistics"
        }
      },
      modelVersion: {
        serializedName: "modelVersion",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var DocumentLinkedEntities = {
  type: {
    name: "Composite",
    className: "DocumentLinkedEntities",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      entities: {
        serializedName: "entities",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "LinkedEntity"
            }
          }
        }
      },
      warnings: {
        serializedName: "warnings",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TextAnalyticsWarning"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentStatistics"
        }
      }
    }
  }
};
var LinkedEntity = {
  type: {
    name: "Composite",
    className: "LinkedEntity",
    modelProperties: {
      name: {
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      matches: {
        serializedName: "matches",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "Match"
            }
          }
        }
      },
      language: {
        serializedName: "language",
        required: true,
        type: {
          name: "String"
        }
      },
      dataSourceEntityId: {
        serializedName: "id",
        type: {
          name: "String"
        }
      },
      url: {
        serializedName: "url",
        required: true,
        type: {
          name: "String"
        }
      },
      dataSource: {
        serializedName: "dataSource",
        required: true,
        type: {
          name: "String"
        }
      },
      bingEntitySearchApiId: {
        serializedName: "bingId",
        type: {
          name: "String"
        }
      }
    }
  }
};
var Match = {
  type: {
    name: "Composite",
    className: "Match",
    modelProperties: {
      confidenceScore: {
        serializedName: "confidenceScore",
        required: true,
        type: {
          name: "Number"
        }
      },
      text: {
        serializedName: "text",
        required: true,
        type: {
          name: "String"
        }
      },
      offset: {
        serializedName: "offset",
        required: true,
        type: {
          name: "Number"
        }
      },
      length: {
        serializedName: "length",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
var SentimentTaskResult = {
  type: {
    name: "Composite",
    className: "SentimentTaskResult",
    modelProperties: {
      results: {
        serializedName: "results",
        type: {
          name: "Composite",
          className: "SentimentResponse"
        }
      }
    }
  }
};
var SentimentResponse = {
  type: {
    name: "Composite",
    className: "SentimentResponse",
    modelProperties: {
      documents: {
        serializedName: "documents",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentSentiment"
            }
          }
        }
      },
      errors: {
        serializedName: "errors",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentError"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentBatchStatistics"
        }
      },
      modelVersion: {
        serializedName: "modelVersion",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var DocumentSentiment = {
  type: {
    name: "Composite",
    className: "DocumentSentiment",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      sentiment: {
        serializedName: "sentiment",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["positive", "neutral", "negative", "mixed"]
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentStatistics"
        }
      },
      confidenceScores: {
        serializedName: "confidenceScores",
        type: {
          name: "Composite",
          className: "SentimentConfidenceScores"
        }
      },
      sentenceSentiments: {
        serializedName: "sentences",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SentenceSentiment"
            }
          }
        }
      },
      warnings: {
        serializedName: "warnings",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TextAnalyticsWarning"
            }
          }
        }
      }
    }
  }
};
var SentimentConfidenceScores = {
  type: {
    name: "Composite",
    className: "SentimentConfidenceScores",
    modelProperties: {
      positive: {
        serializedName: "positive",
        required: true,
        type: {
          name: "Number"
        }
      },
      neutral: {
        serializedName: "neutral",
        required: true,
        type: {
          name: "Number"
        }
      },
      negative: {
        serializedName: "negative",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
var SentenceSentiment = {
  type: {
    name: "Composite",
    className: "SentenceSentiment",
    modelProperties: {
      text: {
        serializedName: "text",
        required: true,
        type: {
          name: "String"
        }
      },
      sentiment: {
        serializedName: "sentiment",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["positive", "neutral", "negative"]
        }
      },
      confidenceScores: {
        serializedName: "confidenceScores",
        type: {
          name: "Composite",
          className: "SentimentConfidenceScores"
        }
      },
      offset: {
        serializedName: "offset",
        required: true,
        type: {
          name: "Number"
        }
      },
      length: {
        serializedName: "length",
        required: true,
        type: {
          name: "Number"
        }
      },
      targets: {
        serializedName: "targets",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SentenceTarget"
            }
          }
        }
      },
      assessments: {
        serializedName: "assessments",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "SentenceAssessment"
            }
          }
        }
      }
    }
  }
};
var SentenceTarget = {
  type: {
    name: "Composite",
    className: "SentenceTarget",
    modelProperties: {
      sentiment: {
        serializedName: "sentiment",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["positive", "mixed", "negative"]
        }
      },
      confidenceScores: {
        serializedName: "confidenceScores",
        type: {
          name: "Composite",
          className: "TargetConfidenceScoreLabel"
        }
      },
      offset: {
        serializedName: "offset",
        required: true,
        type: {
          name: "Number"
        }
      },
      length: {
        serializedName: "length",
        required: true,
        type: {
          name: "Number"
        }
      },
      text: {
        serializedName: "text",
        required: true,
        type: {
          name: "String"
        }
      },
      relations: {
        serializedName: "relations",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TargetRelation"
            }
          }
        }
      }
    }
  }
};
var TargetConfidenceScoreLabel = {
  type: {
    name: "Composite",
    className: "TargetConfidenceScoreLabel",
    modelProperties: {
      positive: {
        serializedName: "positive",
        required: true,
        type: {
          name: "Number"
        }
      },
      negative: {
        serializedName: "negative",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
var TargetRelation = {
  type: {
    name: "Composite",
    className: "TargetRelation",
    modelProperties: {
      relationType: {
        serializedName: "relationType",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["assessment", "target"]
        }
      },
      ref: {
        serializedName: "ref",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var SentenceAssessment = {
  type: {
    name: "Composite",
    className: "SentenceAssessment",
    modelProperties: {
      sentiment: {
        serializedName: "sentiment",
        required: true,
        type: {
          name: "Enum",
          allowedValues: ["positive", "mixed", "negative"]
        }
      },
      confidenceScores: {
        serializedName: "confidenceScores",
        type: {
          name: "Composite",
          className: "TargetConfidenceScoreLabel"
        }
      },
      offset: {
        serializedName: "offset",
        required: true,
        type: {
          name: "Number"
        }
      },
      length: {
        serializedName: "length",
        required: true,
        type: {
          name: "Number"
        }
      },
      text: {
        serializedName: "text",
        required: true,
        type: {
          name: "String"
        }
      },
      isNegated: {
        serializedName: "isNegated",
        required: true,
        type: {
          name: "Boolean"
        }
      }
    }
  }
};
var AnalyzeJobErrorsAndStatistics = {
  type: {
    name: "Composite",
    className: "AnalyzeJobErrorsAndStatistics",
    modelProperties: {
      errors: {
        serializedName: "errors",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TextAnalyticsError"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentBatchStatistics"
        }
      }
    }
  }
};
var Pagination = {
  type: {
    name: "Composite",
    className: "Pagination",
    modelProperties: {
      nextLink: {
        serializedName: "@nextLink",
        type: {
          name: "String"
        }
      }
    }
  }
};
var HealthcareTaskResult = {
  type: {
    name: "Composite",
    className: "HealthcareTaskResult",
    modelProperties: {
      results: {
        serializedName: "results",
        type: {
          name: "Composite",
          className: "HealthcareResult"
        }
      },
      errors: {
        serializedName: "errors",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TextAnalyticsError"
            }
          }
        }
      }
    }
  }
};
var HealthcareResult = {
  type: {
    name: "Composite",
    className: "HealthcareResult",
    modelProperties: {
      documents: {
        serializedName: "documents",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentHealthcareEntities"
            }
          }
        }
      },
      errors: {
        serializedName: "errors",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentError"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentBatchStatistics"
        }
      },
      modelVersion: {
        serializedName: "modelVersion",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var DocumentHealthcareEntities = {
  type: {
    name: "Composite",
    className: "DocumentHealthcareEntities",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      entities: {
        serializedName: "entities",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "HealthcareEntity"
            }
          }
        }
      },
      relations: {
        serializedName: "relations",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "HealthcareRelation"
            }
          }
        }
      },
      warnings: {
        serializedName: "warnings",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TextAnalyticsWarning"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentStatistics"
        }
      }
    }
  }
};
var HealthcareEntityProperties = {
  type: {
    name: "Composite",
    className: "HealthcareEntityProperties",
    modelProperties: {
      text: {
        serializedName: "text",
        required: true,
        type: {
          name: "String"
        }
      },
      category: {
        serializedName: "category",
        required: true,
        type: {
          name: "String"
        }
      },
      subcategory: {
        serializedName: "subcategory",
        type: {
          name: "String"
        }
      },
      offset: {
        serializedName: "offset",
        required: true,
        type: {
          name: "Number"
        }
      },
      length: {
        serializedName: "length",
        required: true,
        type: {
          name: "Number"
        }
      },
      confidenceScore: {
        serializedName: "confidenceScore",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
var HealthcareLinkingProperties = {
  type: {
    name: "Composite",
    className: "HealthcareLinkingProperties",
    modelProperties: {
      assertion: {
        serializedName: "assertion",
        type: {
          name: "Composite",
          className: "HealthcareAssertion"
        }
      },
      name: {
        serializedName: "name",
        type: {
          name: "String"
        }
      },
      links: {
        serializedName: "links",
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "HealthcareEntityLink"
            }
          }
        }
      }
    }
  }
};
var HealthcareAssertion = {
  type: {
    name: "Composite",
    className: "HealthcareAssertion",
    modelProperties: {
      conditionality: {
        serializedName: "conditionality",
        type: {
          name: "Enum",
          allowedValues: ["hypothetical", "conditional"]
        }
      },
      certainty: {
        serializedName: "certainty",
        type: {
          name: "Enum",
          allowedValues: [
            "positive",
            "positivePossible",
            "neutralPossible",
            "negativePossible",
            "negative"
          ]
        }
      },
      association: {
        serializedName: "association",
        type: {
          name: "Enum",
          allowedValues: ["subject", "other"]
        }
      }
    }
  }
};
var HealthcareEntityLink = {
  type: {
    name: "Composite",
    className: "HealthcareEntityLink",
    modelProperties: {
      dataSource: {
        serializedName: "dataSource",
        required: true,
        type: {
          name: "String"
        }
      },
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var HealthcareRelation = {
  type: {
    name: "Composite",
    className: "HealthcareRelation",
    modelProperties: {
      relationType: {
        serializedName: "relationType",
        required: true,
        type: {
          name: "String"
        }
      },
      entities: {
        serializedName: "entities",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "HealthcareRelationEntity"
            }
          }
        }
      }
    }
  }
};
var HealthcareRelationEntity = {
  type: {
    name: "Composite",
    className: "HealthcareRelationEntity",
    modelProperties: {
      ref: {
        serializedName: "ref",
        required: true,
        type: {
          name: "String"
        }
      },
      role: {
        serializedName: "role",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var LanguageBatchInput = {
  type: {
    name: "Composite",
    className: "LanguageBatchInput",
    modelProperties: {
      documents: {
        serializedName: "documents",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DetectLanguageInput"
            }
          }
        }
      }
    }
  }
};
var DetectLanguageInput = {
  type: {
    name: "Composite",
    className: "DetectLanguageInput",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      text: {
        serializedName: "text",
        required: true,
        type: {
          name: "String"
        }
      },
      countryHint: {
        serializedName: "countryHint",
        type: {
          name: "String"
        }
      }
    }
  }
};
var LanguageResult = {
  type: {
    name: "Composite",
    className: "LanguageResult",
    modelProperties: {
      documents: {
        serializedName: "documents",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentLanguage"
            }
          }
        }
      },
      errors: {
        serializedName: "errors",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "DocumentError"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentBatchStatistics"
        }
      },
      modelVersion: {
        serializedName: "modelVersion",
        required: true,
        type: {
          name: "String"
        }
      }
    }
  }
};
var DocumentLanguage = {
  type: {
    name: "Composite",
    className: "DocumentLanguage",
    modelProperties: {
      id: {
        serializedName: "id",
        required: true,
        type: {
          name: "String"
        }
      },
      detectedLanguage: {
        serializedName: "detectedLanguage",
        type: {
          name: "Composite",
          className: "DetectedLanguage"
        }
      },
      warnings: {
        serializedName: "warnings",
        required: true,
        type: {
          name: "Sequence",
          element: {
            type: {
              name: "Composite",
              className: "TextAnalyticsWarning"
            }
          }
        }
      },
      statistics: {
        serializedName: "statistics",
        type: {
          name: "Composite",
          className: "TextDocumentStatistics"
        }
      }
    }
  }
};
var DetectedLanguage = {
  type: {
    name: "Composite",
    className: "DetectedLanguage",
    modelProperties: {
      name: {
        serializedName: "name",
        required: true,
        type: {
          name: "String"
        }
      },
      iso6391Name: {
        serializedName: "iso6391Name",
        required: true,
        type: {
          name: "String"
        }
      },
      confidenceScore: {
        serializedName: "confidenceScore",
        required: true,
        type: {
          name: "Number"
        }
      }
    }
  }
};
var AnalyzeBatchInput = {
  type: {
    name: "Composite",
    className: "AnalyzeBatchInput",
    modelProperties: Object.assign(Object.assign(Object.assign({}, JobDescriptor.type.modelProperties), AnalysisInput.type.modelProperties), JobManifest.type.modelProperties)
  }
};
var AnalyzeJobMetadata = {
  type: {
    name: "Composite",
    className: "AnalyzeJobMetadata",
    modelProperties: Object.assign(Object.assign({}, JobMetadata.type.modelProperties), AnalyzeJobDisplayName.type.modelProperties)
  }
};
var HealthcareJobState = {
  type: {
    name: "Composite",
    className: "HealthcareJobState",
    modelProperties: Object.assign(Object.assign(Object.assign({}, JobMetadata.type.modelProperties), HealthcareTaskResult.type.modelProperties), Pagination.type.modelProperties)
  }
};
var AnalyzeJobState = {
  type: {
    name: "Composite",
    className: "AnalyzeJobState",
    modelProperties: Object.assign(Object.assign(Object.assign(Object.assign({}, AnalyzeJobMetadata.type.modelProperties), TasksState.type.modelProperties), AnalyzeJobErrorsAndStatistics.type.modelProperties), Pagination.type.modelProperties)
  }
};
var TasksStateTasksEntityRecognitionTasksItem = {
  type: {
    name: "Composite",
    className: "TasksStateTasksEntityRecognitionTasksItem",
    modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), EntitiesTaskResult.type.modelProperties)
  }
};
var TasksStateTasksEntityRecognitionPiiTasksItem = {
  type: {
    name: "Composite",
    className: "TasksStateTasksEntityRecognitionPiiTasksItem",
    modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), PiiTaskResult.type.modelProperties)
  }
};
var TasksStateTasksKeyPhraseExtractionTasksItem = {
  type: {
    name: "Composite",
    className: "TasksStateTasksKeyPhraseExtractionTasksItem",
    modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), KeyPhraseTaskResult.type.modelProperties)
  }
};
var TasksStateTasksEntityLinkingTasksItem = {
  type: {
    name: "Composite",
    className: "TasksStateTasksEntityLinkingTasksItem",
    modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), EntityLinkingTaskResult.type.modelProperties)
  }
};
var TasksStateTasksSentimentAnalysisTasksItem = {
  type: {
    name: "Composite",
    className: "TasksStateTasksSentimentAnalysisTasksItem",
    modelProperties: Object.assign(Object.assign({}, TaskState.type.modelProperties), SentimentTaskResult.type.modelProperties)
  }
};
var HealthcareEntity = {
  type: {
    name: "Composite",
    className: "HealthcareEntity",
    modelProperties: Object.assign(Object.assign({}, HealthcareEntityProperties.type.modelProperties), HealthcareLinkingProperties.type.modelProperties)
  }
};
var GeneratedClientAnalyzeHeaders = {
  type: {
    name: "Composite",
    className: "GeneratedClientAnalyzeHeaders",
    modelProperties: {
      operationLocation: {
        serializedName: "operation-location",
        type: {
          name: "String"
        }
      }
    }
  }
};
var GeneratedClientCancelHealthJobHeaders = {
  type: {
    name: "Composite",
    className: "GeneratedClientCancelHealthJobHeaders",
    modelProperties: {
      operationLocation: {
        serializedName: "operation-location",
        type: {
          name: "String"
        }
      }
    }
  }
};
var GeneratedClientHealthHeaders = {
  type: {
    name: "Composite",
    className: "GeneratedClientHealthHeaders",
    modelProperties: {
      operationLocation: {
        serializedName: "operation-location",
        type: {
          name: "String"
        }
      }
    }
  }
};

// node_modules/@azure/ai-text-analytics/dist-esm/src/generated/models/parameters.js
var contentType = {
  parameterPath: ["options", "contentType"],
  mapper: {
    defaultValue: "application/json",
    isConstant: true,
    serializedName: "Content-Type",
    type: {
      name: "String"
    }
  }
};
var body = {
  parameterPath: ["options", "body"],
  mapper: AnalyzeBatchInput
};
var accept = {
  parameterPath: "accept",
  mapper: {
    defaultValue: "application/json, text/json",
    isConstant: true,
    serializedName: "Accept",
    type: {
      name: "String"
    }
  }
};
var endpoint = {
  parameterPath: "endpoint",
  mapper: {
    serializedName: "Endpoint",
    required: true,
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
var apiVersion = {
  parameterPath: "apiVersion",
  mapper: {
    defaultValue: "v3.1",
    isConstant: true,
    serializedName: "ApiVersion",
    type: {
      name: "String"
    }
  },
  skipEncoding: true
};
var jobId = {
  parameterPath: "jobId",
  mapper: {
    serializedName: "jobId",
    required: true,
    type: {
      name: "String"
    }
  }
};
var includeStatistics = {
  parameterPath: ["options", "includeStatistics"],
  mapper: {
    serializedName: "showStats",
    type: {
      name: "Boolean"
    }
  }
};
var top = {
  parameterPath: ["options", "top"],
  mapper: {
    defaultValue: 20,
    constraints: {
      InclusiveMaximum: 50,
      InclusiveMinimum: 1
    },
    serializedName: "$top",
    type: {
      name: "Number"
    }
  }
};
var skip = {
  parameterPath: ["options", "skip"],
  mapper: {
    constraints: {
      InclusiveMinimum: 0
    },
    serializedName: "$skip",
    type: {
      name: "Number"
    }
  }
};
var jobId1 = {
  parameterPath: "jobId",
  mapper: {
    serializedName: "jobId",
    required: true,
    type: {
      name: "Uuid"
    }
  }
};
var input = {
  parameterPath: "input",
  mapper: MultiLanguageBatchInput
};
var modelVersion = {
  parameterPath: ["options", "modelVersion"],
  mapper: {
    serializedName: "model-version",
    type: {
      name: "String"
    }
  }
};
var stringIndexType = {
  parameterPath: ["options", "stringIndexType"],
  mapper: {
    serializedName: "stringIndexType",
    type: {
      name: "String"
    }
  }
};
var loggingOptOut = {
  parameterPath: ["options", "loggingOptOut"],
  mapper: {
    serializedName: "loggingOptOut",
    type: {
      name: "Boolean"
    }
  }
};
var domain = {
  parameterPath: ["options", "domain"],
  mapper: {
    serializedName: "domain",
    type: {
      name: "String"
    }
  }
};
var piiCategories = {
  parameterPath: ["options", "piiCategories"],
  mapper: {
    constraints: {
      UniqueItems: true
    },
    serializedName: "piiCategories",
    type: {
      name: "Sequence",
      element: {
        type: {
          name: "String"
        }
      }
    }
  },
  collectionFormat: "CSV"
};
var input1 = {
  parameterPath: "input",
  mapper: LanguageBatchInput
};
var opinionMining = {
  parameterPath: ["options", "opinionMining"],
  mapper: {
    serializedName: "opinionMining",
    type: {
      name: "Boolean"
    }
  }
};

// node_modules/@azure/ai-text-analytics/dist-esm/src/generated/generatedClientContext.js
var GeneratedClientContext = class extends ServiceClient {
  /**
   * Initializes a new instance of the GeneratedClientContext class.
   * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
   *                 https://westus.api.cognitive.microsoft.com).
   * @param options The parameter options
   */
  constructor(endpoint2, options) {
    if (endpoint2 === void 0) {
      throw new Error("'endpoint' cannot be null");
    }
    if (!options) {
      options = {};
    }
    const defaults = {
      requestContentType: "application/json; charset=utf-8"
    };
    const packageDetails = `azsdk-js-ai-text-analytics/5.1.0`;
    const userAgentPrefix = options.userAgentOptions && options.userAgentOptions.userAgentPrefix ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;
    const optionsWithDefaults = Object.assign(Object.assign(Object.assign({}, defaults), options), { userAgentOptions: {
      userAgentPrefix
    }, baseUri: options.endpoint || "{Endpoint}/text/analytics/{ApiVersion}" });
    super(optionsWithDefaults);
    this.endpoint = endpoint2;
    this.apiVersion = options.apiVersion || "v3.1";
  }
};

// node_modules/@azure/ai-text-analytics/dist-esm/src/generated/generatedClient.js
var GeneratedClient = class extends GeneratedClientContext {
  /**
   * Initializes a new instance of the GeneratedClient class.
   * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
   *                 https://westus.api.cognitive.microsoft.com).
   * @param options The parameter options
   */
  constructor(endpoint2, options) {
    super(endpoint2, options);
  }
  /**
   * Submit a collection of text documents for analysis. Specify one or more unique tasks to be executed.
   * @param options The options parameters.
   */
  analyze(options) {
    return this.sendOperationRequest({ options }, analyzeOperationSpec);
  }
  /**
   * Get the status of an analysis job.  A job may consist of one or more tasks.  Once all tasks are
   * completed, the job will transition to the completed state and results will be available for each
   * task.
   * @param jobId Job ID for Analyze
   * @param options The options parameters.
   */
  analyzeStatus(jobId2, options) {
    return this.sendOperationRequest({ jobId: jobId2, options }, analyzeStatusOperationSpec);
  }
  /**
   * Get details of the healthcare prediction job specified by the jobId.
   * @param jobId Job ID
   * @param options The options parameters.
   */
  healthStatus(jobId2, options) {
    return this.sendOperationRequest({ jobId: jobId2, options }, healthStatusOperationSpec);
  }
  /**
   * Cancel healthcare prediction job.
   * @param jobId Job ID
   * @param options The options parameters.
   */
  cancelHealthJob(jobId2, options) {
    return this.sendOperationRequest({ jobId: jobId2, options }, cancelHealthJobOperationSpec);
  }
  /**
   * Start a healthcare analysis job to recognize healthcare related entities (drugs, conditions,
   * symptoms, etc) and their relations.
   * @param input Collection of documents to analyze.
   * @param options The options parameters.
   */
  health(input2, options) {
    return this.sendOperationRequest({ input: input2, options }, healthOperationSpec);
  }
  /**
   * The API returns a list of general named entities in a given document. For the list of supported
   * entity types, check <a href="https://aka.ms/taner">Supported Entity Types in Text Analytics API</a>.
   * See the <a href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list
   * of enabled languages.
   * @param input Collection of documents to analyze.
   * @param options The options parameters.
   */
  entitiesRecognitionGeneral(input2, options) {
    return this.sendOperationRequest({ input: input2, options }, entitiesRecognitionGeneralOperationSpec);
  }
  /**
   * The API returns a list of entities with personal information (\"SSN\", \"Bank Account\" etc) in the
   * document. For the list of supported entity types, check <a href="https://aka.ms/tanerpii">Supported
   * Entity Types in Text Analytics API</a>. See the <a href="https://aka.ms/talangs">Supported languages
   * in Text Analytics API</a> for the list of enabled languages.
   *
   * @param input Collection of documents to analyze.
   * @param options The options parameters.
   */
  entitiesRecognitionPii(input2, options) {
    return this.sendOperationRequest({ input: input2, options }, entitiesRecognitionPiiOperationSpec);
  }
  /**
   * The API returns a list of recognized entities with links to a well known knowledge base. See the <a
   * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
   * languages.
   * @param input Collection of documents to analyze.
   * @param options The options parameters.
   */
  entitiesLinking(input2, options) {
    return this.sendOperationRequest({ input: input2, options }, entitiesLinkingOperationSpec);
  }
  /**
   * The API returns a list of strings denoting the key phrases in the input text. See the <a
   * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
   * languages.
   * @param input Collection of documents to analyze.
   * @param options The options parameters.
   */
  keyPhrases(input2, options) {
    return this.sendOperationRequest({ input: input2, options }, keyPhrasesOperationSpec);
  }
  /**
   * The API returns the detected language and a numeric score between 0 and 1. Scores close to 1
   * indicate 100% certainty that the identified language is true. See the <a
   * href="https://aka.ms/talangs">Supported languages in Text Analytics API</a> for the list of enabled
   * languages.
   * @param input Collection of documents to analyze for language endpoint.
   * @param options The options parameters.
   */
  languages(input2, options) {
    return this.sendOperationRequest({ input: input2, options }, languagesOperationSpec);
  }
  /**
   * The API returns a detailed sentiment analysis for the input text. The analysis is done in multiple
   * levels of granularity, start from the a document level, down to sentence and key terms (targets and
   * assessments).
   * @param input Collection of documents to analyze.
   * @param options The options parameters.
   */
  sentiment(input2, options) {
    return this.sendOperationRequest({ input: input2, options }, sentimentOperationSpec);
  }
};
var serializer = createSerializer(
  mappers_exports,
  /* isXml */
  false
);
var analyzeOperationSpec = {
  path: "/analyze",
  httpMethod: "POST",
  responses: {
    202: {
      headersMapper: GeneratedClientAnalyzeHeaders
    },
    default: {
      bodyMapper: ErrorResponse
    }
  },
  requestBody: body,
  urlParameters: [endpoint, apiVersion],
  headerParameters: [contentType, accept],
  mediaType: "json",
  serializer
};
var analyzeStatusOperationSpec = {
  path: "/analyze/jobs/{jobId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: AnalyzeJobState
    },
    default: {
      bodyMapper: ErrorResponse
    }
  },
  queryParameters: [
    includeStatistics,
    top,
    skip
  ],
  urlParameters: [endpoint, apiVersion, jobId],
  headerParameters: [accept],
  serializer
};
var healthStatusOperationSpec = {
  path: "/entities/health/jobs/{jobId}",
  httpMethod: "GET",
  responses: {
    200: {
      bodyMapper: HealthcareJobState
    },
    default: {
      bodyMapper: ErrorResponse
    }
  },
  queryParameters: [
    includeStatistics,
    top,
    skip
  ],
  urlParameters: [
    endpoint,
    apiVersion,
    jobId1
  ],
  headerParameters: [accept],
  serializer
};
var cancelHealthJobOperationSpec = {
  path: "/entities/health/jobs/{jobId}",
  httpMethod: "DELETE",
  responses: {
    202: {
      headersMapper: GeneratedClientCancelHealthJobHeaders
    },
    default: {
      bodyMapper: ErrorResponse
    }
  },
  urlParameters: [
    endpoint,
    apiVersion,
    jobId1
  ],
  headerParameters: [accept],
  serializer
};
var healthOperationSpec = {
  path: "/entities/health/jobs",
  httpMethod: "POST",
  responses: {
    202: {
      headersMapper: GeneratedClientHealthHeaders
    },
    default: {
      bodyMapper: ErrorResponse
    }
  },
  requestBody: input,
  queryParameters: [
    modelVersion,
    stringIndexType,
    loggingOptOut
  ],
  urlParameters: [endpoint, apiVersion],
  headerParameters: [contentType, accept],
  mediaType: "json",
  serializer
};
var entitiesRecognitionGeneralOperationSpec = {
  path: "/entities/recognition/general",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: EntitiesResult
    },
    default: {
      bodyMapper: ErrorResponse
    }
  },
  requestBody: input,
  queryParameters: [
    includeStatistics,
    modelVersion,
    stringIndexType,
    loggingOptOut
  ],
  urlParameters: [endpoint, apiVersion],
  headerParameters: [contentType, accept],
  mediaType: "json",
  serializer
};
var entitiesRecognitionPiiOperationSpec = {
  path: "/entities/recognition/pii",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: PiiResult
    },
    default: {
      bodyMapper: ErrorResponse
    }
  },
  requestBody: input,
  queryParameters: [
    includeStatistics,
    modelVersion,
    stringIndexType,
    loggingOptOut,
    domain,
    piiCategories
  ],
  urlParameters: [endpoint, apiVersion],
  headerParameters: [contentType, accept],
  mediaType: "json",
  serializer
};
var entitiesLinkingOperationSpec = {
  path: "/entities/linking",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: EntityLinkingResult
    },
    default: {
      bodyMapper: ErrorResponse
    }
  },
  requestBody: input,
  queryParameters: [
    includeStatistics,
    modelVersion,
    stringIndexType,
    loggingOptOut
  ],
  urlParameters: [endpoint, apiVersion],
  headerParameters: [contentType, accept],
  mediaType: "json",
  serializer
};
var keyPhrasesOperationSpec = {
  path: "/keyPhrases",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: KeyPhraseResult
    },
    default: {
      bodyMapper: ErrorResponse
    }
  },
  requestBody: input,
  queryParameters: [
    includeStatistics,
    modelVersion,
    loggingOptOut
  ],
  urlParameters: [endpoint, apiVersion],
  headerParameters: [contentType, accept],
  mediaType: "json",
  serializer
};
var languagesOperationSpec = {
  path: "/languages",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: LanguageResult
    },
    default: {
      bodyMapper: ErrorResponse
    }
  },
  requestBody: input1,
  queryParameters: [
    includeStatistics,
    modelVersion,
    loggingOptOut
  ],
  urlParameters: [endpoint, apiVersion],
  headerParameters: [contentType, accept],
  mediaType: "json",
  serializer
};
var sentimentOperationSpec = {
  path: "/sentiment",
  httpMethod: "POST",
  responses: {
    200: {
      bodyMapper: SentimentResponse
    },
    default: {
      bodyMapper: ErrorResponse
    }
  },
  requestBody: input,
  queryParameters: [
    includeStatistics,
    modelVersion,
    stringIndexType,
    loggingOptOut,
    opinionMining
  ],
  urlParameters: [endpoint, apiVersion],
  headerParameters: [contentType, accept],
  mediaType: "json",
  serializer
};

// node_modules/@azure/ai-text-analytics/dist-esm/src/logger.js
var logger2 = createClientLogger("ai-text-analytics");

// node_modules/@azure/ai-text-analytics/dist-esm/src/utils/url.browser.js
var url = URL;
var urlSearchParams = URLSearchParams;

// node_modules/@azure/ai-text-analytics/dist-esm/src/util.js
function sortResponseIdObjects(sortedArray, unsortedArray) {
  const unsortedMap = /* @__PURE__ */ new Map();
  for (const item of unsortedArray) {
    unsortedMap.set(item.id, item);
  }
  if (unsortedArray.length !== sortedArray.length) {
    const ordinal = unsortedArray.length > sortedArray.length ? "more" : "fewer";
    logger2.warning(`The service returned ${ordinal} responses than inputs. Some errors may be treated as fatal.`);
  }
  const result = [];
  for (const sortedItem of sortedArray) {
    const item = unsortedMap.get(sortedItem.id);
    if (item) {
      result.push(item);
    }
  }
  return result;
}
function parseAssessmentIndex(pointer) {
  const regex = new RegExp(/#\/documents\/(\d+)\/sentences\/(\d+)\/assessments\/(\d+)/);
  const res = regex.exec(pointer);
  if (res !== null) {
    const assessmentIndex = {
      document: parseInt(res[1]),
      sentence: parseInt(res[2]),
      assessment: parseInt(res[3])
    };
    return assessmentIndex;
  } else {
    throw new Error(`Pointer "${pointer}" is not a valid Assessment pointer`);
  }
}
function parseHealthcareEntityIndex(pointer) {
  const regex = new RegExp(/#\/results\/documents\/(\d+)\/entities\/(\d+)/);
  const res = regex.exec(pointer);
  if (res !== null) {
    return parseInt(res[2]);
  } else {
    throw new Error(`Pointer "${pointer}" is not a valid healthcare entity pointer`);
  }
}
var jsEncodingUnit = "Utf16CodeUnit";
function addStrEncodingParam(options) {
  return Object.assign(Object.assign({}, options), { stringIndexType: options.stringIndexType || jsEncodingUnit });
}
function setStrEncodingParam(x) {
  return Object.assign(Object.assign({}, x), { stringIndexType: x.stringIndexType || jsEncodingUnit });
}
function setStrEncodingParamValue(stringIndexType2) {
  return stringIndexType2 || jsEncodingUnit;
}
function setOpinionMining(x) {
  return Object.assign(Object.assign({}, x), { opinionMining: x.includeOpinionMining });
}
function setCategoriesFilter(x) {
  return Object.assign(Object.assign({}, x), { piiCategories: x.categoriesFilter });
}
function addParamsToTask(action) {
  const { actionName } = action, params = __rest(action, ["actionName"]);
  return { parameters: params, taskName: actionName };
}
function nextLinkToTopAndSkip(nextLink) {
  const url2 = new url(nextLink);
  const searchParams = new urlSearchParams(url2.searchParams);
  let top2;
  if (searchParams.has("$top")) {
    top2 = parseInt(searchParams.get("$top"));
  } else {
    throw new Error(`nextLink URL does not have the $top param: ${nextLink}`);
  }
  let skip2;
  if (searchParams.has("$skip")) {
    skip2 = parseInt(searchParams.get("$skip"));
  } else {
    throw new Error(`nextLink URL does not have the $skip param: ${nextLink}`);
  }
  return {
    skip: skip2,
    top: top2
  };
}
function getOperationId(operationLocation) {
  const lastSlashIndex = operationLocation.lastIndexOf("/");
  return operationLocation.substring(lastSlashIndex + 1);
}
function handleInvalidDocumentBatch(error) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  const castError = error;
  const innerCode = (_d = (_c = (_b = (_a = castError.response) === null || _a === void 0 ? void 0 : _a.parsedBody) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.innererror) === null || _d === void 0 ? void 0 : _d.code;
  const innerMessage = (_h = (_g = (_f = (_e = castError.response) === null || _e === void 0 ? void 0 : _e.parsedBody) === null || _f === void 0 ? void 0 : _f.error) === null || _g === void 0 ? void 0 : _g.innererror) === null || _h === void 0 ? void 0 : _h.message;
  if (innerMessage) {
    return innerCode === "InvalidDocumentBatch" ? new RestError(innerMessage, { code: innerCode, statusCode: castError.statusCode }) : error;
  } else {
    logger2.warning(`The error coming from the service does not follow the expected structure: ${error}`);
    return error;
  }
}
function delay(timeInMs) {
  return new Promise((resolve) => setTimeout(() => resolve(), timeInMs));
}
function compose(fn1, fn2) {
  return (value) => fn2(fn1(value));
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/textAnalyticsResult.js
function intoTextAnalyticsError(errorModel) {
  if (errorModel.innererror !== void 0) {
    return intoTextAnalyticsError(errorModel.innererror);
  }
  return {
    code: errorModel.code,
    message: errorModel.message,
    target: errorModel.target
  };
}
function makeTextAnalyticsSuccessResult(id, warnings, statistics) {
  return {
    id,
    statistics,
    warnings
  };
}
function makeTextAnalyticsErrorResult(id, error) {
  return {
    id,
    error: intoTextAnalyticsError(error)
  };
}
function processAndCombineSuccessfulAndErroneousDocuments(input2, response, processSuccess, processError) {
  const successResults = response.documents.map(processSuccess);
  const unsortedResults = successResults.concat(response.errors.map((error) => processError(error.id, error.error)));
  return sortResponseIdObjects(input2, unsortedResults);
}
function combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input2, response, processSuccess, processError) {
  const sorted = processAndCombineSuccessfulAndErroneousDocuments(input2, response, processSuccess, processError);
  return Object.assign(sorted, {
    statistics: response.statistics,
    modelVersion: response.modelVersion
  });
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/detectLanguageResult.js
function makeDetectLanguageResult(response) {
  const { id, warnings, statistics, detectedLanguage } = response;
  return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { primaryLanguage: detectedLanguage });
}
function makeDetectLanguageErrorResult(id, error) {
  return makeTextAnalyticsErrorResult(id, error);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/detectLanguageResultArray.js
function makeDetectLanguageResultArray(input2, response) {
  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input2, response, makeDetectLanguageResult, makeDetectLanguageErrorResult);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/recognizeCategorizedEntitiesResult.js
function makeRecognizeCategorizedEntitiesResult(result) {
  const { entities, statistics, warnings, id } = result;
  return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
function makeRecognizeCategorizedEntitiesErrorResult(id, error) {
  return makeTextAnalyticsErrorResult(id, error);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/recognizeCategorizedEntitiesResultArray.js
function makeRecognizeCategorizedEntitiesResultArray(input2, response) {
  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input2, response, makeRecognizeCategorizedEntitiesResult, makeRecognizeCategorizedEntitiesErrorResult);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/analyzeSentimentResult.js
function makeAnalyzeSentimentResult(result) {
  const { id, sentiment, confidenceScores, sentenceSentiments: sentences, warnings, statistics } = result;
  return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), {
    sentiment,
    confidenceScores,
    sentences: sentences.map((sentence) => convertGeneratedSentenceSentiment(sentence, result))
  });
}
function makeAnalyzeSentimentErrorResult(id, error) {
  return makeTextAnalyticsErrorResult(id, error);
}
function convertGeneratedSentenceSentiment(sentence, result) {
  return {
    confidenceScores: sentence.confidenceScores,
    sentiment: sentence.sentiment,
    text: sentence.text,
    offset: sentence.offset,
    length: sentence.length,
    opinions: sentence.targets ? sentence.targets.map((target) => ({
      target: {
        confidenceScores: target.confidenceScores,
        sentiment: target.sentiment,
        text: target.text,
        offset: target.offset,
        length: target.length
      },
      assessments: target.relations.filter((relation) => relation.relationType === "assessment").map((relation) => convertTargetRelationToAssessmentSentiment(relation, result))
    })) : []
  };
}
function convertTargetRelationToAssessmentSentiment(targetRelation, result) {
  var _a, _b;
  const assessmentPtr = targetRelation.ref;
  const assessmentIndex = parseAssessmentIndex(assessmentPtr);
  const assessment = (_b = (_a = result.sentenceSentiments) === null || _a === void 0 ? void 0 : _a[assessmentIndex.sentence].assessments) === null || _b === void 0 ? void 0 : _b[assessmentIndex.assessment];
  if (assessment !== void 0) {
    return assessment;
  } else {
    throw new Error(`Pointer "${assessmentPtr}" is not a valid Assessment pointer`);
  }
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/analyzeSentimentResultArray.js
function makeAnalyzeSentimentResultArray(input2, response) {
  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input2, response, makeAnalyzeSentimentResult, makeAnalyzeSentimentErrorResult);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/extractKeyPhrasesResult.js
function makeExtractKeyPhrasesResult(result) {
  const { id, warnings, statistics, keyPhrases } = result;
  return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { keyPhrases });
}
function makeExtractKeyPhrasesErrorResult(id, error) {
  return makeTextAnalyticsErrorResult(id, error);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/extractKeyPhrasesResultArray.js
function makeExtractKeyPhrasesResultArray(input2, response) {
  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input2, response, makeExtractKeyPhrasesResult, makeExtractKeyPhrasesErrorResult);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/recognizePiiEntitiesResult.js
function makeRecognizePiiEntitiesResult(document) {
  const { id, entities, warnings, statistics, redactedText } = document;
  return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), {
    entities,
    redactedText
  });
}
function makeRecognizePiiEntitiesErrorResult(id, error) {
  return makeTextAnalyticsErrorResult(id, error);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/recognizePiiEntitiesResultArray.js
function makeRecognizePiiEntitiesResultArray(input2, response) {
  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input2, response, makeRecognizePiiEntitiesResult, makeRecognizePiiEntitiesErrorResult);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/recognizeLinkedEntitiesResult.js
function makeRecognizeLinkedEntitiesResult(result) {
  const { statistics, id, warnings, entities } = result;
  return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities });
}
function makeRecognizeLinkedEntitiesErrorResult(id, error) {
  return makeTextAnalyticsErrorResult(id, error);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/recognizeLinkedEntitiesResultArray.js
function makeRecognizeLinkedEntitiesResultArray(input2, response) {
  return combineSuccessfulAndErroneousDocumentsWithStatisticsAndModelVersion(input2, response, makeRecognizeLinkedEntitiesResult, makeRecognizeLinkedEntitiesErrorResult);
}

// node_modules/@azure/ai-text-analytics/node_modules/@azure/core-tracing/dist-esm/src/tracers/noop/noOpSpan.js
var NoOpSpan = class {
  /**
   * Returns the SpanContext associated with this Span.
   */
  spanContext() {
    return {
      spanId: "",
      traceId: "",
      traceFlags: 0
      /* NONE */
    };
  }
  /**
   * Marks the end of Span execution.
   * @param _endTime - The time to use as the Span's end time. Defaults to
   * the current time.
   */
  end(_endTime) {
  }
  /**
   * Sets an attribute on the Span
   * @param _key - The attribute key
   * @param _value - The attribute value
   */
  setAttribute(_key, _value) {
    return this;
  }
  /**
   * Sets attributes on the Span
   * @param _attributes - The attributes to add
   */
  setAttributes(_attributes) {
    return this;
  }
  /**
   * Adds an event to the Span
   * @param _name - The name of the event
   * @param _attributes - The associated attributes to add for this event
   */
  addEvent(_name, _attributes) {
    return this;
  }
  /**
   * Sets a status on the span. Overrides the default of SpanStatusCode.OK.
   * @param _status - The status to set.
   */
  setStatus(_status) {
    return this;
  }
  /**
   * Updates the name of the Span
   * @param _name - the new Span name
   */
  updateName(_name) {
    return this;
  }
  /**
   * Returns whether this span will be recorded
   */
  isRecording() {
    return false;
  }
  /**
   * Sets exception as a span event
   * @param exception - the exception the only accepted values are string or Error
   * @param time - the time to set as Span's event time. If not provided,
   *     use the current time.
   */
  recordException(_exception, _time) {
  }
};

// node_modules/@azure/ai-text-analytics/node_modules/@azure/core-tracing/dist-esm/src/tracers/noop/noOpTracer.js
var NoOpTracer = class {
  /**
   * Starts a new Span.
   * @param _name - The name of the span.
   * @param _options - The SpanOptions used during Span creation.
   */
  startSpan(_name, _options) {
    return new NoOpSpan();
  }
  /**
   * Returns the current Span from the current context, if available.
   */
  getCurrentSpan() {
    return new NoOpSpan();
  }
  /**
   * Executes the given function within the context provided by a Span.
   * @param _span - The span that provides the context.
   * @param fn - The function to be executed.
   */
  withSpan(_span, fn) {
    return fn();
  }
  /**
   * Bind a Span as the target's scope
   * @param target - An object to bind the scope.
   * @param _span - A specific Span to use. Otherwise, use the current one.
   */
  bind(target, _span) {
    return target;
  }
};

// node_modules/@azure/ai-text-analytics/node_modules/@azure/core-tracing/dist-esm/src/utils/global.browser.js
function getGlobalObject() {
  return self;
}

// node_modules/@azure/ai-text-analytics/node_modules/@azure/core-tracing/dist-esm/src/utils/cache.js
var GLOBAL_TRACER_SYMBOL = Symbol.for(`@azure/core-tracing.tracerCache4`);
var cache;
function loadTracerCache() {
  const globalObj = getGlobalObject();
  if (!globalObj[GLOBAL_TRACER_SYMBOL]) {
    globalObj[GLOBAL_TRACER_SYMBOL] = {
      tracer: void 0
    };
  }
  cache = globalObj[GLOBAL_TRACER_SYMBOL];
}
function getCache() {
  if (!cache) {
    loadTracerCache();
  }
  return cache;
}

// node_modules/@azure/ai-text-analytics/node_modules/@azure/core-tracing/dist-esm/src/tracerProxy.js
var defaultTracer;
function getDefaultTracer() {
  if (!defaultTracer) {
    defaultTracer = new NoOpTracer();
  }
  return defaultTracer;
}
function getTracer() {
  const cache2 = getCache();
  if (!cache2.tracer) {
    return getDefaultTracer();
  }
  return cache2.tracer;
}

// node_modules/@opentelemetry/api/build/esm/platform/browser/globalThis.js
var _globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};

// node_modules/@opentelemetry/api/build/esm/version.js
var VERSION = "1.7.0";

// node_modules/@opentelemetry/api/build/esm/internal/semver.js
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible = _makeCompatibilityCheck(VERSION);

// node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
var major = VERSION.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a, _b;
  var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}

// node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger = (
  /** @class */
  function() {
    function DiagComponentLogger2(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("debug", this._namespace, args);
    };
    DiagComponentLogger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("error", this._namespace, args);
    };
    DiagComponentLogger2.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("info", this._namespace, args);
    };
    DiagComponentLogger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("warn", this._namespace, args);
    };
    DiagComponentLogger2.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("verbose", this._namespace, args);
    };
    return DiagComponentLogger2;
  }()
);
function logProxy(funcName, namespace, args) {
  var logger4 = getGlobal("diag");
  if (!logger4) {
    return;
  }
  args.unshift(namespace);
  return logger4[funcName].apply(logger4, __spreadArray([], __read(args), false));
}

// node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
(function(DiagLogLevel2) {
  DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
  DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
  DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
  DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
  DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));

// node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger4) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger4 = logger4 || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger4[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger4);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}

// node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME = "diag";
var DiagAPI = (
  /** @class */
  function() {
    function DiagAPI2() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger4 = getGlobal("diag");
          if (!logger4)
            return;
          return logger4[funcName].apply(logger4, __spreadArray2([], __read2(args), false));
        };
      }
      var self2 = this;
      var setLogger = function(logger4, optionsOrLogLevel) {
        var _a, _b, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
        }
        if (logger4 === self2) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self2.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal("diag");
        var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger4);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal("diag", newLogger, self2, true);
      };
      self2.setLogger = setLogger;
      self2.disable = function() {
        unregisterGlobal(API_NAME, self2);
      };
      self2.createComponentLogger = function(options) {
        return new DiagComponentLogger(options);
      };
      self2.verbose = _logProxy("verbose");
      self2.debug = _logProxy("debug");
      self2.info = _logProxy("info");
      self2.warn = _logProxy("warn");
      self2.error = _logProxy("error");
    }
    DiagAPI2.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI2();
      }
      return this._instance;
    };
    return DiagAPI2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var BaggageImpl = (
  /** @class */
  function() {
    function BaggageImpl2(entries) {
      this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
    }
    BaggageImpl2.prototype.getEntry = function(key) {
      var entry = this._entries.get(key);
      if (!entry) {
        return void 0;
      }
      return Object.assign({}, entry);
    };
    BaggageImpl2.prototype.getAllEntries = function() {
      return Array.from(this._entries.entries()).map(function(_a) {
        var _b = __read3(_a, 2), k = _b[0], v = _b[1];
        return [k, v];
      });
    };
    BaggageImpl2.prototype.setEntry = function(key, entry) {
      var newBaggage = new BaggageImpl2(this._entries);
      newBaggage._entries.set(key, entry);
      return newBaggage;
    };
    BaggageImpl2.prototype.removeEntry = function(key) {
      var newBaggage = new BaggageImpl2(this._entries);
      newBaggage._entries.delete(key);
      return newBaggage;
    };
    BaggageImpl2.prototype.removeEntries = function() {
      var e_1, _a;
      var keys = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        keys[_i] = arguments[_i];
      }
      var newBaggage = new BaggageImpl2(this._entries);
      try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
          var key = keys_1_1.value;
          newBaggage._entries.delete(key);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return))
            _a.call(keys_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return newBaggage;
    };
    BaggageImpl2.prototype.clear = function() {
      return new BaggageImpl2();
    };
    return BaggageImpl2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");

// node_modules/@opentelemetry/api/build/esm/baggage/utils.js
var diag = DiagAPI.instance();
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}

// node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext = (
  /** @class */
  function() {
    function BaseContext2(parentContext) {
      var self2 = this;
      self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self2.getValue = function(key) {
        return self2._currentContext.get(key);
      };
      self2.setValue = function(key, value) {
        var context3 = new BaseContext2(self2._currentContext);
        context3._currentContext.set(key, value);
        return context3;
      };
      self2.deleteValue = function(key) {
        var context3 = new BaseContext2(self2._currentContext);
        context3._currentContext.delete(key);
        return context3;
      };
    }
    return BaseContext2;
  }()
);
var ROOT_CONTEXT = new BaseContext();

// node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
var consoleMap = [
  { n: "error", c: "error" },
  { n: "warn", c: "warn" },
  { n: "info", c: "info" },
  { n: "debug", c: "debug" },
  { n: "verbose", c: "trace" }
];
var DiagConsoleLogger = (
  /** @class */
  function() {
    function DiagConsoleLogger2() {
      function _consoleFunc(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          if (console) {
            var theFunc = console[funcName];
            if (typeof theFunc !== "function") {
              theFunc = console.log;
            }
            if (typeof theFunc === "function") {
              return theFunc.apply(console, args);
            }
          }
        };
      }
      for (var i = 0; i < consoleMap.length; i++) {
        this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
      }
    }
    return DiagConsoleLogger2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var NoopMeter = (
  /** @class */
  function() {
    function NoopMeter2() {
    }
    NoopMeter2.prototype.createHistogram = function(_name, _options) {
      return NOOP_HISTOGRAM_METRIC;
    };
    NoopMeter2.prototype.createCounter = function(_name, _options) {
      return NOOP_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
      return NOOP_UP_DOWN_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
      return NOOP_OBSERVABLE_GAUGE_METRIC;
    };
    NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
      return NOOP_OBSERVABLE_COUNTER_METRIC;
    };
    NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
      return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
    };
    NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
    };
    NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
    };
    return NoopMeter2;
  }()
);
var NoopMetric = (
  /** @class */
  function() {
    function NoopMetric2() {
    }
    return NoopMetric2;
  }()
);
var NoopCounterMetric = (
  /** @class */
  function(_super) {
    __extends(NoopCounterMetric2, _super);
    function NoopCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopCounterMetric2.prototype.add = function(_value, _attributes) {
    };
    return NoopCounterMetric2;
  }(NoopMetric)
);
var NoopUpDownCounterMetric = (
  /** @class */
  function(_super) {
    __extends(NoopUpDownCounterMetric2, _super);
    function NoopUpDownCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
    };
    return NoopUpDownCounterMetric2;
  }(NoopMetric)
);
var NoopHistogramMetric = (
  /** @class */
  function(_super) {
    __extends(NoopHistogramMetric2, _super);
    function NoopHistogramMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
    };
    return NoopHistogramMetric2;
  }(NoopMetric)
);
var NoopObservableMetric = (
  /** @class */
  function() {
    function NoopObservableMetric2() {
    }
    NoopObservableMetric2.prototype.addCallback = function(_callback) {
    };
    NoopObservableMetric2.prototype.removeCallback = function(_callback) {
    };
    return NoopObservableMetric2;
  }()
);
var NoopObservableCounterMetric = (
  /** @class */
  function(_super) {
    __extends(NoopObservableCounterMetric2, _super);
    function NoopObservableCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableCounterMetric2;
  }(NoopObservableMetric)
);
var NoopObservableGaugeMetric = (
  /** @class */
  function(_super) {
    __extends(NoopObservableGaugeMetric2, _super);
    function NoopObservableGaugeMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableGaugeMetric2;
  }(NoopObservableMetric)
);
var NoopObservableUpDownCounterMetric = (
  /** @class */
  function(_super) {
    __extends(NoopObservableUpDownCounterMetric2, _super);
    function NoopObservableUpDownCounterMetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return NoopObservableUpDownCounterMetric2;
  }(NoopObservableMetric)
);
var NOOP_METER = new NoopMeter();
var NOOP_COUNTER_METRIC = new NoopCounterMetric();
var NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
var NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
var NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
var NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
var NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();

// node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType;
(function(ValueType2) {
  ValueType2[ValueType2["INT"] = 0] = "INT";
  ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
})(ValueType || (ValueType = {}));

// node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter = {
  get: function(carrier, key) {
    if (carrier == null) {
      return void 0;
    }
    return carrier[key];
  },
  keys: function(carrier) {
    if (carrier == null) {
      return [];
    }
    return Object.keys(carrier);
  }
};
var defaultTextMapSetter = {
  set: function(carrier, key, value) {
    if (carrier == null) {
      return;
    }
    carrier[key] = value;
  }
};

// node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = (
  /** @class */
  function() {
    function NoopContextManager2() {
    }
    NoopContextManager2.prototype.active = function() {
      return ROOT_CONTEXT;
    };
    NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
    };
    NoopContextManager2.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager2.prototype.enable = function() {
      return this;
    };
    NoopContextManager2.prototype.disable = function() {
      return this;
    };
    return NoopContextManager2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME2 = "context";
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
var ContextAPI = (
  /** @class */
  function() {
    function ContextAPI2() {
    }
    ContextAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI2();
      }
      return this._instance;
    };
    ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
    };
    ContextAPI2.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI2.prototype.with = function(context3, fn, thisArg) {
      var _a;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a = this._getContextManager()).with.apply(_a, __spreadArray4([context3, fn, thisArg], __read5(args), false));
    };
    ContextAPI2.prototype.bind = function(context3, target) {
      return this._getContextManager().bind(context3, target);
    };
    ContextAPI2.prototype._getContextManager = function() {
      return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
    };
    ContextAPI2.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal(API_NAME2, DiagAPI.instance());
    };
    return ContextAPI2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
(function(TraceFlags2) {
  TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
  TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));

// node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID = "0000000000000000";
var INVALID_TRACEID = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT = {
  traceId: INVALID_TRACEID,
  spanId: INVALID_SPANID,
  traceFlags: TraceFlags.NONE
};

// node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan = (
  /** @class */
  function() {
    function NonRecordingSpan2(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan2.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan2.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan2.prototype.end = function(_endTime) {
    };
    NonRecordingSpan2.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context3) {
  return context3.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context3, span) {
  return context3.setValue(SPAN_KEY, span);
}
function deleteSpan(context3) {
  return context3.deleteValue(SPAN_KEY);
}
function setSpanContext(context3, spanContext) {
  return setSpan(context3, new NonRecordingSpan(spanContext));
}
function getSpanContext(context3) {
  var _a;
  return (_a = getSpan(context3)) === null || _a === void 0 ? void 0 : _a.spanContext();
}

// node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
var contextApi = ContextAPI.getInstance();
var NoopTracer = (
  /** @class */
  function() {
    function NoopTracer2() {
    }
    NoopTracer2.prototype.startSpan = function(name, options, context3) {
      if (context3 === void 0) {
        context3 = contextApi.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan();
      }
      var parentFromContext = context3 && getSpanContext(context3);
      if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
        return new NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan();
      }
    };
    NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
      var span = this.startSpan(name, opts, parentContext);
      var contextWithSpanSet = setSpan(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer2;
  }()
);
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER = new NoopTracer();
var ProxyTracer = (
  /** @class */
  function() {
    function ProxyTracer2(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    ProxyTracer2.prototype.startSpan = function(name, options, context3) {
      return this._getTracer().startSpan(name, options, context3);
    };
    ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer2.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider = (
  /** @class */
  function() {
    function NoopTracerProvider2() {
    }
    NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer();
    };
    return NoopTracerProvider2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
var ProxyTracerProvider = (
  /** @class */
  function() {
    function ProxyTracerProvider2() {
    }
    ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
      var _a;
      return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
    };
    ProxyTracerProvider2.prototype.getDelegate = function() {
      var _a;
      return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
    };
    ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
    };
    return ProxyTracerProvider2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
(function(SamplingDecision2) {
  SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
  SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
  SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
})(SamplingDecision || (SamplingDecision = {}));

// node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
(function(SpanKind3) {
  SpanKind3[SpanKind3["INTERNAL"] = 0] = "INTERNAL";
  SpanKind3[SpanKind3["SERVER"] = 1] = "SERVER";
  SpanKind3[SpanKind3["CLIENT"] = 2] = "CLIENT";
  SpanKind3[SpanKind3["PRODUCER"] = 3] = "PRODUCER";
  SpanKind3[SpanKind3["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind || (SpanKind = {}));

// node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
(function(SpanStatusCode3) {
  SpanStatusCode3[SpanStatusCode3["UNSET"] = 0] = "UNSET";
  SpanStatusCode3[SpanStatusCode3["OK"] = 1] = "OK";
  SpanStatusCode3[SpanStatusCode3["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
var VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
var VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
var VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
var VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
var VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
var INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}

// node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS = 32;
var MAX_TRACE_STATE_LEN = 512;
var LIST_MEMBERS_SEPARATOR = ",";
var LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
var TraceStateImpl = (
  /** @class */
  function() {
    function TraceStateImpl2(rawTraceState) {
      this._internalState = /* @__PURE__ */ new Map();
      if (rawTraceState)
        this._parse(rawTraceState);
    }
    TraceStateImpl2.prototype.set = function(key, value) {
      var traceState = this._clone();
      if (traceState._internalState.has(key)) {
        traceState._internalState.delete(key);
      }
      traceState._internalState.set(key, value);
      return traceState;
    };
    TraceStateImpl2.prototype.unset = function(key) {
      var traceState = this._clone();
      traceState._internalState.delete(key);
      return traceState;
    };
    TraceStateImpl2.prototype.get = function(key) {
      return this._internalState.get(key);
    };
    TraceStateImpl2.prototype.serialize = function() {
      var _this = this;
      return this._keys().reduce(function(agg, key) {
        agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
        return agg;
      }, []).join(LIST_MEMBERS_SEPARATOR);
    };
    TraceStateImpl2.prototype._parse = function(rawTraceState) {
      if (rawTraceState.length > MAX_TRACE_STATE_LEN)
        return;
      this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
        var listMember = part.trim();
        var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
        if (i !== -1) {
          var key = listMember.slice(0, i);
          var value = listMember.slice(i + 1, part.length);
          if (validateKey(key) && validateValue(value)) {
            agg.set(key, value);
          } else {
          }
        }
        return agg;
      }, /* @__PURE__ */ new Map());
      if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
        this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
      }
    };
    TraceStateImpl2.prototype._keys = function() {
      return Array.from(this._internalState.keys()).reverse();
    };
    TraceStateImpl2.prototype._clone = function() {
      var traceState = new TraceStateImpl2();
      traceState._internalState = new Map(this._internalState);
      return traceState;
    };
    return TraceStateImpl2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/context-api.js
var context = ContextAPI.getInstance();

// node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2 = DiagAPI.instance();

// node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider = (
  /** @class */
  function() {
    function NoopMeterProvider2() {
    }
    NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
      return NOOP_METER;
    };
    return NoopMeterProvider2;
  }()
);
var NOOP_METER_PROVIDER = new NoopMeterProvider();

// node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3 = "metrics";
var MetricsAPI = (
  /** @class */
  function() {
    function MetricsAPI2() {
    }
    MetricsAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new MetricsAPI2();
      }
      return this._instance;
    };
    MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
      return registerGlobal(API_NAME3, provider, DiagAPI.instance());
    };
    MetricsAPI2.prototype.getMeterProvider = function() {
      return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
    };
    MetricsAPI2.prototype.getMeter = function(name, version, options) {
      return this.getMeterProvider().getMeter(name, version, options);
    };
    MetricsAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME3, DiagAPI.instance());
    };
    return MetricsAPI2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics = MetricsAPI.getInstance();

// node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator = (
  /** @class */
  function() {
    function NoopTextMapPropagator2() {
    }
    NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
    };
    NoopTextMapPropagator2.prototype.extract = function(context3, _carrier) {
      return context3;
    };
    NoopTextMapPropagator2.prototype.fields = function() {
      return [];
    };
    return NoopTextMapPropagator2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
var BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
function getBaggage(context3) {
  return context3.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context3, baggage) {
  return context3.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context3) {
  return context3.deleteValue(BAGGAGE_KEY);
}

// node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4 = "propagation";
var NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
var PropagationAPI = (
  /** @class */
  function() {
    function PropagationAPI2() {
      this.createBaggage = createBaggage;
      this.getBaggage = getBaggage;
      this.getActiveBaggage = getActiveBaggage;
      this.setBaggage = setBaggage;
      this.deleteBaggage = deleteBaggage;
    }
    PropagationAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new PropagationAPI2();
      }
      return this._instance;
    };
    PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
      return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
    };
    PropagationAPI2.prototype.inject = function(context3, carrier, setter) {
      if (setter === void 0) {
        setter = defaultTextMapSetter;
      }
      return this._getGlobalPropagator().inject(context3, carrier, setter);
    };
    PropagationAPI2.prototype.extract = function(context3, carrier, getter) {
      if (getter === void 0) {
        getter = defaultTextMapGetter;
      }
      return this._getGlobalPropagator().extract(context3, carrier, getter);
    };
    PropagationAPI2.prototype.fields = function() {
      return this._getGlobalPropagator().fields();
    };
    PropagationAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME4, DiagAPI.instance());
    };
    PropagationAPI2.prototype._getGlobalPropagator = function() {
      return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
    };
    return PropagationAPI2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation = PropagationAPI.getInstance();

// node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5 = "trace";
var TraceAPI = (
  /** @class */
  function() {
    function TraceAPI2() {
      this._proxyTracerProvider = new ProxyTracerProvider();
      this.wrapSpanContext = wrapSpanContext;
      this.isSpanContextValid = isSpanContextValid;
      this.deleteSpan = deleteSpan;
      this.getSpan = getSpan;
      this.getActiveSpan = getActiveSpan;
      this.getSpanContext = getSpanContext;
      this.setSpan = setSpan;
      this.setSpanContext = setSpanContext;
    }
    TraceAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI2();
      }
      return this._instance;
    };
    TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI2.prototype.getTracerProvider = function() {
      return getGlobal(API_NAME5) || this._proxyTracerProvider;
    };
    TraceAPI2.prototype.getTracer = function(name, version) {
      return this.getTracerProvider().getTracer(name, version);
    };
    TraceAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME5, DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI2;
  }()
);

// node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace = TraceAPI.getInstance();

// node_modules/@azure/ai-text-analytics/node_modules/@azure/core-tracing/dist-esm/src/interfaces.js
var SpanKind2;
(function(SpanKind3) {
  SpanKind3[SpanKind3["INTERNAL"] = 0] = "INTERNAL";
  SpanKind3[SpanKind3["SERVER"] = 1] = "SERVER";
  SpanKind3[SpanKind3["CLIENT"] = 2] = "CLIENT";
  SpanKind3[SpanKind3["PRODUCER"] = 3] = "PRODUCER";
  SpanKind3[SpanKind3["CONSUMER"] = 4] = "CONSUMER";
})(SpanKind2 || (SpanKind2 = {}));
function setSpan2(context3, span) {
  return trace.setSpan(context3, span);
}
var context2 = context;
var SpanStatusCode2;
(function(SpanStatusCode3) {
  SpanStatusCode3[SpanStatusCode3["UNSET"] = 0] = "UNSET";
  SpanStatusCode3[SpanStatusCode3["OK"] = 1] = "OK";
  SpanStatusCode3[SpanStatusCode3["ERROR"] = 2] = "ERROR";
})(SpanStatusCode2 || (SpanStatusCode2 = {}));

// node_modules/@azure/ai-text-analytics/node_modules/@azure/core-tracing/dist-esm/src/createSpan.js
function createSpanFunction(args) {
  return function(operationName, operationOptions) {
    const tracer = getTracer();
    const tracingOptions = (operationOptions === null || operationOptions === void 0 ? void 0 : operationOptions.tracingOptions) || {};
    const spanOptions = Object.assign({ kind: SpanKind2.INTERNAL }, tracingOptions.spanOptions);
    const spanName = args.packagePrefix ? `${args.packagePrefix}.${operationName}` : operationName;
    const span = tracer.startSpan(spanName, spanOptions, tracingOptions.tracingContext);
    if (args.namespace) {
      span.setAttribute("az.namespace", args.namespace);
    }
    let newSpanOptions = tracingOptions.spanOptions || {};
    if (span.isRecording() && args.namespace) {
      newSpanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": args.namespace }) });
    }
    const newTracingOptions = Object.assign(Object.assign({}, tracingOptions), { spanOptions: newSpanOptions, tracingContext: setSpan2(tracingOptions.tracingContext || context2.active(), span) });
    const newOperationOptions = Object.assign(Object.assign({}, operationOptions), { tracingOptions: newTracingOptions });
    return {
      span,
      updatedOptions: newOperationOptions
    };
  };
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/tracing.js
var createSpan = createSpanFunction({
  packagePrefix: "Azure.CognitiveServices.TextAnalytics",
  namespace: "Microsoft.CognitiveServices"
});

// node_modules/@azure/ai-text-analytics/dist-esm/src/azureKeyCredentialPolicy.js
var API_KEY_HEADER_NAME = "Ocp-Apim-Subscription-Key";
var textAnalyticsAzureKeyCredentialPolicyName = "textAnalyticsAzureKeyCredentialPolicy";
function textAnalyticsAzureKeyCredentialPolicy(credential) {
  return {
    name: textAnalyticsAzureKeyCredentialPolicyName,
    sendRequest(request, next) {
      request.headers.set(API_KEY_HEADER_NAME, credential.key);
      return next(request);
    }
  };
}

// node_modules/@azure/core-lro/dist-esm/src/logger.js
var logger3 = createClientLogger("core-lro");

// node_modules/@azure/core-lro/dist-esm/src/legacy/poller.js
var PollerStoppedError = class _PollerStoppedError extends Error {
  constructor(message) {
    super(message);
    this.name = "PollerStoppedError";
    Object.setPrototypeOf(this, _PollerStoppedError.prototype);
  }
};
var PollerCancelledError = class _PollerCancelledError extends Error {
  constructor(message) {
    super(message);
    this.name = "PollerCancelledError";
    Object.setPrototypeOf(this, _PollerCancelledError.prototype);
  }
};
var Poller = class {
  /**
   * A poller needs to be initialized by passing in at least the basic properties of the `PollOperation<TState, TResult>`.
   *
   * When writing an implementation of a Poller, this implementation needs to deal with the initialization
   * of any custom state beyond the basic definition of the poller. The basic poller assumes that the poller's
   * operation has already been defined, at least its basic properties. The code below shows how to approach
   * the definition of the constructor of a new custom poller.
   *
   * ```ts
   * export class MyPoller extends Poller<MyOperationState, string> {
   *   constructor({
   *     // Anything you might need outside of the basics
   *   }) {
   *     let state: MyOperationState = {
   *       privateProperty: private,
   *       publicProperty: public,
   *     };
   *
   *     const operation = {
   *       state,
   *       update,
   *       cancel,
   *       toString
   *     }
   *
   *     // Sending the operation to the parent's constructor.
   *     super(operation);
   *
   *     // You can assign more local properties here.
   *   }
   * }
   * ```
   *
   * Inside of this constructor, a new promise is created. This will be used to
   * tell the user when the poller finishes (see `pollUntilDone()`). The promise's
   * resolve and reject methods are also used internally to control when to resolve
   * or reject anyone waiting for the poller to finish.
   *
   * The constructor of a custom implementation of a poller is where any serialized version of
   * a previous poller's operation should be deserialized into the operation sent to the
   * base constructor. For example:
   *
   * ```ts
   * export class MyPoller extends Poller<MyOperationState, string> {
   *   constructor(
   *     baseOperation: string | undefined
   *   ) {
   *     let state: MyOperationState = {};
   *     if (baseOperation) {
   *       state = {
   *         ...JSON.parse(baseOperation).state,
   *         ...state
   *       };
   *     }
   *     const operation = {
   *       state,
   *       // ...
   *     }
   *     super(operation);
   *   }
   * }
   * ```
   *
   * @param operation - Must contain the basic properties of `PollOperation<State, TResult>`.
   */
  constructor(operation) {
    this.resolveOnUnsuccessful = false;
    this.stopped = true;
    this.pollProgressCallbacks = [];
    this.operation = operation;
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
    this.promise.catch(() => {
    });
  }
  /**
   * Starts a loop that will break only if the poller is done
   * or if the poller is stopped.
   */
  async startPolling(pollOptions = {}) {
    if (this.stopped) {
      this.stopped = false;
    }
    while (!this.isStopped() && !this.isDone()) {
      await this.poll(pollOptions);
      await this.delay();
    }
  }
  /**
   * pollOnce does one polling, by calling to the update method of the underlying
   * poll operation to make any relevant change effective.
   *
   * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
   *
   * @param options - Optional properties passed to the operation's update method.
   */
  async pollOnce(options = {}) {
    if (!this.isDone()) {
      this.operation = await this.operation.update({
        abortSignal: options.abortSignal,
        fireProgress: this.fireProgress.bind(this)
      });
    }
    this.processUpdatedState();
  }
  /**
   * fireProgress calls the functions passed in via onProgress the method of the poller.
   *
   * It loops over all of the callbacks received from onProgress, and executes them, sending them
   * the current operation state.
   *
   * @param state - The current operation state.
   */
  fireProgress(state) {
    for (const callback of this.pollProgressCallbacks) {
      callback(state);
    }
  }
  /**
   * Invokes the underlying operation's cancel method.
   */
  async cancelOnce(options = {}) {
    this.operation = await this.operation.cancel(options);
  }
  /**
   * Returns a promise that will resolve once a single polling request finishes.
   * It does this by calling the update method of the Poller's operation.
   *
   * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
   *
   * @param options - Optional properties passed to the operation's update method.
   */
  poll(options = {}) {
    if (!this.pollOncePromise) {
      this.pollOncePromise = this.pollOnce(options);
      const clearPollOncePromise = () => {
        this.pollOncePromise = void 0;
      };
      this.pollOncePromise.then(clearPollOncePromise, clearPollOncePromise).catch(this.reject);
    }
    return this.pollOncePromise;
  }
  processUpdatedState() {
    if (this.operation.state.error) {
      this.stopped = true;
      if (!this.resolveOnUnsuccessful) {
        this.reject(this.operation.state.error);
        throw this.operation.state.error;
      }
    }
    if (this.operation.state.isCancelled) {
      this.stopped = true;
      if (!this.resolveOnUnsuccessful) {
        const error = new PollerCancelledError("Operation was canceled");
        this.reject(error);
        throw error;
      }
    }
    if (this.isDone() && this.resolve) {
      this.resolve(this.getResult());
    }
  }
  /**
   * Returns a promise that will resolve once the underlying operation is completed.
   */
  async pollUntilDone(pollOptions = {}) {
    if (this.stopped) {
      this.startPolling(pollOptions).catch(this.reject);
    }
    this.processUpdatedState();
    return this.promise;
  }
  /**
   * Invokes the provided callback after each polling is completed,
   * sending the current state of the poller's operation.
   *
   * It returns a method that can be used to stop receiving updates on the given callback function.
   */
  onProgress(callback) {
    this.pollProgressCallbacks.push(callback);
    return () => {
      this.pollProgressCallbacks = this.pollProgressCallbacks.filter((c) => c !== callback);
    };
  }
  /**
   * Returns true if the poller has finished polling.
   */
  isDone() {
    const state = this.operation.state;
    return Boolean(state.isCompleted || state.isCancelled || state.error);
  }
  /**
   * Stops the poller from continuing to poll.
   */
  stopPolling() {
    if (!this.stopped) {
      this.stopped = true;
      if (this.reject) {
        this.reject(new PollerStoppedError("This poller is already stopped"));
      }
    }
  }
  /**
   * Returns true if the poller is stopped.
   */
  isStopped() {
    return this.stopped;
  }
  /**
   * Attempts to cancel the underlying operation.
   *
   * It only optionally receives an object with an abortSignal property, from \@azure/abort-controller's AbortSignalLike.
   *
   * If it's called again before it finishes, it will throw an error.
   *
   * @param options - Optional properties passed to the operation's update method.
   */
  cancelOperation(options = {}) {
    if (!this.cancelPromise) {
      this.cancelPromise = this.cancelOnce(options);
    } else if (options.abortSignal) {
      throw new Error("A cancel request is currently pending");
    }
    return this.cancelPromise;
  }
  /**
   * Returns the state of the operation.
   *
   * Even though TState will be the same type inside any of the methods of any extension of the Poller class,
   * implementations of the pollers can customize what's shared with the public by writing their own
   * version of the `getOperationState` method, and by defining two types, one representing the internal state of the poller
   * and a public type representing a safe to share subset of the properties of the internal state.
   * Their definition of getOperationState can then return their public type.
   *
   * Example:
   *
   * ```ts
   * // Let's say we have our poller's operation state defined as:
   * interface MyOperationState extends PollOperationState<ResultType> {
   *   privateProperty?: string;
   *   publicProperty?: string;
   * }
   *
   * // To allow us to have a true separation of public and private state, we have to define another interface:
   * interface PublicState extends PollOperationState<ResultType> {
   *   publicProperty?: string;
   * }
   *
   * // Then, we define our Poller as follows:
   * export class MyPoller extends Poller<MyOperationState, ResultType> {
   *   // ... More content is needed here ...
   *
   *   public getOperationState(): PublicState {
   *     const state: PublicState = this.operation.state;
   *     return {
   *       // Properties from PollOperationState<TResult>
   *       isStarted: state.isStarted,
   *       isCompleted: state.isCompleted,
   *       isCancelled: state.isCancelled,
   *       error: state.error,
   *       result: state.result,
   *
   *       // The only other property needed by PublicState.
   *       publicProperty: state.publicProperty
   *     }
   *   }
   * }
   * ```
   *
   * You can see this in the tests of this repository, go to the file:
   * `../test/utils/testPoller.ts`
   * and look for the getOperationState implementation.
   */
  getOperationState() {
    return this.operation.state;
  }
  /**
   * Returns the result value of the operation,
   * regardless of the state of the poller.
   * It can return undefined or an incomplete form of the final TResult value
   * depending on the implementation.
   */
  getResult() {
    const state = this.operation.state;
    return state.result;
  }
  /**
   * Returns a serialized version of the poller's operation
   * by invoking the operation's toString method.
   */
  toString() {
    return this.operation.toString();
  }
};

// node_modules/@azure/ai-text-analytics/dist-esm/src/lro/poller.js
var AnalysisPoller = class extends Poller {
  constructor() {
    super(...arguments);
    this.updateIntervalInMs = 2e3;
  }
  /**
   * The method used by the poller to wait before attempting to update its operation.
   */
  async delay() {
    return delay(this.updateIntervalInMs);
  }
};
var AnalysisPollOperation = class {
  constructor(state) {
    this.state = state;
  }
  /**
   * Serializes the Poller operation.
   */
  toString() {
    return JSON.stringify({
      state: this.state
    });
  }
};

// node_modules/@azure/ai-text-analytics/dist-esm/src/analyzeHealthcareEntitiesResult.js
function makeHealthcareEntitiesWithoutNeighbors(entity) {
  var _a;
  const { category, confidenceScore, assertion, offset, text, links, subcategory, length, name } = entity;
  return {
    category,
    confidenceScore,
    assertion,
    offset,
    length,
    text,
    normalizedText: name,
    subCategory: subcategory,
    dataSources: (_a = links === null || links === void 0 ? void 0 : links.map(({ dataSource, id }) => ({ name: dataSource, entityId: id }))) !== null && _a !== void 0 ? _a : []
  };
}
function makeHealthcareRelations(entities, relations) {
  return relations.map((relation) => ({
    relationType: relation.relationType,
    roles: relation.entities.map((role) => ({
      entity: entities[parseHealthcareEntityIndex(role.ref)],
      name: role.role
    }))
  }));
}
function makeHealthcareEntitiesResult(document) {
  const { id, entities, relations, warnings, statistics } = document;
  const newEntities = entities.map(makeHealthcareEntitiesWithoutNeighbors);
  return Object.assign(Object.assign({}, makeTextAnalyticsSuccessResult(id, warnings, statistics)), { entities: newEntities, entityRelations: makeHealthcareRelations(newEntities, relations) });
}
function makeHealthcareEntitiesErrorResult(id, error) {
  return makeTextAnalyticsErrorResult(id, error);
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/lro/health/operation.js
function getMetaInfoFromResponse(response) {
  return {
    createdOn: response.createdDateTime,
    lastModifiedOn: response.lastUpdateDateTime,
    expiresOn: response.expirationDateTime,
    status: response.status
  };
}
var BeginAnalyzeHealthcarePollerOperation = class extends AnalysisPollOperation {
  constructor(state, client, documents, options = {}) {
    super(state);
    this.state = state;
    this.client = client;
    this.documents = documents;
    this.options = options;
  }
  /**
   * should be called only after all the status of the healthcare operations became
   * "succeeded" and it returns an iterator for the results and provides a
   * byPage method to return the results paged.
   */
  listHealthcareEntitiesByPage(operationId, options = {}) {
    const iter = this._listHealthcareEntities(operationId, options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings) => {
        const pageOptions = Object.assign(Object.assign({}, options), { top: settings === null || settings === void 0 ? void 0 : settings.maxPageSize });
        return this._listHealthcareEntitiesPaged(operationId, pageOptions);
      }
    };
  }
  /**
   * returns an iterator to the results of a healthcare operation.
   */
  _listHealthcareEntities(operationId, options) {
    return __asyncGenerator(this, arguments, function* _listHealthcareEntities_1() {
      var e_1, _a;
      try {
        for (var _b = __asyncValues(this._listHealthcareEntitiesPaged(operationId, options)), _c; _c = yield __await(_b.next()), !_c.done; ) {
          const page = _c.value;
          yield __await(yield* __asyncDelegator(__asyncValues(page)));
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            yield __await(_a.call(_b));
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    });
  }
  /**
   * returns an iterator to arrays of the results of a healthcare operation.
   */
  _listHealthcareEntitiesPaged(operationId, options) {
    return __asyncGenerator(this, arguments, function* _listHealthcareEntitiesPaged_1() {
      let response = yield __await(this._listHealthcareEntitiesSinglePage(operationId, options));
      yield yield __await(response.result);
      while (response.skip) {
        const optionsWithContinuation = Object.assign(Object.assign({}, options), { top: response.top, skip: response.skip });
        response = yield __await(this._listHealthcareEntitiesSinglePage(operationId, optionsWithContinuation));
        yield yield __await(response.result);
      }
    });
  }
  /**
   * returns an iterator to arrays of the sorted results of a healthcare operation.
   */
  async _listHealthcareEntitiesSinglePage(operationId, options) {
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-_listHealthcareEntitiesSinglePage", options || {});
    try {
      const response = await this.client.healthStatus(operationId, finalOptions);
      if (response.results) {
        const result = processAndCombineSuccessfulAndErroneousDocuments(this.documents, response.results, makeHealthcareEntitiesResult, makeHealthcareEntitiesErrorResult);
        return response.nextLink ? Object.assign({ result }, nextLinkToTopAndSkip(response.nextLink)) : { result };
      } else {
        throw new Error("Healthcare action has succeeded but the there are no results!");
      }
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * returns whether the healthcare operation is done and if so returns also
   * statistics and the model version used.
   */
  async getHealthStatus(operationId, options) {
    var _a;
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-getHealthStatus", options || {});
    try {
      const response = await this.client.healthStatus(operationId, finalOptions);
      switch (response.status) {
        case "notStarted":
        case "running":
          break;
        case "failed": {
          const errors = (_a = response.errors) === null || _a === void 0 ? void 0 : _a.map((e) => `  code ${e.code}, message: '${e.message}'`).join("\n");
          const message = `Healthcare analysis failed. Error(s): ${errors || ""}`;
          throw new Error(message);
        }
        default: {
          if (response.results) {
            return {
              done: true,
              statistics: response.results.statistics,
              modelVersion: response.results.modelVersion,
              operationMetdata: getMetaInfoFromResponse(response)
            };
          } else {
            throw new Error("Healthcare action has finished but the there are no results!");
          }
        }
      }
      return { done: false, operationMetdata: getMetaInfoFromResponse(response) };
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  async beginAnalyzeHealthcare(documents, options) {
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-beginAnalyzeHealthcare", addStrEncodingParam(options || {}));
    try {
      return await this.client.health({ documents }, finalOptions);
    } catch (e) {
      const exception = handleInvalidDocumentBatch(e);
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: exception.message
      });
      throw exception;
    } finally {
      span.end();
    }
  }
  async update(options = {}) {
    const state = this.state;
    const updatedAbortSignal = options.abortSignal;
    if (!state.isStarted) {
      state.isStarted = true;
      const response = await this.beginAnalyzeHealthcare(this.documents, {
        requestOptions: this.options.requestOptions,
        tracingOptions: this.options.tracingOptions,
        abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal,
        modelVersion: this.options.modelVersion,
        stringIndexType: this.options.stringIndexType,
        loggingOptOut: this.options.disableServiceLogs
      });
      if (!response.operationLocation) {
        throw new Error("Expects a valid 'operationLocation' to retrieve health results but did not find any");
      }
      state.operationId = getOperationId(response.operationLocation);
    }
    const operationStatus = await this.getHealthStatus(state.operationId, {
      abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal,
      includeStatistics: this.options.includeStatistics,
      tracingOptions: this.options.tracingOptions,
      onResponse: this.options.onResponse,
      serializerOptions: this.options.serializerOptions
    });
    state.createdOn = operationStatus.operationMetdata.createdOn;
    state.expiresOn = operationStatus.operationMetdata.expiresOn;
    state.lastModifiedOn = operationStatus.operationMetdata.lastModifiedOn;
    state.status = operationStatus.operationMetdata.status;
    if (!state.isCompleted && operationStatus.done) {
      const pagedIterator = this.listHealthcareEntitiesByPage(state.operationId, {
        abortSignal: this.options.abortSignal,
        tracingOptions: this.options.tracingOptions
      });
      state.result = Object.assign(pagedIterator, {
        statistics: operationStatus.statistics,
        modelVersion: operationStatus.modelVersion
      });
      state.isCompleted = true;
    }
    if (typeof options.fireProgress === "function") {
      options.fireProgress(state);
    }
    return this;
  }
  async cancel() {
    const state = this.state;
    if (state.operationId) {
      await this.client.cancelHealthJob(state.operationId, {
        abortSignal: this.options.abortSignal,
        tracingOptions: this.options.tracingOptions
      });
    }
    state.isCancelled = true;
    return this;
  }
};

// node_modules/@azure/ai-text-analytics/dist-esm/src/lro/health/poller.js
var BeginAnalyzeHealthcarePoller = class extends AnalysisPoller {
  // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
  constructor(inputs) {
    const { client, documents, options, updateIntervalInMs = 5e3, resumeFrom } = inputs;
    let state;
    if (resumeFrom) {
      state = JSON.parse(resumeFrom).state;
    }
    const operation = new BeginAnalyzeHealthcarePollerOperation(state || {}, client, documents, options);
    super(operation);
    this.updateIntervalInMs = updateIntervalInMs;
  }
  delay() {
    return delay(this.updateIntervalInMs);
  }
};

// node_modules/@azure/ai-text-analytics/dist-esm/src/analyzeActionsResult.js
function convertTaskTypeToActionType(taskType) {
  switch (taskType) {
    case "entityRecognitionTasks": {
      return "RecognizeCategorizedEntities";
    }
    case "entityRecognitionPiiTasks": {
      return "RecognizePiiEntities";
    }
    case "keyPhraseExtractionTasks": {
      return "ExtractKeyPhrases";
    }
    case "entityLinkingTasks": {
      return "RecognizeLinkedEntities";
    }
    case "sentimentAnalysisTasks": {
      return "AnalyzeSentiment";
    }
    default: {
      throw new Error(`unexpected action type from the service: ${taskType}`);
    }
  }
}
function parseActionError(erredActions) {
  if (erredActions.target) {
    const regex = new RegExp(/#\/tasks\/(entityRecognitionTasks|entityRecognitionPiiTasks|keyPhraseExtractionTasks|entityLinkingTasks|sentimentAnalysisTasks)\/(\d+)/);
    const result = regex.exec(erredActions.target);
    if (result !== null) {
      return {
        code: erredActions.code,
        message: erredActions.message,
        index: parseInt(result[2]),
        type: convertTaskTypeToActionType(result[1])
      };
    } else {
      throw new Error(`Pointer "${erredActions.target}" is not a valid action pointer`);
    }
  } else {
    throw new Error("expected an error with a target field referencing an action but did not get one");
  }
}
function categorizeActionErrors(erredActions, recognizeEntitiesActionErrors, recognizePiiEntitiesActionErrors, extractKeyPhrasesActionErrors, recognizeLinkedEntitiesActionErrors, analyzeSentimentActionErrors) {
  for (const error of erredActions) {
    const actionError = parseActionError(error);
    switch (actionError.type) {
      case "RecognizeCategorizedEntities": {
        recognizeEntitiesActionErrors.push(actionError);
        break;
      }
      case "RecognizePiiEntities": {
        recognizePiiEntitiesActionErrors.push(actionError);
        break;
      }
      case "ExtractKeyPhrases": {
        extractKeyPhrasesActionErrors.push(actionError);
        break;
      }
      case "RecognizeLinkedEntities": {
        recognizeLinkedEntitiesActionErrors.push(actionError);
        break;
      }
      case "AnalyzeSentiment": {
        analyzeSentimentActionErrors.push(actionError);
        break;
      }
    }
  }
}
function createErredAction(error, lastUpdateDateTime) {
  return { error: intoTextAnalyticsError(error), failedOn: lastUpdateDateTime };
}
function makeActionResult(documents, makeResultsArray, succeededTasks, erredActions) {
  let errorIndex = 0;
  function convertTasksToActions(actions, task) {
    const { results: actionResults, lastUpdateDateTime } = task;
    if (actionResults !== void 0) {
      const recognizeEntitiesResults = makeResultsArray(documents, actionResults);
      return [
        ...actions,
        {
          results: recognizeEntitiesResults,
          completedOn: lastUpdateDateTime
        }
      ];
    } else {
      return [...actions, createErredAction(erredActions[errorIndex++], lastUpdateDateTime)];
    }
  }
  return succeededTasks.reduce(convertTasksToActions, []);
}
function createAnalyzeActionsResult(response, documents) {
  var _a, _b, _c, _d, _e, _f;
  const recognizeEntitiesActionErrors = [];
  const recognizePiiEntitiesActionErrors = [];
  const extractKeyPhrasesActionErrors = [];
  const recognizeLinkedEntitiesActionErrors = [];
  const analyzeSentimentActionErrors = [];
  categorizeActionErrors((_a = response === null || response === void 0 ? void 0 : response.errors) !== null && _a !== void 0 ? _a : [], recognizeEntitiesActionErrors, recognizePiiEntitiesActionErrors, extractKeyPhrasesActionErrors, recognizeLinkedEntitiesActionErrors, analyzeSentimentActionErrors);
  return {
    recognizeEntitiesResults: makeActionResult(documents, makeRecognizeCategorizedEntitiesResultArray, (_b = response.tasks.entityRecognitionTasks) !== null && _b !== void 0 ? _b : [], recognizeEntitiesActionErrors),
    recognizePiiEntitiesResults: makeActionResult(documents, makeRecognizePiiEntitiesResultArray, (_c = response.tasks.entityRecognitionPiiTasks) !== null && _c !== void 0 ? _c : [], recognizePiiEntitiesActionErrors),
    extractKeyPhrasesResults: makeActionResult(documents, makeExtractKeyPhrasesResultArray, (_d = response.tasks.keyPhraseExtractionTasks) !== null && _d !== void 0 ? _d : [], extractKeyPhrasesActionErrors),
    recognizeLinkedEntitiesResults: makeActionResult(documents, makeRecognizeLinkedEntitiesResultArray, (_e = response.tasks.entityLinkingTasks) !== null && _e !== void 0 ? _e : [], recognizeLinkedEntitiesActionErrors),
    analyzeSentimentResults: makeActionResult(documents, makeAnalyzeSentimentResultArray, (_f = response.tasks.sentimentAnalysisTasks) !== null && _f !== void 0 ? _f : [], analyzeSentimentActionErrors)
  };
}

// node_modules/@azure/ai-text-analytics/dist-esm/src/lro/analyze/operation.js
function getMetaInfoFromResponse2(response) {
  return {
    createdOn: response.createdDateTime,
    lastModifiedOn: response.lastUpdateDateTime,
    expiresOn: response.expirationDateTime,
    status: response.status,
    actionsSucceededCount: response.tasks.completed,
    actionsFailedCount: response.tasks.failed,
    actionsInProgressCount: response.tasks.inProgress,
    displayName: response.displayName
  };
}
var BeginAnalyzeActionsPollerOperation = class extends AnalysisPollOperation {
  constructor(state, client, documents, actions, options = {}) {
    super(state);
    this.state = state;
    this.client = client;
    this.documents = documents;
    this.actions = actions;
    this.options = options;
  }
  /**
   * should be called only after all the status of the analyze actions operations became
   * "succeeded" and it returns an iterator for the results and provides a
   * byPage method to return the results paged.
   */
  listAnalyzeActionsResults(operationId, options = {}) {
    const iter = this._listAnalyzeActionsResultsPaged(operationId, options);
    return {
      next() {
        return iter.next();
      },
      [Symbol.asyncIterator]() {
        return this;
      },
      byPage: (settings) => {
        const pageOptions = Object.assign(Object.assign({}, options), { top: settings === null || settings === void 0 ? void 0 : settings.maxPageSize });
        return this._listAnalyzeActionsResultsPaged(operationId, pageOptions);
      }
    };
  }
  /**
   * returns an iterator to arrays of the results of an analyze actions operation.
   */
  _listAnalyzeActionsResultsPaged(operationId, options) {
    return __asyncGenerator(this, arguments, function* _listAnalyzeActionsResultsPaged_1() {
      let response = yield __await(this._listAnalyzeActionsResultsSinglePage(operationId, options));
      yield yield __await(response.result);
      while (response.skip) {
        const optionsWithContinuation = Object.assign(Object.assign({}, options), { top: response.top, skip: response.skip });
        response = yield __await(this._listAnalyzeActionsResultsSinglePage(operationId, optionsWithContinuation));
        yield yield __await(response.result);
      }
    });
  }
  /**
   * returns an iterator to arrays of the sorted results of an analyze actions operation.
   */
  async _listAnalyzeActionsResultsSinglePage(operationId, options) {
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-_listAnalyzeActionsResultsSinglePage", options || {});
    try {
      const response = await this.client.analyzeStatus(operationId, finalOptions);
      const result = createAnalyzeActionsResult(response, this.documents);
      return response.nextLink ? Object.assign({ result }, nextLinkToTopAndSkip(response.nextLink)) : { result };
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  /**
   * returns whether the analyze actions operation is done and if so returns also
   * statistics.
   */
  async getAnalyzeActionsOperationStatus(operationId, options) {
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-getAnalyzeActionsOperationStatus", options || {});
    try {
      const response = await this.client.analyzeStatus(operationId, finalOptions);
      switch (response.status) {
        case "notStarted":
        case "running":
          break;
        default: {
          return {
            done: true,
            statistics: response.statistics,
            operationMetdata: getMetaInfoFromResponse2(response)
          };
        }
      }
      return { done: false, operationMetdata: getMetaInfoFromResponse2(response) };
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  async beginAnalyzeActions(documents, actions, options) {
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-beginAnalyze", options || {});
    try {
      return await this.client.analyze(Object.assign({ body: {
        analysisInput: { documents },
        tasks: actions,
        displayName: options === null || options === void 0 ? void 0 : options.displayName
      } }, finalOptions));
    } catch (e) {
      const exception = handleInvalidDocumentBatch(e);
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: exception.message
      });
      throw exception;
    } finally {
      span.end();
    }
  }
  async update(options = {}) {
    var _a;
    const state = this.state;
    const updatedAbortSignal = options.abortSignal;
    if (!state.isStarted) {
      state.isStarted = true;
      const response = await this.beginAnalyzeActions(this.documents, this.actions, {
        displayName: this.options.displayName,
        tracingOptions: this.options.tracingOptions,
        requestOptions: this.options.requestOptions,
        abortSignal: updatedAbortSignal ? updatedAbortSignal : this.options.abortSignal
      });
      if (!response.operationLocation) {
        throw new Error("Expects a valid 'operationLocation' to retrieve analyze results but did not find any");
      }
      state.operationId = getOperationId(response.operationLocation);
    }
    const operationStatus = await this.getAnalyzeActionsOperationStatus(state.operationId, {
      abortSignal: updatedAbortSignal ? updatedAbortSignal : options.abortSignal,
      includeStatistics: this.options.includeStatistics,
      tracingOptions: this.options.tracingOptions
    });
    state.createdOn = operationStatus.operationMetdata.createdOn;
    state.expiresOn = operationStatus.operationMetdata.expiresOn;
    state.lastModifiedOn = operationStatus.operationMetdata.lastModifiedOn;
    state.status = operationStatus.operationMetdata.status;
    state.actionsSucceededCount = operationStatus.operationMetdata.actionsSucceededCount;
    state.actionsFailedCount = operationStatus.operationMetdata.actionsFailedCount;
    state.actionsInProgressCount = operationStatus.operationMetdata.actionsInProgressCount;
    state.displayName = (_a = operationStatus.operationMetdata) === null || _a === void 0 ? void 0 : _a.displayName;
    if (!state.isCompleted && operationStatus.done) {
      const pagedIterator = this.listAnalyzeActionsResults(state.operationId, {
        abortSignal: this.options.abortSignal,
        tracingOptions: this.options.tracingOptions,
        includeStatistics: this.options.includeStatistics,
        onResponse: this.options.onResponse,
        serializerOptions: this.options.serializerOptions
      });
      state.result = pagedIterator;
      state.isCompleted = true;
    }
    if (typeof options.fireProgress === "function") {
      options.fireProgress(state);
    }
    return this;
  }
  async cancel() {
    const state = this.state;
    logger2.warning(`The service does not yet support cancellation for beginAnalyze.`);
    state.isCancelled = true;
    return this;
  }
};

// node_modules/@azure/ai-text-analytics/dist-esm/src/lro/analyze/poller.js
var BeginAnalyzeActionsPoller = class extends AnalysisPoller {
  // eslint-disable-next-line @azure/azure-sdk/ts-use-interface-parameters
  constructor(pollerOptions) {
    const { client, documents, actions, options, updateIntervalInMs = 5e3, resumeFrom } = pollerOptions;
    let state;
    if (resumeFrom) {
      state = JSON.parse(resumeFrom).state;
    }
    const operation = new BeginAnalyzeActionsPollerOperation(state || {}, client, documents, actions, options);
    super(operation);
    this.updateIntervalInMs = updateIntervalInMs;
  }
  delay() {
    return delay(this.updateIntervalInMs);
  }
};

// node_modules/@azure/ai-text-analytics/dist-esm/src/textAnalyticsClient.js
var DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
var PiiEntityDomain;
(function(PiiEntityDomain2) {
  PiiEntityDomain2["PROTECTED_HEALTH_INFORMATION"] = "PHI";
})(PiiEntityDomain || (PiiEntityDomain = {}));
var TextAnalyticsClient = class {
  /**
   * Creates an instance of TextAnalyticsClient.
   *
   * Example usage:
   * ```ts
   * import { TextAnalyticsClient, AzureKeyCredential } from "@azure/ai-text-analytics";
   *
   * const client = new TextAnalyticsClient(
   *    "<service endpoint>",
   *    new AzureKeyCredential("<api key>")
   * );
   * ```
   * @param endpointUrl - The URL to the TextAnalytics endpoint
   * @param credential - Used to authenticate requests to the service.
   * @param options - Used to configure the TextAnalytics client.
   */
  constructor(endpointUrl, credential, options = {}) {
    this.endpointUrl = endpointUrl;
    const { defaultCountryHint = "us", defaultLanguage = "en" } = options, pipelineOptions = __rest(options, ["defaultCountryHint", "defaultLanguage"]);
    this.defaultCountryHint = defaultCountryHint;
    this.defaultLanguage = defaultLanguage;
    const libInfo = `azsdk-js-ai-textanalytics/${SDK_VERSION}`;
    if (!pipelineOptions.userAgentOptions) {
      pipelineOptions.userAgentOptions = {};
    }
    if (pipelineOptions.userAgentOptions.userAgentPrefix) {
      pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
    } else {
      pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
    }
    const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
      loggingOptions: {
        logger: logger2.info,
        additionalAllowedHeaderNames: ["x-ms-correlation-request-id", "x-ms-request-id"]
      }
    });
    this.client = new GeneratedClient(this.endpointUrl, internalPipelineOptions);
    const authPolicy = isTokenCredential(credential) ? bearerTokenAuthenticationPolicy({ credential, scopes: DEFAULT_COGNITIVE_SCOPE }) : textAnalyticsAzureKeyCredentialPolicy(credential);
    this.client.pipeline.addPolicy(authPolicy);
  }
  async detectLanguage(documents, countryHintOrOptions, options) {
    let realOptions;
    let realInputs;
    if (!Array.isArray(documents) || documents.length === 0) {
      throw new Error("'documents' must be a non-empty array");
    }
    if (isStringArray(documents)) {
      const countryHint = countryHintOrOptions || this.defaultCountryHint;
      realInputs = convertToDetectLanguageInput(documents, countryHint);
      realOptions = options || {};
    } else {
      realInputs = documents.map((input2) => Object.assign(Object.assign({}, input2), { countryHint: input2.countryHint === "none" ? "" : input2.countryHint }));
      realOptions = countryHintOrOptions || {};
    }
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-detectLanguages", makeGeneratedDetectLanguageOptions(realOptions));
    try {
      const result = await this.client.languages({
        documents: realInputs
      }, finalOptions);
      return makeDetectLanguageResultArray(realInputs, result);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  async recognizeEntities(documents, languageOrOptions, options) {
    let realOptions;
    let realInputs;
    if (!Array.isArray(documents) || documents.length === 0) {
      throw new Error("'documents' must be a non-empty array");
    }
    if (isStringArray(documents)) {
      const language = languageOrOptions || this.defaultLanguage;
      realInputs = convertToTextDocumentInput(documents, language);
      realOptions = options || {};
    } else {
      realInputs = documents;
      realOptions = languageOrOptions || {};
    }
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeEntities", makeGeneratedRecognizeCategorizedEntitiesOptions(realOptions));
    try {
      const result = await this.client.entitiesRecognitionGeneral({
        documents: realInputs
      }, finalOptions);
      return makeRecognizeCategorizedEntitiesResultArray(realInputs, result);
    } catch (e) {
      const backwardCompatibleException = handleInvalidDocumentBatch(e);
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: backwardCompatibleException.message
      });
      throw backwardCompatibleException;
    } finally {
      span.end();
    }
  }
  async analyzeSentiment(documents, languageOrOptions, options) {
    let realOptions;
    let realInputs;
    if (!Array.isArray(documents) || documents.length === 0) {
      throw new Error("'documents' must be a non-empty array");
    }
    if (isStringArray(documents)) {
      const language = languageOrOptions || this.defaultLanguage;
      realInputs = convertToTextDocumentInput(documents, language);
      realOptions = options || {};
    } else {
      realInputs = documents;
      realOptions = languageOrOptions || {};
    }
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-analyzeSentiment", makeGeneratedAnalyzeSentimentOptions(realOptions));
    try {
      const result = await this.client.sentiment({
        documents: realInputs
      }, finalOptions);
      return makeAnalyzeSentimentResultArray(realInputs, result);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  async extractKeyPhrases(documents, languageOrOptions, options) {
    let realOptions;
    let realInputs;
    if (!Array.isArray(documents) || documents.length === 0) {
      throw new Error("'documents' must be a non-empty array");
    }
    if (isStringArray(documents)) {
      const language = languageOrOptions || this.defaultLanguage;
      realInputs = convertToTextDocumentInput(documents, language);
      realOptions = options || {};
    } else {
      realInputs = documents;
      realOptions = languageOrOptions || {};
    }
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-extractKeyPhrases", makeGeneratedExtractKeyPhrasesOptions(realOptions));
    try {
      const result = await this.client.keyPhrases({
        documents: realInputs
      }, finalOptions);
      return makeExtractKeyPhrasesResultArray(realInputs, result);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  async recognizePiiEntities(inputs, languageOrOptions, options) {
    let realOptions;
    let realInputs;
    if (isStringArray(inputs)) {
      const language = languageOrOptions || this.defaultLanguage;
      realInputs = convertToTextDocumentInput(inputs, language);
      realOptions = options || {};
    } else {
      realInputs = inputs;
      realOptions = languageOrOptions || {};
    }
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizePiiEntities", makeGeneratedRecognizePiiEntitiesOptions(realOptions));
    try {
      const result = await this.client.entitiesRecognitionPii({
        documents: realInputs
      }, finalOptions);
      return makeRecognizePiiEntitiesResultArray(realInputs, result);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  async recognizeLinkedEntities(documents, languageOrOptions, options) {
    let realOptions;
    let realInputs;
    if (!Array.isArray(documents) || documents.length === 0) {
      throw new Error("'documents' must be a non-empty array");
    }
    if (isStringArray(documents)) {
      const language = languageOrOptions || this.defaultLanguage;
      realInputs = convertToTextDocumentInput(documents, language);
      realOptions = options || {};
    } else {
      realInputs = documents;
      realOptions = languageOrOptions || {};
    }
    const { span, updatedOptions: finalOptions } = createSpan("TextAnalyticsClient-recognizeLinkedEntities", makeGeneratedRecognizeLinkingEntitiesOptions(realOptions));
    try {
      const result = await this.client.entitiesLinking({
        documents: realInputs
      }, finalOptions);
      return makeRecognizeLinkedEntitiesResultArray(realInputs, result);
    } catch (e) {
      span.setStatus({
        code: SpanStatusCode2.ERROR,
        message: e.message
      });
      throw e;
    } finally {
      span.end();
    }
  }
  async beginAnalyzeHealthcareEntities(documents, languageOrOptions, options) {
    let realOptions;
    let realInputs;
    if (isStringArray(documents)) {
      const language = languageOrOptions || this.defaultLanguage;
      realInputs = convertToTextDocumentInput(documents, language);
      realOptions = options || {};
    } else {
      realInputs = documents;
      realOptions = languageOrOptions || {};
    }
    const { updateIntervalInMs, resumeFrom } = realOptions, restOptions = __rest(realOptions, ["updateIntervalInMs", "resumeFrom"]);
    const poller = new BeginAnalyzeHealthcarePoller({
      client: this.client,
      documents: realInputs,
      options: restOptions,
      updateIntervalInMs,
      resumeFrom
    });
    await poller.poll();
    return poller;
  }
  async beginAnalyzeActions(documents, actions, languageOrOptions, options) {
    let realOptions;
    let realInputs;
    if (!Array.isArray(documents) || documents.length === 0) {
      throw new Error("'documents' must be a non-empty array");
    }
    if (isStringArray(documents)) {
      const language = languageOrOptions || this.defaultLanguage;
      realInputs = convertToTextDocumentInput(documents, language);
      realOptions = options || {};
    } else {
      realInputs = documents;
      realOptions = languageOrOptions || {};
    }
    validateActions(actions);
    const compiledActions = compileAnalyzeInput(actions);
    const { updateIntervalInMs, resumeFrom } = realOptions, restOptions = __rest(realOptions, ["updateIntervalInMs", "resumeFrom"]);
    const poller = new BeginAnalyzeActionsPoller({
      client: this.client,
      documents: realInputs,
      actions: compiledActions,
      options: restOptions,
      resumeFrom,
      updateIntervalInMs
    });
    await poller.poll();
    return poller;
  }
};
function validateActions(actions) {
  function validateActionType(actionList, actionType) {
    var _a;
    if (((_a = actionList === null || actionList === void 0 ? void 0 : actionList.length) !== null && _a !== void 0 ? _a : 0) > 1) {
      throw new Error(`beginAnalyzeActions: Currently, the service can accept up to one action only for ${actionType} actions.`);
    }
  }
  validateActionType(actions.analyzeSentimentActions, `analyzeSentiment`);
  validateActionType(actions.extractKeyPhrasesActions, `extractKeyPhrases`);
  validateActionType(actions.recognizeEntitiesActions, `recognizeEntities`);
  validateActionType(actions.recognizeLinkedEntitiesActions, `recognizeLinkedEntities`);
  validateActionType(actions.recognizePiiEntitiesActions, `recognizePiiEntities`);
}
function compileAnalyzeInput(actions) {
  var _a, _b, _c, _d, _e;
  return {
    entityRecognitionPiiTasks: (_a = actions.recognizePiiEntitiesActions) === null || _a === void 0 ? void 0 : _a.map(compose(setStrEncodingParam, compose(setCategoriesFilter, addParamsToTask))),
    entityRecognitionTasks: (_b = actions.recognizeEntitiesActions) === null || _b === void 0 ? void 0 : _b.map(compose(setStrEncodingParam, addParamsToTask)),
    keyPhraseExtractionTasks: (_c = actions.extractKeyPhrasesActions) === null || _c === void 0 ? void 0 : _c.map(addParamsToTask),
    entityLinkingTasks: (_d = actions.recognizeLinkedEntitiesActions) === null || _d === void 0 ? void 0 : _d.map(compose(setStrEncodingParam, addParamsToTask)),
    sentimentAnalysisTasks: (_e = actions.analyzeSentimentActions) === null || _e === void 0 ? void 0 : _e.map(compose(setStrEncodingParam, compose(setOpinionMining, addParamsToTask)))
  };
}
function isStringArray(documents) {
  return typeof documents[0] === "string";
}
function convertToDetectLanguageInput(inputs, countryHint) {
  if (countryHint === "none") {
    countryHint = "";
  }
  return inputs.map((text, index) => {
    return {
      id: String(index),
      countryHint,
      text
    };
  });
}
function convertToTextDocumentInput(inputs, language) {
  return inputs.map((text, index) => {
    return {
      id: String(index),
      language,
      text
    };
  });
}
function makeGeneratedAnalyzeSentimentOptions(params) {
  return {
    abortSignal: params.abortSignal,
    opinionMining: params.includeOpinionMining,
    includeStatistics: params.includeStatistics,
    modelVersion: params.modelVersion,
    requestOptions: params.requestOptions,
    stringIndexType: setStrEncodingParamValue(params.stringIndexType),
    tracingOptions: params.tracingOptions,
    onResponse: params.onResponse,
    serializerOptions: params.serializerOptions,
    loggingOptOut: params.disableServiceLogs
  };
}
function makeGeneratedRecognizePiiEntitiesOptions(params) {
  return {
    abortSignal: params.abortSignal,
    domain: params.domainFilter,
    includeStatistics: params.includeStatistics,
    modelVersion: params.modelVersion,
    requestOptions: params.requestOptions,
    stringIndexType: setStrEncodingParamValue(params.stringIndexType),
    tracingOptions: params.tracingOptions,
    piiCategories: params.categoriesFilter,
    onResponse: params.onResponse,
    serializerOptions: params.serializerOptions,
    loggingOptOut: params.disableServiceLogs
  };
}
function makeGeneratedRecognizeCategorizedEntitiesOptions(params) {
  return {
    abortSignal: params.abortSignal,
    includeStatistics: params.includeStatistics,
    modelVersion: params.modelVersion,
    requestOptions: params.requestOptions,
    stringIndexType: setStrEncodingParamValue(params.stringIndexType),
    tracingOptions: params.tracingOptions,
    onResponse: params.onResponse,
    serializerOptions: params.serializerOptions,
    loggingOptOut: params.disableServiceLogs
  };
}
function makeGeneratedDetectLanguageOptions(params) {
  return {
    abortSignal: params.abortSignal,
    includeStatistics: params.includeStatistics,
    modelVersion: params.modelVersion,
    requestOptions: params.requestOptions,
    tracingOptions: params.tracingOptions,
    onResponse: params.onResponse,
    serializerOptions: params.serializerOptions,
    loggingOptOut: params.disableServiceLogs
  };
}
function makeGeneratedExtractKeyPhrasesOptions(params) {
  return {
    abortSignal: params.abortSignal,
    includeStatistics: params.includeStatistics,
    modelVersion: params.modelVersion,
    requestOptions: params.requestOptions,
    tracingOptions: params.tracingOptions,
    onResponse: params.onResponse,
    serializerOptions: params.serializerOptions,
    loggingOptOut: params.disableServiceLogs
  };
}
function makeGeneratedRecognizeLinkingEntitiesOptions(params) {
  return {
    abortSignal: params.abortSignal,
    includeStatistics: params.includeStatistics,
    modelVersion: params.modelVersion,
    requestOptions: params.requestOptions,
    tracingOptions: params.tracingOptions,
    onResponse: params.onResponse,
    serializerOptions: params.serializerOptions,
    loggingOptOut: params.disableServiceLogs,
    stringIndexType: setStrEncodingParamValue(params.stringIndexType)
  };
}
export {
  AzureKeyCredential,
  PiiEntityDomain,
  TextAnalyticsClient
};
//# sourceMappingURL=@azure_ai-text-analytics.js.map
