import {
  AbortError,
  RestError,
  bearerTokenAuthenticationPolicy,
  createClientLogger,
  createDefaultHttpClient,
  createEmptyPipeline,
  createHttpHeaders,
  createPipelineRequest
} from "./chunk-6EDKNDAJ.js";
import {
  __asyncGenerator,
  __await
} from "./chunk-ZDQUMZSZ.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/priorityqueuejs/index.js
var require_priorityqueuejs = __commonJS({
  "node_modules/priorityqueuejs/index.js"(exports, module) {
    module.exports = PriorityQueue2;
    function PriorityQueue2(comparator) {
      this._comparator = comparator || PriorityQueue2.DEFAULT_COMPARATOR;
      this._elements = [];
    }
    PriorityQueue2.DEFAULT_COMPARATOR = function(a, b) {
      if (typeof a === "number" && typeof b === "number") {
        return a - b;
      } else {
        a = a.toString();
        b = b.toString();
        if (a == b)
          return 0;
        return a > b ? 1 : -1;
      }
    };
    PriorityQueue2.prototype.isEmpty = function() {
      return this.size() === 0;
    };
    PriorityQueue2.prototype.peek = function() {
      if (this.isEmpty())
        throw new Error("PriorityQueue is empty");
      return this._elements[0];
    };
    PriorityQueue2.prototype.deq = function() {
      var first = this.peek();
      var last = this._elements.pop();
      var size = this.size();
      if (size === 0)
        return first;
      this._elements[0] = last;
      var current = 0;
      while (current < size) {
        var largest = current;
        var left = 2 * current + 1;
        var right = 2 * current + 2;
        if (left < size && this._compare(left, largest) >= 0) {
          largest = left;
        }
        if (right < size && this._compare(right, largest) >= 0) {
          largest = right;
        }
        if (largest === current)
          break;
        this._swap(largest, current);
        current = largest;
      }
      return first;
    };
    PriorityQueue2.prototype.enq = function(element) {
      var size = this._elements.push(element);
      var current = size - 1;
      while (current > 0) {
        var parent = Math.floor((current - 1) / 2);
        if (this._compare(current, parent) <= 0)
          break;
        this._swap(parent, current);
        current = parent;
      }
      return size;
    };
    PriorityQueue2.prototype.size = function() {
      return this._elements.length;
    };
    PriorityQueue2.prototype.forEach = function(fn) {
      return this._elements.forEach(fn);
    };
    PriorityQueue2.prototype._compare = function(a, b) {
      return this._comparator(this._elements[a], this._elements[b]);
    };
    PriorityQueue2.prototype._swap = function(a, b) {
      var aux = this._elements[a];
      this._elements[a] = this._elements[b];
      this._elements[b] = aux;
    };
  }
});

// node_modules/semaphore/lib/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/semaphore/lib/semaphore.js"(exports, module) {
    (function(global) {
      "use strict";
      var nextTick = function(fn) {
        setTimeout(fn, 0);
      };
      if (typeof process != "undefined" && process && typeof process.nextTick == "function") {
        nextTick = process.nextTick;
      }
      function semaphore2(capacity) {
        var semaphore3 = {
          capacity: capacity || 1,
          current: 0,
          queue: [],
          firstHere: false,
          take: function() {
            if (semaphore3.firstHere === false) {
              semaphore3.current++;
              semaphore3.firstHere = true;
              var isFirst = 1;
            } else {
              var isFirst = 0;
            }
            var item = { n: 1 };
            if (typeof arguments[0] == "function") {
              item.task = arguments[0];
            } else {
              item.n = arguments[0];
            }
            if (arguments.length >= 2) {
              if (typeof arguments[1] == "function")
                item.task = arguments[1];
              else
                item.n = arguments[1];
            }
            var task = item.task;
            item.task = function() {
              task(semaphore3.leave);
            };
            if (semaphore3.current + item.n - isFirst > semaphore3.capacity) {
              if (isFirst === 1) {
                semaphore3.current--;
                semaphore3.firstHere = false;
              }
              return semaphore3.queue.push(item);
            }
            semaphore3.current += item.n - isFirst;
            item.task(semaphore3.leave);
            if (isFirst === 1)
              semaphore3.firstHere = false;
          },
          leave: function(n) {
            n = n || 1;
            semaphore3.current -= n;
            if (!semaphore3.queue.length) {
              if (semaphore3.current < 0) {
                throw new Error("leave called too many times.");
              }
              return;
            }
            var item = semaphore3.queue[0];
            if (item.n + semaphore3.current > semaphore3.capacity) {
              return;
            }
            semaphore3.queue.shift();
            semaphore3.current += item.n;
            nextTick(item.task);
          },
          available: function(n) {
            n = n || 1;
            return semaphore3.current + n <= semaphore3.capacity;
          }
        };
        return semaphore3;
      }
      ;
      if (typeof exports === "object") {
        module.exports = semaphore2;
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return semaphore2;
        });
      } else {
        global.semaphore = semaphore2;
      }
    })(exports);
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS({
  "node_modules/fast-json-stable-stringify/index.js"(exports, module) {
    "use strict";
    module.exports = function(data, opts) {
      if (!opts)
        opts = {};
      if (typeof opts === "function")
        opts = { cmp: opts };
      var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
      var cmp = opts.cmp && function(f2) {
        return function(node) {
          return function(a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f2(aobj, bobj);
          };
        };
      }(opts.cmp);
      var seen = [];
      return function stringify2(node) {
        if (node && node.toJSON && typeof node.toJSON === "function") {
          node = node.toJSON();
        }
        if (node === void 0)
          return;
        if (typeof node == "number")
          return isFinite(node) ? "" + node : "null";
        if (typeof node !== "object")
          return JSON.stringify(node);
        var i, out;
        if (Array.isArray(node)) {
          out = "[";
          for (i = 0; i < node.length; i++) {
            if (i)
              out += ",";
            out += stringify2(node[i]) || "null";
          }
          return out + "]";
        }
        if (node === null)
          return "null";
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        }
        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = "";
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify2(node[key]);
          if (!value)
            continue;
          if (out)
            out += ",";
          out += JSON.stringify(key) + ":" + value;
        }
        seen.splice(seenIndex, 1);
        return "{" + out + "}";
      }(data);
    };
  }
});

// node_modules/node-abort-controller/browser.js
var require_browser = __commonJS({
  "node_modules/node-abort-controller/browser.js"(exports, module) {
    "use strict";
    var _global = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    if (!_global) {
      throw new Error(
        `Unable to find global scope. Are you sure this is running in the browser?`
      );
    }
    if (!_global.AbortController) {
      throw new Error(
        `Could not find "AbortController" in the global scope. You need to polyfill it first`
      );
    }
    module.exports.AbortController = _global.AbortController;
  }
});

// node_modules/@azure/cosmos/dist-esm/src/common/partitionKeys.js
var DEFAULT_PARTITION_KEY_PATH = "/_partitionKey";

// node_modules/@azure/cosmos/dist-esm/src/common/constants.js
var Constants = {
  HttpHeaders: {
    Authorization: "authorization",
    ETag: "etag",
    MethodOverride: "X-HTTP-Method",
    Slug: "Slug",
    ContentType: "Content-Type",
    LastModified: "Last-Modified",
    ContentEncoding: "Content-Encoding",
    CharacterSet: "CharacterSet",
    UserAgent: "User-Agent",
    IfModifiedSince: "If-Modified-Since",
    IfMatch: "If-Match",
    IfNoneMatch: "If-None-Match",
    ContentLength: "Content-Length",
    AcceptEncoding: "Accept-Encoding",
    KeepAlive: "Keep-Alive",
    CacheControl: "Cache-Control",
    TransferEncoding: "Transfer-Encoding",
    ContentLanguage: "Content-Language",
    ContentLocation: "Content-Location",
    ContentMd5: "Content-Md5",
    ContentRange: "Content-Range",
    Accept: "Accept",
    AcceptCharset: "Accept-Charset",
    AcceptLanguage: "Accept-Language",
    IfRange: "If-Range",
    IfUnmodifiedSince: "If-Unmodified-Since",
    MaxForwards: "Max-Forwards",
    ProxyAuthorization: "Proxy-Authorization",
    AcceptRanges: "Accept-Ranges",
    ProxyAuthenticate: "Proxy-Authenticate",
    RetryAfter: "Retry-After",
    SetCookie: "Set-Cookie",
    WwwAuthenticate: "Www-Authenticate",
    Origin: "Origin",
    Host: "Host",
    AccessControlAllowOrigin: "Access-Control-Allow-Origin",
    AccessControlAllowHeaders: "Access-Control-Allow-Headers",
    KeyValueEncodingFormat: "application/x-www-form-urlencoded",
    WrapAssertionFormat: "wrap_assertion_format",
    WrapAssertion: "wrap_assertion",
    WrapScope: "wrap_scope",
    SimpleToken: "SWT",
    HttpDate: "date",
    Prefer: "Prefer",
    Location: "Location",
    Referer: "referer",
    A_IM: "A-IM",
    // Query
    Query: "x-ms-documentdb-query",
    IsQuery: "x-ms-documentdb-isquery",
    IsQueryPlan: "x-ms-cosmos-is-query-plan-request",
    SupportedQueryFeatures: "x-ms-cosmos-supported-query-features",
    QueryVersion: "x-ms-cosmos-query-version",
    // Our custom Azure Cosmos DB headers
    Continuation: "x-ms-continuation",
    ContinuationToken: "x-ms-continuation-token",
    PageSize: "x-ms-max-item-count",
    ItemCount: "x-ms-item-count",
    // Request sender generated. Simply echoed by backend.
    ActivityId: "x-ms-activity-id",
    PreTriggerInclude: "x-ms-documentdb-pre-trigger-include",
    PreTriggerExclude: "x-ms-documentdb-pre-trigger-exclude",
    PostTriggerInclude: "x-ms-documentdb-post-trigger-include",
    PostTriggerExclude: "x-ms-documentdb-post-trigger-exclude",
    IndexingDirective: "x-ms-indexing-directive",
    SessionToken: "x-ms-session-token",
    ConsistencyLevel: "x-ms-consistency-level",
    XDate: "x-ms-date",
    CollectionPartitionInfo: "x-ms-collection-partition-info",
    CollectionServiceInfo: "x-ms-collection-service-info",
    // Deprecated, use RetryAfterInMs instead.
    RetryAfterInMilliseconds: "x-ms-retry-after-ms",
    RetryAfterInMs: "x-ms-retry-after-ms",
    IsFeedUnfiltered: "x-ms-is-feed-unfiltered",
    ResourceTokenExpiry: "x-ms-documentdb-expiry-seconds",
    EnableScanInQuery: "x-ms-documentdb-query-enable-scan",
    EmitVerboseTracesInQuery: "x-ms-documentdb-query-emit-traces",
    EnableCrossPartitionQuery: "x-ms-documentdb-query-enablecrosspartition",
    ParallelizeCrossPartitionQuery: "x-ms-documentdb-query-parallelizecrosspartitionquery",
    ResponseContinuationTokenLimitInKB: "x-ms-documentdb-responsecontinuationtokenlimitinkb",
    // QueryMetrics
    // Request header to tell backend to give you query metrics.
    PopulateQueryMetrics: "x-ms-documentdb-populatequerymetrics",
    // Response header that holds the serialized version of query metrics.
    QueryMetrics: "x-ms-documentdb-query-metrics",
    // IndexMetrics
    // Request header to tell backend to give you index metrics.
    PopulateIndexMetrics: "x-ms-cosmos-populateindexmetrics",
    // Response header that holds the serialized version of index metrics.
    IndexUtilization: "x-ms-cosmos-index-utilization",
    // Version headers and values
    Version: "x-ms-version",
    // Owner name
    OwnerFullName: "x-ms-alt-content-path",
    // Owner ID used for name based request in session token.
    OwnerId: "x-ms-content-path",
    // Partition Key
    PartitionKey: "x-ms-documentdb-partitionkey",
    PartitionKeyRangeID: "x-ms-documentdb-partitionkeyrangeid",
    // Epk Range headers
    StartEpk: "x-ms-start-epk",
    EndEpk: "x-ms-end-epk",
    // Read Feed Type
    ReadFeedKeyType: "x-ms-read-key-type",
    // Quota Info
    MaxEntityCount: "x-ms-root-entity-max-count",
    CurrentEntityCount: "x-ms-root-entity-current-count",
    CollectionQuotaInMb: "x-ms-collection-quota-mb",
    CollectionCurrentUsageInMb: "x-ms-collection-usage-mb",
    MaxMediaStorageUsageInMB: "x-ms-max-media-storage-usage-mb",
    CurrentMediaStorageUsageInMB: "x-ms-media-storage-usage-mb",
    RequestCharge: "x-ms-request-charge",
    PopulateQuotaInfo: "x-ms-documentdb-populatequotainfo",
    MaxResourceQuota: "x-ms-resource-quota",
    // Offer header
    OfferType: "x-ms-offer-type",
    OfferThroughput: "x-ms-offer-throughput",
    AutoscaleSettings: "x-ms-cosmos-offer-autopilot-settings",
    // Custom RUs/minute headers
    DisableRUPerMinuteUsage: "x-ms-documentdb-disable-ru-per-minute-usage",
    IsRUPerMinuteUsed: "x-ms-documentdb-is-ru-per-minute-used",
    OfferIsRUPerMinuteThroughputEnabled: "x-ms-offer-is-ru-per-minute-throughput-enabled",
    // Index progress headers
    IndexTransformationProgress: "x-ms-documentdb-collection-index-transformation-progress",
    LazyIndexingProgress: "x-ms-documentdb-collection-lazy-indexing-progress",
    // Upsert header
    IsUpsert: "x-ms-documentdb-is-upsert",
    // Sub status of the error
    SubStatus: "x-ms-substatus",
    // StoredProcedure related headers
    EnableScriptLogging: "x-ms-documentdb-script-enable-logging",
    ScriptLogResults: "x-ms-documentdb-script-log-results",
    // Multi-Region Write
    ALLOW_MULTIPLE_WRITES: "x-ms-cosmos-allow-tentative-writes",
    // Bulk/Batch header
    IsBatchRequest: "x-ms-cosmos-is-batch-request",
    IsBatchAtomic: "x-ms-cosmos-batch-atomic",
    BatchContinueOnError: "x-ms-cosmos-batch-continue-on-error",
    // Dedicated Gateway Headers
    DedicatedGatewayPerRequestCacheStaleness: "x-ms-dedicatedgateway-max-age",
    // Cache Refresh header
    ForceRefresh: "x-ms-force-refresh",
    // Priority Based throttling header
    PriorityLevel: "x-ms-cosmos-priority-level"
  },
  // GlobalDB related constants
  WritableLocations: "writableLocations",
  ReadableLocations: "readableLocations",
  LocationUnavailableExpirationTimeInMs: 5 * 60 * 1e3,
  // ServiceDocument Resource
  ENABLE_MULTIPLE_WRITABLE_LOCATIONS: "enableMultipleWriteLocations",
  // Background refresh time
  DefaultUnavailableLocationExpirationTimeMS: 5 * 60 * 1e3,
  // Client generated retry count response header
  ThrottleRetryCount: "x-ms-throttle-retry-count",
  ThrottleRetryWaitTimeInMs: "x-ms-throttle-retry-wait-time-ms",
  // Platform
  CurrentVersion: "2020-07-15",
  AzureNamespace: "Azure.Cosmos",
  AzurePackageName: "@azure/cosmos",
  SDKName: "azure-cosmos-js",
  SDKVersion: "4.0.0",
  // Diagnostics
  CosmosDbDiagnosticLevelEnvVarName: "AZURE_COSMOSDB_DIAGNOSTICS_LEVEL",
  // Bulk Operations
  DefaultMaxBulkRequestBodySizeInBytes: 220201,
  Quota: {
    CollectionSize: "collectionSize"
  },
  Path: {
    Root: "/",
    DatabasesPathSegment: "dbs",
    CollectionsPathSegment: "colls",
    UsersPathSegment: "users",
    DocumentsPathSegment: "docs",
    PermissionsPathSegment: "permissions",
    StoredProceduresPathSegment: "sprocs",
    TriggersPathSegment: "triggers",
    UserDefinedFunctionsPathSegment: "udfs",
    ConflictsPathSegment: "conflicts",
    AttachmentsPathSegment: "attachments",
    PartitionKeyRangesPathSegment: "pkranges",
    SchemasPathSegment: "schemas",
    OffersPathSegment: "offers",
    TopologyPathSegment: "topology",
    DatabaseAccountPathSegment: "databaseaccount"
  },
  PartitionKeyRange: {
    // Partition Key Range Constants
    MinInclusive: "minInclusive",
    MaxExclusive: "maxExclusive",
    Id: "id"
  },
  QueryRangeConstants: {
    // Partition Key Range Constants
    MinInclusive: "minInclusive",
    MaxExclusive: "maxExclusive",
    min: "min"
  },
  /**
   * @deprecated Use EffectivePartitionKeyConstants instead
   */
  EffectiveParitionKeyConstants: {
    MinimumInclusiveEffectivePartitionKey: "",
    MaximumExclusiveEffectivePartitionKey: "FF"
  },
  EffectivePartitionKeyConstants: {
    MinimumInclusiveEffectivePartitionKey: "",
    MaximumExclusiveEffectivePartitionKey: "FF"
  }
};
var ResourceType;
(function(ResourceType2) {
  ResourceType2["none"] = "";
  ResourceType2["database"] = "dbs";
  ResourceType2["offer"] = "offers";
  ResourceType2["user"] = "users";
  ResourceType2["permission"] = "permissions";
  ResourceType2["container"] = "colls";
  ResourceType2["conflicts"] = "conflicts";
  ResourceType2["sproc"] = "sprocs";
  ResourceType2["udf"] = "udfs";
  ResourceType2["trigger"] = "triggers";
  ResourceType2["item"] = "docs";
  ResourceType2["pkranges"] = "pkranges";
  ResourceType2["partitionkey"] = "partitionKey";
})(ResourceType || (ResourceType = {}));
var HTTPMethod;
(function(HTTPMethod2) {
  HTTPMethod2["get"] = "GET";
  HTTPMethod2["patch"] = "PATCH";
  HTTPMethod2["post"] = "POST";
  HTTPMethod2["put"] = "PUT";
  HTTPMethod2["delete"] = "DELETE";
})(HTTPMethod || (HTTPMethod = {}));
var OperationType;
(function(OperationType2) {
  OperationType2["Create"] = "create";
  OperationType2["Replace"] = "replace";
  OperationType2["Upsert"] = "upsert";
  OperationType2["Delete"] = "delete";
  OperationType2["Read"] = "read";
  OperationType2["Query"] = "query";
  OperationType2["Execute"] = "execute";
  OperationType2["Batch"] = "batch";
  OperationType2["Patch"] = "patch";
})(OperationType || (OperationType = {}));
var CosmosKeyType;
(function(CosmosKeyType2) {
  CosmosKeyType2["PrimaryMaster"] = "PRIMARY_MASTER";
  CosmosKeyType2["SecondaryMaster"] = "SECONDARY_MASTER";
  CosmosKeyType2["PrimaryReadOnly"] = "PRIMARY_READONLY";
  CosmosKeyType2["SecondaryReadOnly"] = "SECONDARY_READONLY";
})(CosmosKeyType || (CosmosKeyType = {}));
var CosmosContainerChildResourceKind;
(function(CosmosContainerChildResourceKind2) {
  CosmosContainerChildResourceKind2["Item"] = "ITEM";
  CosmosContainerChildResourceKind2["StoredProcedure"] = "STORED_PROCEDURE";
  CosmosContainerChildResourceKind2["UserDefinedFunction"] = "USER_DEFINED_FUNCTION";
  CosmosContainerChildResourceKind2["Trigger"] = "TRIGGER";
})(CosmosContainerChildResourceKind || (CosmosContainerChildResourceKind = {}));
var PermissionScopeValues;
(function(PermissionScopeValues2) {
  PermissionScopeValues2[PermissionScopeValues2["ScopeAccountReadValue"] = 1] = "ScopeAccountReadValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeAccountListDatabasesValue"] = 2] = "ScopeAccountListDatabasesValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeDatabaseReadValue"] = 4] = "ScopeDatabaseReadValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeDatabaseReadOfferValue"] = 8] = "ScopeDatabaseReadOfferValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeDatabaseListContainerValue"] = 16] = "ScopeDatabaseListContainerValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReadValue"] = 32] = "ScopeContainerReadValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReadOfferValue"] = 64] = "ScopeContainerReadOfferValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeAccountCreateDatabasesValue"] = 1] = "ScopeAccountCreateDatabasesValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeAccountDeleteDatabasesValue"] = 2] = "ScopeAccountDeleteDatabasesValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeDatabaseDeleteValue"] = 4] = "ScopeDatabaseDeleteValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeDatabaseReplaceOfferValue"] = 8] = "ScopeDatabaseReplaceOfferValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeDatabaseCreateContainerValue"] = 16] = "ScopeDatabaseCreateContainerValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeDatabaseDeleteContainerValue"] = 32] = "ScopeDatabaseDeleteContainerValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReplaceValue"] = 64] = "ScopeContainerReplaceValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerDeleteValue"] = 128] = "ScopeContainerDeleteValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReplaceOfferValue"] = 256] = "ScopeContainerReplaceOfferValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeAccountReadAllAccessValue"] = 65535] = "ScopeAccountReadAllAccessValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeDatabaseReadAllAccessValue"] = 124] = "ScopeDatabaseReadAllAccessValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainersReadAllAccessValue"] = 96] = "ScopeContainersReadAllAccessValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeAccountWriteAllAccessValue"] = 65535] = "ScopeAccountWriteAllAccessValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeDatabaseWriteAllAccessValue"] = 508] = "ScopeDatabaseWriteAllAccessValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainersWriteAllAccessValue"] = 448] = "ScopeContainersWriteAllAccessValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerExecuteQueriesValue"] = 1] = "ScopeContainerExecuteQueriesValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReadFeedsValue"] = 2] = "ScopeContainerReadFeedsValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReadStoredProceduresValue"] = 4] = "ScopeContainerReadStoredProceduresValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReadUserDefinedFunctionsValue"] = 8] = "ScopeContainerReadUserDefinedFunctionsValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReadTriggersValue"] = 16] = "ScopeContainerReadTriggersValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReadConflictsValue"] = 32] = "ScopeContainerReadConflictsValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeItemReadValue"] = 64] = "ScopeItemReadValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeStoredProcedureReadValue"] = 128] = "ScopeStoredProcedureReadValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeUserDefinedFunctionReadValue"] = 256] = "ScopeUserDefinedFunctionReadValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeTriggerReadValue"] = 512] = "ScopeTriggerReadValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerCreateItemsValue"] = 1] = "ScopeContainerCreateItemsValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReplaceItemsValue"] = 2] = "ScopeContainerReplaceItemsValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerUpsertItemsValue"] = 4] = "ScopeContainerUpsertItemsValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerDeleteItemsValue"] = 8] = "ScopeContainerDeleteItemsValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerCreateStoredProceduresValue"] = 16] = "ScopeContainerCreateStoredProceduresValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReplaceStoredProceduresValue"] = 32] = "ScopeContainerReplaceStoredProceduresValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerDeleteStoredProceduresValue"] = 64] = "ScopeContainerDeleteStoredProceduresValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerExecuteStoredProceduresValue"] = 128] = "ScopeContainerExecuteStoredProceduresValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerCreateTriggersValue"] = 256] = "ScopeContainerCreateTriggersValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReplaceTriggersValue"] = 512] = "ScopeContainerReplaceTriggersValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerDeleteTriggersValue"] = 1024] = "ScopeContainerDeleteTriggersValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerCreateUserDefinedFunctionsValue"] = 2048] = "ScopeContainerCreateUserDefinedFunctionsValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReplaceUserDefinedFunctionsValue"] = 4096] = "ScopeContainerReplaceUserDefinedFunctionsValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerDeleteUserDefinedFunctionSValue"] = 8192] = "ScopeContainerDeleteUserDefinedFunctionSValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerDeleteCONFLICTSValue"] = 16384] = "ScopeContainerDeleteCONFLICTSValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeItemReplaceValue"] = 65536] = "ScopeItemReplaceValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeItemUpsertValue"] = 131072] = "ScopeItemUpsertValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeItemDeleteValue"] = 262144] = "ScopeItemDeleteValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeStoredProcedureReplaceValue"] = 1048576] = "ScopeStoredProcedureReplaceValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeStoredProcedureDeleteValue"] = 2097152] = "ScopeStoredProcedureDeleteValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeStoredProcedureExecuteValue"] = 4194304] = "ScopeStoredProcedureExecuteValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeUserDefinedFunctionReplaceValue"] = 8388608] = "ScopeUserDefinedFunctionReplaceValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeUserDefinedFunctionDeleteValue"] = 16777216] = "ScopeUserDefinedFunctionDeleteValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeTriggerReplaceValue"] = 33554432] = "ScopeTriggerReplaceValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeTriggerDeleteValue"] = 67108864] = "ScopeTriggerDeleteValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerReadAllAccessValue"] = 4294967295] = "ScopeContainerReadAllAccessValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeItemReadAllAccessValue"] = 65] = "ScopeItemReadAllAccessValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeContainerWriteAllAccessValue"] = 4294967295] = "ScopeContainerWriteAllAccessValue";
  PermissionScopeValues2[PermissionScopeValues2["ScopeItemWriteAllAccessValue"] = 458767] = "ScopeItemWriteAllAccessValue";
  PermissionScopeValues2[PermissionScopeValues2["NoneValue"] = 0] = "NoneValue";
})(PermissionScopeValues || (PermissionScopeValues = {}));
var SasTokenPermissionKind;
(function(SasTokenPermissionKind2) {
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerCreateItems"] = 1] = "ContainerCreateItems";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerReplaceItems"] = 2] = "ContainerReplaceItems";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerUpsertItems"] = 4] = "ContainerUpsertItems";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerDeleteItems"] = 128] = "ContainerDeleteItems";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerExecuteQueries"] = 1] = "ContainerExecuteQueries";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerReadFeeds"] = 2] = "ContainerReadFeeds";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerCreateStoreProcedure"] = 16] = "ContainerCreateStoreProcedure";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerReadStoreProcedure"] = 4] = "ContainerReadStoreProcedure";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerReplaceStoreProcedure"] = 32] = "ContainerReplaceStoreProcedure";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerDeleteStoreProcedure"] = 64] = "ContainerDeleteStoreProcedure";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerCreateTriggers"] = 256] = "ContainerCreateTriggers";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerReadTriggers"] = 16] = "ContainerReadTriggers";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerReplaceTriggers"] = 512] = "ContainerReplaceTriggers";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerDeleteTriggers"] = 1024] = "ContainerDeleteTriggers";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerCreateUserDefinedFunctions"] = 2048] = "ContainerCreateUserDefinedFunctions";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerReadUserDefinedFunctions"] = 8] = "ContainerReadUserDefinedFunctions";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerReplaceUserDefinedFunctions"] = 4096] = "ContainerReplaceUserDefinedFunctions";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerDeleteUserDefinedFunctions"] = 8192] = "ContainerDeleteUserDefinedFunctions";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerExecuteStoredProcedure"] = 128] = "ContainerExecuteStoredProcedure";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerReadConflicts"] = 32] = "ContainerReadConflicts";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerDeleteConflicts"] = 16384] = "ContainerDeleteConflicts";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerReadAny"] = 64] = "ContainerReadAny";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ContainerFullAccess"] = 4294967295] = "ContainerFullAccess";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ItemReadAny"] = 65536] = "ItemReadAny";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ItemFullAccess"] = 65] = "ItemFullAccess";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ItemRead"] = 64] = "ItemRead";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ItemReplace"] = 65536] = "ItemReplace";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ItemUpsert"] = 131072] = "ItemUpsert";
  SasTokenPermissionKind2[SasTokenPermissionKind2["ItemDelete"] = 262144] = "ItemDelete";
  SasTokenPermissionKind2[SasTokenPermissionKind2["StoreProcedureRead"] = 128] = "StoreProcedureRead";
  SasTokenPermissionKind2[SasTokenPermissionKind2["StoreProcedureReplace"] = 1048576] = "StoreProcedureReplace";
  SasTokenPermissionKind2[SasTokenPermissionKind2["StoreProcedureDelete"] = 2097152] = "StoreProcedureDelete";
  SasTokenPermissionKind2[SasTokenPermissionKind2["StoreProcedureExecute"] = 4194304] = "StoreProcedureExecute";
  SasTokenPermissionKind2[SasTokenPermissionKind2["UserDefinedFuntionRead"] = 256] = "UserDefinedFuntionRead";
  SasTokenPermissionKind2[SasTokenPermissionKind2["UserDefinedFuntionReplace"] = 8388608] = "UserDefinedFuntionReplace";
  SasTokenPermissionKind2[SasTokenPermissionKind2["UserDefinedFuntionDelete"] = 16777216] = "UserDefinedFuntionDelete";
  SasTokenPermissionKind2[SasTokenPermissionKind2["TriggerRead"] = 512] = "TriggerRead";
  SasTokenPermissionKind2[SasTokenPermissionKind2["TriggerReplace"] = 33554432] = "TriggerReplace";
  SasTokenPermissionKind2[SasTokenPermissionKind2["TriggerDelete"] = 67108864] = "TriggerDelete";
})(SasTokenPermissionKind || (SasTokenPermissionKind = {}));

// node_modules/@azure/cosmos/dist-esm/src/common/helper.js
var trimLeftSlashes = new RegExp("^[/]+");
var trimRightSlashes = new RegExp("[/]+$");
var illegalResourceIdCharacters = new RegExp("[/\\\\?#]");
var illegalItemResourceIdCharacters = new RegExp("[/\\\\#]");
function jsonStringifyAndEscapeNonASCII(arg) {
  return JSON.stringify(arg).replace(/[\u007F-\uFFFF]/g, (m) => {
    return "\\u" + ("0000" + m.charCodeAt(0).toString(16)).slice(-4);
  });
}
function parseLink(resourcePath) {
  if (resourcePath.length === 0) {
    return {
      type: void 0,
      objectBody: void 0
    };
  }
  if (resourcePath[resourcePath.length - 1] !== "/") {
    resourcePath = resourcePath + "/";
  }
  if (resourcePath[0] !== "/") {
    resourcePath = "/" + resourcePath;
  }
  const pathParts = resourcePath.split("/");
  let id;
  let type;
  if (pathParts.length % 2 === 0) {
    id = pathParts[pathParts.length - 2];
    type = pathParts[pathParts.length - 3];
  } else {
    id = pathParts[pathParts.length - 3];
    type = pathParts[pathParts.length - 2];
  }
  const result = {
    type,
    objectBody: {
      id,
      self: resourcePath
    }
  };
  return result;
}
function isReadRequest(operationType) {
  return operationType === OperationType.Read || operationType === OperationType.Query;
}
function sleep(time) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, time);
  });
}
function getContainerLink(link) {
  return link.split("/").slice(0, 4).join("/");
}
function prepareURL(endpoint, path) {
  return trimSlashes(endpoint) + path;
}
function trimSlashes(source) {
  return source.replace(trimLeftSlashes, "").replace(trimRightSlashes, "");
}
function parsePath(path) {
  const pathParts = [];
  let currentIndex = 0;
  const throwError = () => {
    throw new Error("Path " + path + " is invalid at index " + currentIndex);
  };
  const getEscapedToken = () => {
    const quote = path[currentIndex];
    let newIndex = ++currentIndex;
    for (; ; ) {
      newIndex = path.indexOf(quote, newIndex);
      if (newIndex === -1) {
        throwError();
      }
      if (path[newIndex - 1] !== "\\") {
        break;
      }
      ++newIndex;
    }
    const token = path.substr(currentIndex, newIndex - currentIndex);
    currentIndex = newIndex + 1;
    return token;
  };
  const getToken = () => {
    const newIndex = path.indexOf("/", currentIndex);
    let token = null;
    if (newIndex === -1) {
      token = path.substr(currentIndex);
      currentIndex = path.length;
    } else {
      token = path.substr(currentIndex, newIndex - currentIndex);
      currentIndex = newIndex;
    }
    token = token.trim();
    return token;
  };
  while (currentIndex < path.length) {
    if (path[currentIndex] !== "/") {
      throwError();
    }
    if (++currentIndex === path.length) {
      break;
    }
    if (path[currentIndex] === '"' || path[currentIndex] === "'") {
      pathParts.push(getEscapedToken());
    } else {
      pathParts.push(getToken());
    }
  }
  return pathParts;
}
function isResourceValid(resource, err) {
  if (resource.id) {
    if (typeof resource.id !== "string") {
      err.message = "Id must be a string.";
      return false;
    }
    if (resource.id.indexOf("/") !== -1 || resource.id.indexOf("\\") !== -1 || resource.id.indexOf("?") !== -1 || resource.id.indexOf("#") !== -1) {
      err.message = "Id contains illegal chars.";
      return false;
    }
    if (resource.id[resource.id.length - 1] === " ") {
      err.message = "Id ends with a space.";
      return false;
    }
  }
  return true;
}
function isItemResourceValid(resource, err) {
  if (resource.id) {
    if (typeof resource.id !== "string") {
      err.message = "Id must be a string.";
      return false;
    }
    if (resource.id.indexOf("/") !== -1 || resource.id.indexOf("\\") !== -1 || resource.id.indexOf("#") !== -1) {
      err.message = "Id contains illegal chars.";
      return false;
    }
  }
  return true;
}
function getIdFromLink(resourceLink) {
  resourceLink = trimSlashes(resourceLink);
  return resourceLink;
}
function getPathFromLink(resourceLink, resourceType) {
  resourceLink = trimSlashes(resourceLink);
  if (resourceType) {
    return "/" + encodeURI(resourceLink) + "/" + resourceType;
  } else {
    return "/" + encodeURI(resourceLink);
  }
}
function isStringNullOrEmpty(inputString) {
  return !inputString || /^\s*$/.test(inputString);
}
function trimSlashFromLeftAndRight(inputString) {
  if (typeof inputString !== "string") {
    throw new Error("invalid input: input is not string");
  }
  return inputString.replace(trimLeftSlashes, "").replace(trimRightSlashes, "");
}
function validateResourceId(resourceId) {
  if (typeof resourceId !== "string" || isStringNullOrEmpty(resourceId)) {
    throw new Error("Resource ID must be a string and cannot be undefined, null or empty");
  }
  if (illegalResourceIdCharacters.test(resourceId)) {
    throw new Error("Illegal characters ['/', '\\', '#', '?'] cannot be used in Resource ID");
  }
  return true;
}
function validateItemResourceId(resourceId) {
  if (typeof resourceId !== "string" || isStringNullOrEmpty(resourceId)) {
    throw new Error("Resource ID must be a string and cannot be undefined, null or empty");
  }
  if (illegalItemResourceIdCharacters.test(resourceId)) {
    throw new Error("Illegal characters ['/', '\\', '#'] cannot be used in Resource ID");
  }
  return true;
}
function getResourceIdFromPath(resourcePath) {
  if (!resourcePath || typeof resourcePath !== "string") {
    return null;
  }
  const trimmedPath = trimSlashFromLeftAndRight(resourcePath);
  const pathSegments = trimmedPath.split("/");
  if (pathSegments.length % 2 !== 0) {
    return null;
  }
  return pathSegments[pathSegments.length - 1];
}
function parseConnectionString(connectionString) {
  const keyValueStrings = connectionString.split(";");
  const { AccountEndpoint, AccountKey } = keyValueStrings.reduce((connectionObject, keyValueString) => {
    const [key, ...value] = keyValueString.split("=");
    connectionObject[key] = value.join("=");
    return connectionObject;
  }, {});
  if (!AccountEndpoint || !AccountKey) {
    throw new Error("Could not parse the provided connection string");
  }
  return {
    endpoint: AccountEndpoint,
    key: AccountKey
  };
}

// node_modules/@azure/cosmos/dist-esm/src/common/statusCodes.js
var StatusCodes = {
  // Success
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NoContent: 204,
  NotModified: 304,
  // Client error
  BadRequest: 400,
  Unauthorized: 401,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  PreconditionFailed: 412,
  RequestEntityTooLarge: 413,
  TooManyRequests: 429,
  RetryWith: 449,
  // Server Error
  InternalServerError: 500,
  ServiceUnavailable: 503,
  // System codes
  ENOTFOUND: "ENOTFOUND",
  // Operation pause and cancel. These are FAKE status codes for QOS logging purpose only.
  OperationPaused: 1200,
  OperationCancelled: 1201
};
var SubStatusCodes = {
  Unknown: 0,
  // 400: Bad Request Substatus
  CrossPartitionQueryNotServable: 1004,
  // 410: StatusCodeType_Gone: substatus
  PartitionKeyRangeGone: 1002,
  CompletingSplit: 1007,
  // 404: NotFound Substatus
  ReadSessionNotAvailable: 1002,
  // 403: Forbidden Substatus
  WriteForbidden: 3,
  DatabaseAccountNotFound: 1008
};

// node_modules/@azure/cosmos/dist-esm/src/common/uriFactory.js
function createDatabaseUri(databaseId) {
  databaseId = trimSlashFromLeftAndRight(databaseId);
  validateResourceId(databaseId);
  return Constants.Path.DatabasesPathSegment + "/" + databaseId;
}
function createDocumentCollectionUri(databaseId, collectionId) {
  collectionId = trimSlashFromLeftAndRight(collectionId);
  validateResourceId(collectionId);
  return createDatabaseUri(databaseId) + "/" + Constants.Path.CollectionsPathSegment + "/" + collectionId;
}
function createUserUri(databaseId, userId) {
  userId = trimSlashFromLeftAndRight(userId);
  validateResourceId(userId);
  return createDatabaseUri(databaseId) + "/" + Constants.Path.UsersPathSegment + "/" + userId;
}
function createDocumentUri(databaseId, collectionId, documentId) {
  documentId = trimSlashFromLeftAndRight(documentId);
  validateItemResourceId(documentId);
  return createDocumentCollectionUri(databaseId, collectionId) + "/" + Constants.Path.DocumentsPathSegment + "/" + documentId;
}
function createPermissionUri(databaseId, userId, permissionId) {
  permissionId = trimSlashFromLeftAndRight(permissionId);
  validateResourceId(permissionId);
  return createUserUri(databaseId, userId) + "/" + Constants.Path.PermissionsPathSegment + "/" + permissionId;
}
function createStoredProcedureUri(databaseId, collectionId, storedProcedureId) {
  storedProcedureId = trimSlashFromLeftAndRight(storedProcedureId);
  validateResourceId(storedProcedureId);
  return createDocumentCollectionUri(databaseId, collectionId) + "/" + Constants.Path.StoredProceduresPathSegment + "/" + storedProcedureId;
}
function createTriggerUri(databaseId, collectionId, triggerId) {
  triggerId = trimSlashFromLeftAndRight(triggerId);
  validateResourceId(triggerId);
  return createDocumentCollectionUri(databaseId, collectionId) + "/" + Constants.Path.TriggersPathSegment + "/" + triggerId;
}
function createUserDefinedFunctionUri(databaseId, collectionId, udfId) {
  udfId = trimSlashFromLeftAndRight(udfId);
  validateResourceId(udfId);
  return createDocumentCollectionUri(databaseId, collectionId) + "/" + Constants.Path.UserDefinedFunctionsPathSegment + "/" + udfId;
}

// node_modules/@azure/cosmos/dist-esm/src/utils/encode.js
function encodeUTF8(str) {
  const bytes = new Uint8Array(str.length);
  for (let i = 0; i < str.length; i++) {
    bytes[i] = str.charCodeAt(i);
  }
  return bytes;
}
function encodeBase64(value) {
  if ("function" !== typeof btoa) {
    throw new Error("Your browser environment is missing the global `btoa` function");
  }
  let binary = "";
  const bytes = new Uint8Array(value);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

// node_modules/@azure/cosmos/dist-esm/src/utils/atob.browser.js
var safeatob;
var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64re = /^(?:[A-Za-z\d+/]{4})*?(?:[A-Za-z\d+/]{2}(?:==)?|[A-Za-z\d+/]{3}=?)?$/;
if ("function" !== typeof atob) {
  safeatob = (str) => {
    str = String(str).replace(/[\t\n\f\r ]+/g, "");
    if (!b64re.test(str)) {
      throw new TypeError("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.");
    }
    str += "==".slice(2 - (str.length & 3));
    let bitmap;
    let result = "";
    let r1;
    let r2;
    let i = 0;
    for (; i < str.length; ) {
      bitmap = b64.indexOf(str.charAt(i++)) << 18 | b64.indexOf(str.charAt(i++)) << 12 | (r1 = b64.indexOf(str.charAt(i++))) << 6 | (r2 = b64.indexOf(str.charAt(i++)));
      result += r1 === 64 ? String.fromCharCode(bitmap >> 16 & 255) : r2 === 64 ? String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255) : String.fromCharCode(bitmap >> 16 & 255, bitmap >> 8 & 255, bitmap & 255);
    }
    return result;
  };
} else {
  safeatob = atob;
}
var atob_browser_default = safeatob;

// node_modules/@azure/cosmos/dist-esm/src/utils/globalCrypto.js
var globalRef = typeof self === "undefined" ? window : self;
if (!globalRef) {
  throw new Error("Could not find global");
}
var globalCrypto = globalRef.crypto || globalRef.msCrypto;
if (!globalCrypto || !globalCrypto.subtle) {
  throw new Error("Browser does not support cryptography functions");
}

// node_modules/@azure/cosmos/dist-esm/src/utils/hmac.browser.js
async function hmac(key, message) {
  const importParams = { name: "HMAC", hash: { name: "SHA-256" } };
  const encodedMessage = new Uint8Array([...unescape(encodeURIComponent(message))].map((c) => c.charCodeAt(0)));
  const encodedKey = encodeUTF8(atob_browser_default(key));
  const cryptoKey = await globalCrypto.subtle.importKey("raw", encodedKey, importParams, false, [
    "sign"
  ]);
  const signature2 = await globalCrypto.subtle.sign(importParams, cryptoKey, encodedMessage);
  return encodeBase64(signature2);
}

// node_modules/@azure/cosmos/dist-esm/src/utils/headers.js
async function generateHeaders(masterKey, method, resourceType = ResourceType.none, resourceId = "", date = /* @__PURE__ */ new Date()) {
  if (masterKey.startsWith("type=sas&")) {
    return {
      [Constants.HttpHeaders.Authorization]: encodeURIComponent(masterKey),
      [Constants.HttpHeaders.XDate]: date.toUTCString()
    };
  }
  const sig = await signature(masterKey, method, resourceType, resourceId, date);
  return {
    [Constants.HttpHeaders.Authorization]: sig,
    [Constants.HttpHeaders.XDate]: date.toUTCString()
  };
}
async function signature(masterKey, method, resourceType, resourceId = "", date = /* @__PURE__ */ new Date()) {
  const type = "master";
  const version = "1.0";
  const text = method.toLowerCase() + "\n" + resourceType.toLowerCase() + "\n" + resourceId + "\n" + date.toUTCString().toLowerCase() + "\n\n";
  const signed = await hmac(masterKey, text);
  return encodeURIComponent("type=" + type + "&ver=" + version + "&sig=" + signed);
}

// node_modules/@azure/cosmos/dist-esm/src/auth.js
async function setAuthorizationHeader(clientOptions, verb, path, resourceId, resourceType, headers) {
  if (clientOptions.permissionFeed) {
    clientOptions.resourceTokens = {};
    for (const permission of clientOptions.permissionFeed) {
      const id = getResourceIdFromPath(permission.resource);
      if (!id) {
        throw new Error(`authorization error: ${id}                           is an invalid resourceId in permissionFeed`);
      }
      clientOptions.resourceTokens[id] = permission._token;
    }
  }
  if (clientOptions.key) {
    await setAuthorizationTokenHeaderUsingMasterKey(verb, resourceId, resourceType, headers, clientOptions.key);
  } else if (clientOptions.resourceTokens) {
    headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(getAuthorizationTokenUsingResourceTokens(clientOptions.resourceTokens, path, resourceId));
  } else if (clientOptions.tokenProvider) {
    headers[Constants.HttpHeaders.Authorization] = encodeURIComponent(await clientOptions.tokenProvider({ verb, path, resourceId, resourceType, headers }));
  }
}
async function setAuthorizationTokenHeaderUsingMasterKey(verb, resourceId, resourceType, headers, masterKey) {
  if (resourceType === ResourceType.offer) {
    resourceId = resourceId && resourceId.toLowerCase();
  }
  headers = Object.assign(headers, await generateHeaders(masterKey, verb, resourceType, resourceId));
}
function getAuthorizationTokenUsingResourceTokens(resourceTokens, path, resourceId) {
  if (resourceTokens && Object.keys(resourceTokens).length > 0) {
    if (!path && !resourceId) {
      return resourceTokens[Object.keys(resourceTokens)[0]];
    }
    if (resourceId && resourceTokens[resourceId]) {
      return resourceTokens[resourceId];
    }
    if (!path || path.length < 4) {
      return null;
    }
    path = trimSlashFromLeftAndRight(path);
    const pathSegments = path && path.split("/") || [];
    if (pathSegments.length === 6) {
      const containerPath = pathSegments.slice(0, 4).map(decodeURIComponent).join("/");
      if (resourceTokens[containerPath]) {
        return resourceTokens[containerPath];
      }
    }
    let index = pathSegments.length % 2 === 0 ? pathSegments.length - 1 : pathSegments.length - 2;
    for (; index > 0; index -= 2) {
      const id = decodeURI(pathSegments[index]);
      if (resourceTokens[id]) {
        return resourceTokens[id];
      }
    }
  }
  return null;
}

// node_modules/@azure/cosmos/dist-esm/src/documents/ConnectionMode.js
var ConnectionMode;
(function(ConnectionMode2) {
  ConnectionMode2[ConnectionMode2["Gateway"] = 0] = "Gateway";
})(ConnectionMode || (ConnectionMode = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/ConnectionPolicy.js
var defaultConnectionPolicy = Object.freeze({
  connectionMode: ConnectionMode.Gateway,
  requestTimeout: 6e4,
  enableEndpointDiscovery: true,
  preferredLocations: [],
  retryOptions: {
    maxRetryAttemptCount: 9,
    fixedRetryIntervalInMilliseconds: 0,
    maxWaitTimeInSeconds: 30
  },
  useMultipleWriteLocations: true,
  endpointRefreshRateInMs: 3e5,
  enableBackgroundEndpointRefreshing: true
});

// node_modules/@azure/cosmos/dist-esm/src/documents/ConsistencyLevel.js
var ConsistencyLevel;
(function(ConsistencyLevel2) {
  ConsistencyLevel2["Strong"] = "Strong";
  ConsistencyLevel2["BoundedStaleness"] = "BoundedStaleness";
  ConsistencyLevel2["Session"] = "Session";
  ConsistencyLevel2["Eventual"] = "Eventual";
  ConsistencyLevel2["ConsistentPrefix"] = "ConsistentPrefix";
})(ConsistencyLevel || (ConsistencyLevel = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/DatabaseAccount.js
var DatabaseAccount = class {
  /**
   * The self-link for Databases in the databaseAccount.
   * @deprecated Use `databasesLink`
   */
  get DatabasesLink() {
    return this.databasesLink;
  }
  /**
   * The self-link for Media in the databaseAccount.
   * @deprecated Use `mediaLink`
   */
  get MediaLink() {
    return this.mediaLink;
  }
  /**
   * Attachment content (media) storage quota in MBs ( Retrieved from gateway ).
   * @deprecated use `maxMediaStorageUsageInMB`
   */
  get MaxMediaStorageUsageInMB() {
    return this.maxMediaStorageUsageInMB;
  }
  /**
   * Current attachment content (media) usage in MBs (Retrieved from gateway )
   *
   * Value is returned from cached information updated periodically and is not guaranteed
   * to be real time.
   *
   * @deprecated use `currentMediaStorageUsageInMB`
   */
  get CurrentMediaStorageUsageInMB() {
    return this.currentMediaStorageUsageInMB;
  }
  /**
   * Gets the UserConsistencyPolicy settings.
   * @deprecated use `consistencyPolicy`
   */
  get ConsistencyPolicy() {
    return this.consistencyPolicy;
  }
  // TODO: body - any
  constructor(body, headers) {
    this.writableLocations = [];
    this.readableLocations = [];
    this.databasesLink = "/dbs/";
    this.mediaLink = "/media/";
    this.maxMediaStorageUsageInMB = headers[Constants.HttpHeaders.MaxMediaStorageUsageInMB];
    this.currentMediaStorageUsageInMB = headers[Constants.HttpHeaders.CurrentMediaStorageUsageInMB];
    this.consistencyPolicy = body.userConsistencyPolicy ? body.userConsistencyPolicy.defaultConsistencyLevel : ConsistencyLevel.Session;
    if (body[Constants.WritableLocations] && body.id !== "localhost") {
      this.writableLocations = body[Constants.WritableLocations];
    }
    if (body[Constants.ReadableLocations] && body.id !== "localhost") {
      this.readableLocations = body[Constants.ReadableLocations];
    }
    if (body[Constants.ENABLE_MULTIPLE_WRITABLE_LOCATIONS]) {
      this.enableMultipleWritableLocations = body[Constants.ENABLE_MULTIPLE_WRITABLE_LOCATIONS] === true || body[Constants.ENABLE_MULTIPLE_WRITABLE_LOCATIONS] === "true";
    }
  }
};

// node_modules/@azure/cosmos/dist-esm/src/documents/DataType.js
var DataType;
(function(DataType2) {
  DataType2["Number"] = "Number";
  DataType2["String"] = "String";
  DataType2["Point"] = "Point";
  DataType2["LineString"] = "LineString";
  DataType2["Polygon"] = "Polygon";
  DataType2["MultiPolygon"] = "MultiPolygon";
})(DataType || (DataType = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/IndexingMode.js
var IndexingMode;
(function(IndexingMode2) {
  IndexingMode2["consistent"] = "consistent";
  IndexingMode2["lazy"] = "lazy";
  IndexingMode2["none"] = "none";
})(IndexingMode || (IndexingMode = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/IndexingPolicy.js
var SpatialType;
(function(SpatialType2) {
  SpatialType2["LineString"] = "LineString";
  SpatialType2["MultiPolygon"] = "MultiPolygon";
  SpatialType2["Point"] = "Point";
  SpatialType2["Polygon"] = "Polygon";
})(SpatialType || (SpatialType = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/IndexKind.js
var IndexKind;
(function(IndexKind2) {
  IndexKind2["Range"] = "Range";
  IndexKind2["Spatial"] = "Spatial";
})(IndexKind || (IndexKind = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/PartitionKeyInternal.js
var NonePartitionKeyLiteral = {};
var NullPartitionKeyLiteral = null;
function convertToInternalPartitionKey(partitionKey) {
  if (Array.isArray(partitionKey)) {
    return partitionKey.map((key) => key === void 0 ? NonePartitionKeyLiteral : key);
  } else
    return [partitionKey];
}

// node_modules/@azure/cosmos/dist-esm/src/documents/PartitionKey.js
var PartitionKeyBuilder = class {
  constructor() {
    this.values = [];
  }
  addValue(value) {
    this.values.push(value);
    return this;
  }
  addNullValue() {
    this.values.push(NullPartitionKeyLiteral);
    return this;
  }
  addNoneValue() {
    this.values.push(NonePartitionKeyLiteral);
    return this;
  }
  build() {
    return [...this.values];
  }
};

// node_modules/@azure/cosmos/dist-esm/src/documents/PartitionKeyDefinitionVersion.js
var PartitionKeyDefinitionVersion;
(function(PartitionKeyDefinitionVersion2) {
  PartitionKeyDefinitionVersion2[PartitionKeyDefinitionVersion2["V1"] = 1] = "V1";
  PartitionKeyDefinitionVersion2[PartitionKeyDefinitionVersion2["V2"] = 2] = "V2";
})(PartitionKeyDefinitionVersion || (PartitionKeyDefinitionVersion = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/PartitionKeyKind.js
var PartitionKeyKind;
(function(PartitionKeyKind2) {
  PartitionKeyKind2["Hash"] = "Hash";
  PartitionKeyKind2["MultiHash"] = "MultiHash";
})(PartitionKeyKind || (PartitionKeyKind = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/PermissionMode.js
var PermissionMode;
(function(PermissionMode2) {
  PermissionMode2["None"] = "none";
  PermissionMode2["Read"] = "read";
  PermissionMode2["All"] = "all";
})(PermissionMode || (PermissionMode = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/PriorityLevel.js
var PriorityLevel;
(function(PriorityLevel2) {
  PriorityLevel2["High"] = "High";
  PriorityLevel2["Low"] = "Low";
})(PriorityLevel || (PriorityLevel = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/TriggerOperation.js
var TriggerOperation;
(function(TriggerOperation2) {
  TriggerOperation2["All"] = "all";
  TriggerOperation2["Create"] = "create";
  TriggerOperation2["Update"] = "update";
  TriggerOperation2["Delete"] = "delete";
  TriggerOperation2["Replace"] = "replace";
})(TriggerOperation || (TriggerOperation = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/TriggerType.js
var TriggerType;
(function(TriggerType2) {
  TriggerType2["Pre"] = "pre";
  TriggerType2["Post"] = "post";
})(TriggerType || (TriggerType = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/UserDefinedFunctionType.js
var UserDefinedFunctionType;
(function(UserDefinedFunctionType2) {
  UserDefinedFunctionType2["Javascript"] = "Javascript";
})(UserDefinedFunctionType || (UserDefinedFunctionType = {}));

// node_modules/@azure/cosmos/dist-esm/src/documents/GeospatialType.js
var GeospatialType;
(function(GeospatialType2) {
  GeospatialType2["Geography"] = "Geography";
  GeospatialType2["Geometry"] = "Geometry";
})(GeospatialType || (GeospatialType = {}));

// node_modules/@azure/cosmos/dist-esm/src/extractPartitionKey.js
var logger = createClientLogger("extractPartitionKey");
function extractPartitionKeys(document, partitionKeyDefinition) {
  if (partitionKeyDefinition && partitionKeyDefinition.paths && partitionKeyDefinition.paths.length > 0) {
    if (partitionKeyDefinition.systemKey === true) {
      return [];
    }
    if (partitionKeyDefinition.paths.length === 1 && partitionKeyDefinition.paths[0] === DEFAULT_PARTITION_KEY_PATH) {
      return [extractPartitionKey(DEFAULT_PARTITION_KEY_PATH, document)];
    }
    const partitionKeys = [];
    partitionKeyDefinition.paths.forEach((path) => {
      const obj = extractPartitionKey(path, document);
      if (obj === void 0) {
        logger.warning("Unsupported PartitionKey found.");
        return void 0;
      }
      partitionKeys.push(obj);
    });
    return partitionKeys;
  }
  logger.error("Unexpected Partition Key Definition Found.");
  return void 0;
}
function extractPartitionKey(path, obj) {
  const pathParts = parsePath(path);
  for (const part of pathParts) {
    if (typeof obj === "object" && obj !== null && part in obj) {
      obj = obj[part];
    } else {
      obj = void 0;
      break;
    }
  }
  if (typeof obj === "string" || typeof obj === "number" || typeof obj === "boolean") {
    return obj;
  } else if (obj === NullPartitionKeyLiteral) {
    return NullPartitionKeyLiteral;
  } else if (obj === void 0 || JSON.stringify(obj) === JSON.stringify(NonePartitionKeyLiteral)) {
    return NonePartitionKeyLiteral;
  }
  return void 0;
}
function undefinedPartitionKey(partitionKeyDefinition) {
  if (partitionKeyDefinition.systemKey === true) {
    return [];
  } else {
    return partitionKeyDefinition.paths.map(() => NonePartitionKeyLiteral);
  }
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid4) {
  return typeof uuid4 === "string" && regex_default.test(uuid4);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
var i;
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid4 = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate_default(uuid4)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid4;
}
var stringify_default = stringify;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid4) {
  if (!validate_default(uuid4)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid4.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid4.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid4.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid4.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid4.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35_default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (namespace.length !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return stringify_default(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35_default("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify_default(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35_default("v5", 80, sha1_default);

// node_modules/@azure/cosmos/dist-esm/src/utils/typeChecks.js
function assertNotUndefined(value, msg) {
  if (value !== void 0) {
    return value;
  }
  throw new Error(msg || "Unexpected 'undefined' value encountered");
}
function isPrimitivePartitionKeyValue(value) {
  return isWellDefinedPartitionKeyValue(value) || isNonePartitionKeyValue(value) || isNullPartitionKeyValue(value);
}
function isWellDefinedPartitionKeyValue(value) {
  return typeof value === "string" || typeof value === "boolean" || typeof value === "number";
}
function isNonePartitionKeyValue(value) {
  return value !== void 0 && JSON.stringify(value) === JSON.stringify(NonePartitionKeyLiteral);
}
function isNullPartitionKeyValue(value) {
  return value === NullPartitionKeyLiteral;
}
function isPartitionKey(partitionKey) {
  return isPrimitivePartitionKeyValue(partitionKey) || Array.isArray(partitionKey);
}

// node_modules/@azure/cosmos/dist-esm/src/common/logger.js
var defaultLogger = createClientLogger("cosmosdb");

// node_modules/@azure/cosmos/dist-esm/src/request/request.js
function javaScriptFriendlyJSONStringify(s) {
  return JSON.stringify(s).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
}
function bodyFromData(data) {
  if (typeof data === "object") {
    return javaScriptFriendlyJSONStringify(data);
  }
  return data;
}
var JsonContentType = "application/json";
async function getHeaders({ clientOptions, defaultHeaders, verb, path, resourceId, resourceType, options = {}, partitionKeyRangeId, useMultipleWriteLocations, partitionKey }) {
  const headers = Object.assign({ [Constants.HttpHeaders.ResponseContinuationTokenLimitInKB]: 1, [Constants.HttpHeaders.EnableCrossPartitionQuery]: true }, defaultHeaders);
  if (useMultipleWriteLocations) {
    headers[Constants.HttpHeaders.ALLOW_MULTIPLE_WRITES] = true;
  }
  if (options.continuationTokenLimitInKB) {
    headers[Constants.HttpHeaders.ResponseContinuationTokenLimitInKB] = options.continuationTokenLimitInKB;
  }
  if (options.continuationToken) {
    headers[Constants.HttpHeaders.Continuation] = options.continuationToken;
  } else if (options.continuation) {
    headers[Constants.HttpHeaders.Continuation] = options.continuation;
  }
  if (options.preTriggerInclude) {
    headers[Constants.HttpHeaders.PreTriggerInclude] = options.preTriggerInclude.constructor === Array ? options.preTriggerInclude.join(",") : options.preTriggerInclude;
  }
  if (options.postTriggerInclude) {
    headers[Constants.HttpHeaders.PostTriggerInclude] = options.postTriggerInclude.constructor === Array ? options.postTriggerInclude.join(",") : options.postTriggerInclude;
  }
  if (options.offerType) {
    headers[Constants.HttpHeaders.OfferType] = options.offerType;
  }
  if (options.offerThroughput) {
    headers[Constants.HttpHeaders.OfferThroughput] = options.offerThroughput;
  }
  if (options.maxItemCount) {
    headers[Constants.HttpHeaders.PageSize] = options.maxItemCount;
  }
  if (options.accessCondition) {
    if (options.accessCondition.type === "IfMatch") {
      headers[Constants.HttpHeaders.IfMatch] = options.accessCondition.condition;
    } else {
      headers[Constants.HttpHeaders.IfNoneMatch] = options.accessCondition.condition;
    }
  }
  if (options.useIncrementalFeed) {
    headers[Constants.HttpHeaders.A_IM] = "Incremental Feed";
  }
  if (options.indexingDirective) {
    headers[Constants.HttpHeaders.IndexingDirective] = options.indexingDirective;
  }
  if (options.consistencyLevel) {
    headers[Constants.HttpHeaders.ConsistencyLevel] = options.consistencyLevel;
  }
  if (options.priorityLevel) {
    headers[Constants.HttpHeaders.PriorityLevel] = options.priorityLevel;
  }
  if (options.maxIntegratedCacheStalenessInMs && resourceType === ResourceType.item) {
    if (typeof options.maxIntegratedCacheStalenessInMs === "number") {
      headers[Constants.HttpHeaders.DedicatedGatewayPerRequestCacheStaleness] = options.maxIntegratedCacheStalenessInMs.toString();
    } else {
      defaultLogger.error(`RangeError: maxIntegratedCacheStalenessInMs "${options.maxIntegratedCacheStalenessInMs}" is not a valid parameter.`);
      headers[Constants.HttpHeaders.DedicatedGatewayPerRequestCacheStaleness] = "null";
    }
  }
  if (options.resourceTokenExpirySeconds) {
    headers[Constants.HttpHeaders.ResourceTokenExpiry] = options.resourceTokenExpirySeconds;
  }
  if (options.sessionToken) {
    headers[Constants.HttpHeaders.SessionToken] = options.sessionToken;
  }
  if (options.enableScanInQuery) {
    headers[Constants.HttpHeaders.EnableScanInQuery] = options.enableScanInQuery;
  }
  if (options.populateQuotaInfo) {
    headers[Constants.HttpHeaders.PopulateQuotaInfo] = options.populateQuotaInfo;
  }
  if (options.populateQueryMetrics) {
    headers[Constants.HttpHeaders.PopulateQueryMetrics] = options.populateQueryMetrics;
  }
  if (options.maxDegreeOfParallelism !== void 0) {
    headers[Constants.HttpHeaders.ParallelizeCrossPartitionQuery] = true;
  }
  if (options.populateQuotaInfo) {
    headers[Constants.HttpHeaders.PopulateQuotaInfo] = true;
  }
  if (partitionKey !== void 0 && !headers[Constants.HttpHeaders.PartitionKey]) {
    headers[Constants.HttpHeaders.PartitionKey] = jsonStringifyAndEscapeNonASCII(partitionKey);
  }
  if (clientOptions.key || clientOptions.tokenProvider) {
    headers[Constants.HttpHeaders.XDate] = (/* @__PURE__ */ new Date()).toUTCString();
  }
  if (verb === HTTPMethod.post || verb === HTTPMethod.put) {
    if (!headers[Constants.HttpHeaders.ContentType]) {
      headers[Constants.HttpHeaders.ContentType] = JsonContentType;
    }
  }
  if (!headers[Constants.HttpHeaders.Accept]) {
    headers[Constants.HttpHeaders.Accept] = JsonContentType;
  }
  if (partitionKeyRangeId !== void 0) {
    headers[Constants.HttpHeaders.PartitionKeyRangeID] = partitionKeyRangeId;
  }
  if (options.enableScriptLogging) {
    headers[Constants.HttpHeaders.EnableScriptLogging] = options.enableScriptLogging;
  }
  if (options.disableRUPerMinuteUsage) {
    headers[Constants.HttpHeaders.DisableRUPerMinuteUsage] = true;
  }
  if (options.populateIndexMetrics) {
    headers[Constants.HttpHeaders.PopulateIndexMetrics] = options.populateIndexMetrics;
  }
  if (clientOptions.key || clientOptions.resourceTokens || clientOptions.tokenProvider || clientOptions.permissionFeed) {
    await setAuthorizationHeader(clientOptions, verb, path, resourceId, resourceType, headers);
  }
  return headers;
}

// node_modules/@azure/cosmos/dist-esm/src/utils/batch.js
var uuid = v4_default;
function isKeyInRange(min, max2, key) {
  const isAfterMinInclusive = key.localeCompare(min) >= 0;
  const isBeforeMax = key.localeCompare(max2) < 0;
  return isAfterMinInclusive && isBeforeMax;
}
var BulkOperationType = {
  Create: "Create",
  Upsert: "Upsert",
  Read: "Read",
  Delete: "Delete",
  Replace: "Replace",
  Patch: "Patch"
};
function prepareOperations(operationInput, definition, options = {}) {
  populateIdsIfNeeded(operationInput, options);
  let partitionKey;
  if (Object.prototype.hasOwnProperty.call(operationInput, "partitionKey")) {
    if (operationInput.partitionKey === void 0) {
      partitionKey = definition.paths.map(() => NonePartitionKeyLiteral);
    } else {
      partitionKey = convertToInternalPartitionKey(operationInput.partitionKey);
    }
  } else {
    switch (operationInput.operationType) {
      case BulkOperationType.Create:
      case BulkOperationType.Replace:
      case BulkOperationType.Upsert:
        partitionKey = assertNotUndefined(extractPartitionKeys(operationInput.resourceBody, definition), "Unexpected undefined Partition Key Found.");
        break;
      case BulkOperationType.Read:
      case BulkOperationType.Delete:
      case BulkOperationType.Patch:
        partitionKey = definition.paths.map(() => NonePartitionKeyLiteral);
    }
  }
  return {
    operation: Object.assign(Object.assign({}, operationInput), { partitionKey: JSON.stringify(partitionKey) }),
    partitionKey
  };
}
function populateIdsIfNeeded(operationInput, options) {
  if (operationInput.operationType === BulkOperationType.Create || operationInput.operationType === BulkOperationType.Upsert) {
    if ((operationInput.resourceBody.id === void 0 || operationInput.resourceBody.id === "") && !options.disableAutomaticIdGeneration) {
      operationInput.resourceBody.id = uuid();
    }
  }
}
function splitBatchBasedOnBodySize(originalBatch) {
  if ((originalBatch === null || originalBatch === void 0 ? void 0 : originalBatch.operations) === void 0 || originalBatch.operations.length < 1)
    return [];
  let currentBatchSize = calculateObjectSizeInBytes(originalBatch.operations[0]);
  let currentBatch = Object.assign(Object.assign({}, originalBatch), { operations: [originalBatch.operations[0]], indexes: [originalBatch.indexes[0]] });
  const processedBatches = [];
  processedBatches.push(currentBatch);
  for (let index = 1; index < originalBatch.operations.length; index++) {
    const operation = originalBatch.operations[index];
    const currentOpSize = calculateObjectSizeInBytes(operation);
    if (currentBatchSize + currentOpSize > Constants.DefaultMaxBulkRequestBodySizeInBytes) {
      currentBatch = Object.assign(Object.assign({}, originalBatch), { operations: [], indexes: [] });
      processedBatches.push(currentBatch);
      currentBatchSize = 0;
    }
    currentBatch.operations.push(operation);
    currentBatch.indexes.push(originalBatch.indexes[index]);
    currentBatchSize += currentOpSize;
  }
  return processedBatches;
}
function calculateObjectSizeInBytes(obj) {
  return new TextEncoder().encode(bodyFromData(obj)).length;
}
function decorateBatchOperation(operation, options = {}) {
  if (operation.operationType === BulkOperationType.Create || operation.operationType === BulkOperationType.Upsert) {
    if ((operation.resourceBody.id === void 0 || operation.resourceBody.id === "") && !options.disableAutomaticIdGeneration) {
      operation.resourceBody.id = uuid();
    }
  }
  return operation;
}

// node_modules/@azure/cosmos/dist-esm/src/utils/patch.js
var PatchOperationType = {
  add: "add",
  replace: "replace",
  remove: "remove",
  set: "set",
  incr: "incr"
};

// node_modules/@azure/cosmos/dist-esm/src/request/ErrorResponse.js
var ErrorResponse = class extends Error {
};

// node_modules/@azure/cosmos/dist-esm/src/request/ResourceResponse.js
var ResourceResponse = class {
  constructor(resource, headers, statusCode, diagnostics, substatus) {
    this.resource = resource;
    this.headers = headers;
    this.statusCode = statusCode;
    this.diagnostics = diagnostics;
    this.substatus = substatus;
  }
  get requestCharge() {
    return Number(this.headers[Constants.HttpHeaders.RequestCharge]) || 0;
  }
  get activityId() {
    return this.headers[Constants.HttpHeaders.ActivityId];
  }
  get etag() {
    return this.headers[Constants.HttpHeaders.ETag];
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryMetrics/clientSideMetrics.js
var ClientSideMetrics = class _ClientSideMetrics {
  constructor(requestCharge) {
    this.requestCharge = requestCharge;
  }
  /**
   * Adds one or more ClientSideMetrics to a copy of this instance and returns the result.
   */
  add(...clientSideMetricsArray) {
    let requestCharge = this.requestCharge;
    for (const clientSideMetrics of clientSideMetricsArray) {
      if (clientSideMetrics == null) {
        throw new Error("clientSideMetrics has null or undefined item(s)");
      }
      requestCharge += clientSideMetrics.requestCharge;
    }
    return new _ClientSideMetrics(requestCharge);
  }
  static createFromArray(...clientSideMetricsArray) {
    if (clientSideMetricsArray == null) {
      throw new Error("clientSideMetricsArray is null or undefined item(s)");
    }
    return this.zero.add(...clientSideMetricsArray);
  }
};
ClientSideMetrics.zero = new ClientSideMetrics(0);

// node_modules/@azure/cosmos/dist-esm/src/queryMetrics/queryMetricsConstants.js
var queryMetricsConstants_default = {
  // QueryMetrics
  RetrievedDocumentCount: "retrievedDocumentCount",
  RetrievedDocumentSize: "retrievedDocumentSize",
  OutputDocumentCount: "outputDocumentCount",
  OutputDocumentSize: "outputDocumentSize",
  IndexHitRatio: "indexUtilizationRatio",
  IndexHitDocumentCount: "indexHitDocumentCount",
  TotalQueryExecutionTimeInMs: "totalExecutionTimeInMs",
  // QueryPreparationTimes
  QueryCompileTimeInMs: "queryCompileTimeInMs",
  LogicalPlanBuildTimeInMs: "queryLogicalPlanBuildTimeInMs",
  PhysicalPlanBuildTimeInMs: "queryPhysicalPlanBuildTimeInMs",
  QueryOptimizationTimeInMs: "queryOptimizationTimeInMs",
  // QueryTimes
  IndexLookupTimeInMs: "indexLookupTimeInMs",
  DocumentLoadTimeInMs: "documentLoadTimeInMs",
  VMExecutionTimeInMs: "VMExecutionTimeInMs",
  DocumentWriteTimeInMs: "writeOutputTimeInMs",
  // RuntimeExecutionTimes
  QueryEngineTimes: "queryEngineTimes",
  SystemFunctionExecuteTimeInMs: "systemFunctionExecuteTimeInMs",
  UserDefinedFunctionExecutionTimeInMs: "userFunctionExecuteTimeInMs",
  // QueryMetrics Text
  RetrievedDocumentCountText: "Retrieved Document Count",
  RetrievedDocumentSizeText: "Retrieved Document Size",
  OutputDocumentCountText: "Output Document Count",
  OutputDocumentSizeText: "Output Document Size",
  IndexUtilizationText: "Index Utilization",
  TotalQueryExecutionTimeText: "Total Query Execution Time",
  // QueryPreparationTimes Text
  QueryPreparationTimesText: "Query Preparation Times",
  QueryCompileTimeText: "Query Compilation Time",
  LogicalPlanBuildTimeText: "Logical Plan Build Time",
  PhysicalPlanBuildTimeText: "Physical Plan Build Time",
  QueryOptimizationTimeText: "Query Optimization Time",
  // QueryTimes Text
  QueryEngineTimesText: "Query Engine Times",
  IndexLookupTimeText: "Index Lookup Time",
  DocumentLoadTimeText: "Document Load Time",
  WriteOutputTimeText: "Document Write Time",
  // RuntimeExecutionTimes Text
  RuntimeExecutionTimesText: "Runtime Execution Times",
  TotalExecutionTimeText: "Query Engine Execution Time",
  SystemFunctionExecuteTimeText: "System Function Execution Time",
  UserDefinedFunctionExecutionTimeText: "User-defined Function Execution Time",
  // ClientSideQueryMetrics Text
  ClientSideQueryMetricsText: "Client Side Metrics",
  RetriesText: "Retry Count",
  RequestChargeText: "Request Charge",
  FetchExecutionRangesText: "Partition Execution Timeline",
  SchedulingMetricsText: "Scheduling Metrics"
};

// node_modules/@azure/cosmos/dist-esm/src/queryMetrics/timeSpan.js
var ticksPerMillisecond = 1e4;
var millisecondsPerTick = 1 / ticksPerMillisecond;
var ticksPerSecond = ticksPerMillisecond * 1e3;
var secondsPerTick = 1 / ticksPerSecond;
var ticksPerMinute = ticksPerSecond * 60;
var minutesPerTick = 1 / ticksPerMinute;
var ticksPerHour = ticksPerMinute * 60;
var hoursPerTick = 1 / ticksPerHour;
var ticksPerDay = ticksPerHour * 24;
var daysPerTick = 1 / ticksPerDay;
var millisPerSecond = 1e3;
var millisPerMinute = millisPerSecond * 60;
var millisPerHour = millisPerMinute * 60;
var millisPerDay = millisPerHour * 24;
var maxMilliSeconds = Number.MAX_SAFE_INTEGER / ticksPerMillisecond;
var minMilliSeconds = Number.MIN_SAFE_INTEGER / ticksPerMillisecond;
var TimeSpan = class _TimeSpan {
  constructor(days, hours, minutes, seconds, milliseconds) {
    if (!Number.isInteger(days)) {
      throw new Error("days is not an integer");
    }
    if (!Number.isInteger(hours)) {
      throw new Error("hours is not an integer");
    }
    if (!Number.isInteger(minutes)) {
      throw new Error("minutes is not an integer");
    }
    if (!Number.isInteger(seconds)) {
      throw new Error("seconds is not an integer");
    }
    if (!Number.isInteger(milliseconds)) {
      throw new Error("milliseconds is not an integer");
    }
    const totalMilliSeconds = (days * 3600 * 24 + hours * 3600 + minutes * 60 + seconds) * 1e3 + milliseconds;
    if (totalMilliSeconds > maxMilliSeconds || totalMilliSeconds < minMilliSeconds) {
      throw new Error("Total number of milliseconds was either too large or too small");
    }
    this._ticks = totalMilliSeconds * ticksPerMillisecond;
  }
  /**
   * Returns a new TimeSpan object whose value is the sum of the specified TimeSpan object and this instance.
   * @param ts - The time interval to add.
   */
  add(ts) {
    if (_TimeSpan.additionDoesOverflow(this._ticks, ts._ticks)) {
      throw new Error("Adding the two timestamps causes an overflow.");
    }
    const results = this._ticks + ts._ticks;
    return _TimeSpan.fromTicks(results);
  }
  /**
   * Returns a new TimeSpan object whose value is the difference of the specified TimeSpan object and this instance.
   * @param ts - The time interval to subtract.
   */
  subtract(ts) {
    if (_TimeSpan.subtractionDoesUnderflow(this._ticks, ts._ticks)) {
      throw new Error("Subtracting the two timestamps causes an underflow.");
    }
    const results = this._ticks - ts._ticks;
    return _TimeSpan.fromTicks(results);
  }
  /**
   * Compares this instance to a specified object and returns an integer that indicates whether this
   * instance is shorter than, equal to, or longer than the specified object.
   * @param value - The time interval to add.
   */
  compareTo(value) {
    if (value == null) {
      return 1;
    }
    if (!_TimeSpan.isTimeSpan(value)) {
      throw new Error("Argument must be a TimeSpan object");
    }
    return _TimeSpan.compare(this, value);
  }
  /**
   * Returns a new TimeSpan object whose value is the absolute value of the current TimeSpan object.
   */
  duration() {
    return _TimeSpan.fromTicks(this._ticks >= 0 ? this._ticks : -this._ticks);
  }
  /**
   * Returns a value indicating whether this instance is equal to a specified object.
   * @param value - The time interval to check for equality.
   */
  equals(value) {
    if (_TimeSpan.isTimeSpan(value)) {
      return this._ticks === value._ticks;
    }
    return false;
  }
  /**
   * Returns a new TimeSpan object whose value is the negated value of this instance.
   * @param value - The time interval to check for equality.
   */
  negate() {
    return _TimeSpan.fromTicks(-this._ticks);
  }
  days() {
    return Math.floor(this._ticks / ticksPerDay);
  }
  hours() {
    return Math.floor(this._ticks / ticksPerHour);
  }
  milliseconds() {
    return Math.floor(this._ticks / ticksPerMillisecond);
  }
  seconds() {
    return Math.floor(this._ticks / ticksPerSecond);
  }
  ticks() {
    return this._ticks;
  }
  totalDays() {
    return this._ticks * daysPerTick;
  }
  totalHours() {
    return this._ticks * hoursPerTick;
  }
  totalMilliseconds() {
    return this._ticks * millisecondsPerTick;
  }
  totalMinutes() {
    return this._ticks * minutesPerTick;
  }
  totalSeconds() {
    return this._ticks * secondsPerTick;
  }
  static fromTicks(value) {
    const timeSpan = new _TimeSpan(0, 0, 0, 0, 0);
    timeSpan._ticks = value;
    return timeSpan;
  }
  static isTimeSpan(timespan) {
    return timespan._ticks;
  }
  static additionDoesOverflow(a, b) {
    const c = a + b;
    return a !== c - b || b !== c - a;
  }
  static subtractionDoesUnderflow(a, b) {
    const c = a - b;
    return a !== c + b || b !== a - c;
  }
  static compare(t1, t2) {
    if (t1._ticks > t2._ticks) {
      return 1;
    }
    if (t1._ticks < t2._ticks) {
      return -1;
    }
    return 0;
  }
  static interval(value, scale) {
    if (isNaN(value)) {
      throw new Error("value must be a number");
    }
    const milliseconds = value * scale;
    if (milliseconds > maxMilliSeconds || milliseconds < minMilliSeconds) {
      throw new Error("timespan too long");
    }
    return _TimeSpan.fromTicks(Math.floor(milliseconds * ticksPerMillisecond));
  }
  static fromMilliseconds(value) {
    return _TimeSpan.interval(value, 1);
  }
  static fromSeconds(value) {
    return _TimeSpan.interval(value, millisPerSecond);
  }
  static fromMinutes(value) {
    return _TimeSpan.interval(value, millisPerMinute);
  }
  static fromHours(value) {
    return _TimeSpan.interval(value, millisPerHour);
  }
  static fromDays(value) {
    return _TimeSpan.interval(value, millisPerDay);
  }
};
TimeSpan.zero = new TimeSpan(0, 0, 0, 0, 0);
TimeSpan.maxValue = TimeSpan.fromTicks(Number.MAX_SAFE_INTEGER);
TimeSpan.minValue = TimeSpan.fromTicks(Number.MIN_SAFE_INTEGER);

// node_modules/@azure/cosmos/dist-esm/src/queryMetrics/queryMetricsUtils.js
function parseDelimitedString(delimitedString) {
  if (delimitedString == null) {
    throw new Error("delimitedString is null or undefined");
  }
  const metrics = {};
  const headerAttributes = delimitedString.split(";");
  for (const attribute of headerAttributes) {
    const attributeKeyValue = attribute.split("=");
    if (attributeKeyValue.length !== 2) {
      throw new Error("recieved a malformed delimited string");
    }
    const attributeKey = attributeKeyValue[0];
    const attributeValue = parseFloat(attributeKeyValue[1]);
    metrics[attributeKey] = attributeValue;
  }
  return metrics;
}
function timeSpanFromMetrics(metrics, key) {
  if (key in metrics) {
    return TimeSpan.fromMilliseconds(metrics[key]);
  }
  return TimeSpan.zero;
}

// node_modules/@azure/cosmos/dist-esm/src/queryMetrics/queryPreparationTime.js
var QueryPreparationTimes = class _QueryPreparationTimes {
  constructor(queryCompilationTime, logicalPlanBuildTime, physicalPlanBuildTime, queryOptimizationTime) {
    this.queryCompilationTime = queryCompilationTime;
    this.logicalPlanBuildTime = logicalPlanBuildTime;
    this.physicalPlanBuildTime = physicalPlanBuildTime;
    this.queryOptimizationTime = queryOptimizationTime;
  }
  /**
   * returns a new QueryPreparationTimes instance that is the addition of this and the arguments.
   */
  add(...queryPreparationTimesArray) {
    let queryCompilationTime = this.queryCompilationTime;
    let logicalPlanBuildTime = this.logicalPlanBuildTime;
    let physicalPlanBuildTime = this.physicalPlanBuildTime;
    let queryOptimizationTime = this.queryOptimizationTime;
    for (const queryPreparationTimes of queryPreparationTimesArray) {
      if (queryPreparationTimes == null) {
        throw new Error("queryPreparationTimesArray has null or undefined item(s)");
      }
      queryCompilationTime = queryCompilationTime.add(queryPreparationTimes.queryCompilationTime);
      logicalPlanBuildTime = logicalPlanBuildTime.add(queryPreparationTimes.logicalPlanBuildTime);
      physicalPlanBuildTime = physicalPlanBuildTime.add(queryPreparationTimes.physicalPlanBuildTime);
      queryOptimizationTime = queryOptimizationTime.add(queryPreparationTimes.queryOptimizationTime);
    }
    return new _QueryPreparationTimes(queryCompilationTime, logicalPlanBuildTime, physicalPlanBuildTime, queryOptimizationTime);
  }
  /**
   * Output the QueryPreparationTimes as a delimited string.
   */
  toDelimitedString() {
    return `${queryMetricsConstants_default.QueryCompileTimeInMs}=${this.queryCompilationTime.totalMilliseconds()};${queryMetricsConstants_default.LogicalPlanBuildTimeInMs}=${this.logicalPlanBuildTime.totalMilliseconds()};${queryMetricsConstants_default.PhysicalPlanBuildTimeInMs}=${this.physicalPlanBuildTime.totalMilliseconds()};${queryMetricsConstants_default.QueryOptimizationTimeInMs}=${this.queryOptimizationTime.totalMilliseconds()}`;
  }
  /**
   * Returns a new instance of the QueryPreparationTimes class that is the
   * aggregation of an array of QueryPreparationTimes.
   */
  static createFromArray(queryPreparationTimesArray) {
    if (queryPreparationTimesArray == null) {
      throw new Error("queryPreparationTimesArray is null or undefined item(s)");
    }
    return _QueryPreparationTimes.zero.add(...queryPreparationTimesArray);
  }
  /**
   * Returns a new instance of the QueryPreparationTimes class this is deserialized from a delimited string.
   */
  static createFromDelimitedString(delimitedString) {
    const metrics = parseDelimitedString(delimitedString);
    return new _QueryPreparationTimes(timeSpanFromMetrics(metrics, queryMetricsConstants_default.QueryCompileTimeInMs), timeSpanFromMetrics(metrics, queryMetricsConstants_default.LogicalPlanBuildTimeInMs), timeSpanFromMetrics(metrics, queryMetricsConstants_default.PhysicalPlanBuildTimeInMs), timeSpanFromMetrics(metrics, queryMetricsConstants_default.QueryOptimizationTimeInMs));
  }
};
QueryPreparationTimes.zero = new QueryPreparationTimes(TimeSpan.zero, TimeSpan.zero, TimeSpan.zero, TimeSpan.zero);

// node_modules/@azure/cosmos/dist-esm/src/queryMetrics/runtimeExecutionTimes.js
var RuntimeExecutionTimes = class _RuntimeExecutionTimes {
  constructor(queryEngineExecutionTime, systemFunctionExecutionTime, userDefinedFunctionExecutionTime) {
    this.queryEngineExecutionTime = queryEngineExecutionTime;
    this.systemFunctionExecutionTime = systemFunctionExecutionTime;
    this.userDefinedFunctionExecutionTime = userDefinedFunctionExecutionTime;
  }
  /**
   * returns a new RuntimeExecutionTimes instance that is the addition of this and the arguments.
   */
  add(...runtimeExecutionTimesArray) {
    let queryEngineExecutionTime = this.queryEngineExecutionTime;
    let systemFunctionExecutionTime = this.systemFunctionExecutionTime;
    let userDefinedFunctionExecutionTime = this.userDefinedFunctionExecutionTime;
    for (const runtimeExecutionTimes of runtimeExecutionTimesArray) {
      if (runtimeExecutionTimes == null) {
        throw new Error("runtimeExecutionTimes has null or undefined item(s)");
      }
      queryEngineExecutionTime = queryEngineExecutionTime.add(runtimeExecutionTimes.queryEngineExecutionTime);
      systemFunctionExecutionTime = systemFunctionExecutionTime.add(runtimeExecutionTimes.systemFunctionExecutionTime);
      userDefinedFunctionExecutionTime = userDefinedFunctionExecutionTime.add(runtimeExecutionTimes.userDefinedFunctionExecutionTime);
    }
    return new _RuntimeExecutionTimes(queryEngineExecutionTime, systemFunctionExecutionTime, userDefinedFunctionExecutionTime);
  }
  /**
   * Output the RuntimeExecutionTimes as a delimited string.
   */
  toDelimitedString() {
    return `${queryMetricsConstants_default.SystemFunctionExecuteTimeInMs}=${this.systemFunctionExecutionTime.totalMilliseconds()};${queryMetricsConstants_default.UserDefinedFunctionExecutionTimeInMs}=${this.userDefinedFunctionExecutionTime.totalMilliseconds()}`;
  }
  /**
   * Returns a new instance of the RuntimeExecutionTimes class that is
   *  the aggregation of an array of RuntimeExecutionTimes.
   */
  static createFromArray(runtimeExecutionTimesArray) {
    if (runtimeExecutionTimesArray == null) {
      throw new Error("runtimeExecutionTimesArray is null or undefined item(s)");
    }
    return _RuntimeExecutionTimes.zero.add(...runtimeExecutionTimesArray);
  }
  /**
   * Returns a new instance of the RuntimeExecutionTimes class this is deserialized from a delimited string.
   */
  static createFromDelimitedString(delimitedString) {
    const metrics = parseDelimitedString(delimitedString);
    const vmExecutionTime = timeSpanFromMetrics(metrics, queryMetricsConstants_default.VMExecutionTimeInMs);
    const indexLookupTime = timeSpanFromMetrics(metrics, queryMetricsConstants_default.IndexLookupTimeInMs);
    const documentLoadTime = timeSpanFromMetrics(metrics, queryMetricsConstants_default.DocumentLoadTimeInMs);
    const documentWriteTime = timeSpanFromMetrics(metrics, queryMetricsConstants_default.DocumentWriteTimeInMs);
    let queryEngineExecutionTime = TimeSpan.zero;
    queryEngineExecutionTime = queryEngineExecutionTime.add(vmExecutionTime);
    queryEngineExecutionTime = queryEngineExecutionTime.subtract(indexLookupTime);
    queryEngineExecutionTime = queryEngineExecutionTime.subtract(documentLoadTime);
    queryEngineExecutionTime = queryEngineExecutionTime.subtract(documentWriteTime);
    return new _RuntimeExecutionTimes(queryEngineExecutionTime, timeSpanFromMetrics(metrics, queryMetricsConstants_default.SystemFunctionExecuteTimeInMs), timeSpanFromMetrics(metrics, queryMetricsConstants_default.UserDefinedFunctionExecutionTimeInMs));
  }
};
RuntimeExecutionTimes.zero = new RuntimeExecutionTimes(TimeSpan.zero, TimeSpan.zero, TimeSpan.zero);

// node_modules/@azure/cosmos/dist-esm/src/queryMetrics/queryMetrics.js
var QueryMetrics = class _QueryMetrics {
  constructor(retrievedDocumentCount, retrievedDocumentSize, outputDocumentCount, outputDocumentSize, indexHitDocumentCount, totalQueryExecutionTime, queryPreparationTimes, indexLookupTime, documentLoadTime, vmExecutionTime, runtimeExecutionTimes, documentWriteTime, clientSideMetrics) {
    this.retrievedDocumentCount = retrievedDocumentCount;
    this.retrievedDocumentSize = retrievedDocumentSize;
    this.outputDocumentCount = outputDocumentCount;
    this.outputDocumentSize = outputDocumentSize;
    this.indexHitDocumentCount = indexHitDocumentCount;
    this.totalQueryExecutionTime = totalQueryExecutionTime;
    this.queryPreparationTimes = queryPreparationTimes;
    this.indexLookupTime = indexLookupTime;
    this.documentLoadTime = documentLoadTime;
    this.vmExecutionTime = vmExecutionTime;
    this.runtimeExecutionTimes = runtimeExecutionTimes;
    this.documentWriteTime = documentWriteTime;
    this.clientSideMetrics = clientSideMetrics;
  }
  /**
   * Gets the IndexHitRatio
   * @hidden
   */
  get indexHitRatio() {
    return this.retrievedDocumentCount === 0 ? 1 : this.indexHitDocumentCount / this.retrievedDocumentCount;
  }
  /**
   * returns a new QueryMetrics instance that is the addition of this and the arguments.
   */
  add(queryMetricsArray) {
    let retrievedDocumentCount = 0;
    let retrievedDocumentSize = 0;
    let outputDocumentCount = 0;
    let outputDocumentSize = 0;
    let indexHitDocumentCount = 0;
    let totalQueryExecutionTime = TimeSpan.zero;
    const queryPreparationTimesArray = [];
    let indexLookupTime = TimeSpan.zero;
    let documentLoadTime = TimeSpan.zero;
    let vmExecutionTime = TimeSpan.zero;
    const runtimeExecutionTimesArray = [];
    let documentWriteTime = TimeSpan.zero;
    const clientSideQueryMetricsArray = [];
    queryMetricsArray.push(this);
    for (const queryMetrics of queryMetricsArray) {
      if (queryMetrics) {
        retrievedDocumentCount += queryMetrics.retrievedDocumentCount;
        retrievedDocumentSize += queryMetrics.retrievedDocumentSize;
        outputDocumentCount += queryMetrics.outputDocumentCount;
        outputDocumentSize += queryMetrics.outputDocumentSize;
        indexHitDocumentCount += queryMetrics.indexHitDocumentCount;
        totalQueryExecutionTime = totalQueryExecutionTime.add(queryMetrics.totalQueryExecutionTime);
        queryPreparationTimesArray.push(queryMetrics.queryPreparationTimes);
        indexLookupTime = indexLookupTime.add(queryMetrics.indexLookupTime);
        documentLoadTime = documentLoadTime.add(queryMetrics.documentLoadTime);
        vmExecutionTime = vmExecutionTime.add(queryMetrics.vmExecutionTime);
        runtimeExecutionTimesArray.push(queryMetrics.runtimeExecutionTimes);
        documentWriteTime = documentWriteTime.add(queryMetrics.documentWriteTime);
        clientSideQueryMetricsArray.push(queryMetrics.clientSideMetrics);
      }
    }
    return new _QueryMetrics(retrievedDocumentCount, retrievedDocumentSize, outputDocumentCount, outputDocumentSize, indexHitDocumentCount, totalQueryExecutionTime, QueryPreparationTimes.createFromArray(queryPreparationTimesArray), indexLookupTime, documentLoadTime, vmExecutionTime, RuntimeExecutionTimes.createFromArray(runtimeExecutionTimesArray), documentWriteTime, ClientSideMetrics.createFromArray(...clientSideQueryMetricsArray));
  }
  /**
   * Output the QueryMetrics as a delimited string.
   * @hidden
   */
  toDelimitedString() {
    return queryMetricsConstants_default.RetrievedDocumentCount + "=" + this.retrievedDocumentCount + ";" + queryMetricsConstants_default.RetrievedDocumentSize + "=" + this.retrievedDocumentSize + ";" + queryMetricsConstants_default.OutputDocumentCount + "=" + this.outputDocumentCount + ";" + queryMetricsConstants_default.OutputDocumentSize + "=" + this.outputDocumentSize + ";" + queryMetricsConstants_default.IndexHitRatio + "=" + this.indexHitRatio + ";" + queryMetricsConstants_default.TotalQueryExecutionTimeInMs + "=" + this.totalQueryExecutionTime.totalMilliseconds() + ";" + this.queryPreparationTimes.toDelimitedString() + ";" + queryMetricsConstants_default.IndexLookupTimeInMs + "=" + this.indexLookupTime.totalMilliseconds() + ";" + queryMetricsConstants_default.DocumentLoadTimeInMs + "=" + this.documentLoadTime.totalMilliseconds() + ";" + queryMetricsConstants_default.VMExecutionTimeInMs + "=" + this.vmExecutionTime.totalMilliseconds() + ";" + this.runtimeExecutionTimes.toDelimitedString() + ";" + queryMetricsConstants_default.DocumentWriteTimeInMs + "=" + this.documentWriteTime.totalMilliseconds();
  }
  /**
   * Returns a new instance of the QueryMetrics class that is the aggregation of an array of query metrics.
   */
  static createFromArray(queryMetricsArray) {
    if (!queryMetricsArray) {
      throw new Error("queryMetricsArray is null or undefined item(s)");
    }
    return _QueryMetrics.zero.add(queryMetricsArray);
  }
  /**
   * Returns a new instance of the QueryMetrics class this is deserialized from a delimited string.
   */
  static createFromDelimitedString(delimitedString, clientSideMetrics) {
    const metrics = parseDelimitedString(delimitedString);
    const indexHitRatio = metrics[queryMetricsConstants_default.IndexHitRatio] || 0;
    const retrievedDocumentCount = metrics[queryMetricsConstants_default.RetrievedDocumentCount] || 0;
    const indexHitCount = indexHitRatio * retrievedDocumentCount;
    const outputDocumentCount = metrics[queryMetricsConstants_default.OutputDocumentCount] || 0;
    const outputDocumentSize = metrics[queryMetricsConstants_default.OutputDocumentSize] || 0;
    const retrievedDocumentSize = metrics[queryMetricsConstants_default.RetrievedDocumentSize] || 0;
    const totalQueryExecutionTime = timeSpanFromMetrics(metrics, queryMetricsConstants_default.TotalQueryExecutionTimeInMs);
    return new _QueryMetrics(retrievedDocumentCount, retrievedDocumentSize, outputDocumentCount, outputDocumentSize, indexHitCount, totalQueryExecutionTime, QueryPreparationTimes.createFromDelimitedString(delimitedString), timeSpanFromMetrics(metrics, queryMetricsConstants_default.IndexLookupTimeInMs), timeSpanFromMetrics(metrics, queryMetricsConstants_default.DocumentLoadTimeInMs), timeSpanFromMetrics(metrics, queryMetricsConstants_default.VMExecutionTimeInMs), RuntimeExecutionTimes.createFromDelimitedString(delimitedString), timeSpanFromMetrics(metrics, queryMetricsConstants_default.DocumentWriteTimeInMs), clientSideMetrics || ClientSideMetrics.zero);
  }
};
QueryMetrics.zero = new QueryMetrics(0, 0, 0, 0, 0, TimeSpan.zero, QueryPreparationTimes.zero, TimeSpan.zero, TimeSpan.zero, TimeSpan.zero, RuntimeExecutionTimes.zero, TimeSpan.zero, ClientSideMetrics.zero);

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/headerUtils.js
function getRequestChargeIfAny(headers) {
  if (typeof headers === "number") {
    return headers;
  } else if (typeof headers === "string") {
    return parseFloat(headers);
  }
  if (headers) {
    const rc = headers[Constants.HttpHeaders.RequestCharge];
    if (rc) {
      return parseFloat(rc);
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}
function getInitialHeader() {
  const headers = {};
  headers[Constants.HttpHeaders.RequestCharge] = 0;
  headers[Constants.HttpHeaders.QueryMetrics] = {};
  return headers;
}
function mergeHeaders(headers, toBeMergedHeaders) {
  if (headers[Constants.HttpHeaders.RequestCharge] === void 0) {
    headers[Constants.HttpHeaders.RequestCharge] = 0;
  }
  if (headers[Constants.HttpHeaders.QueryMetrics] === void 0) {
    headers[Constants.HttpHeaders.QueryMetrics] = QueryMetrics.zero;
  }
  if (!toBeMergedHeaders) {
    return;
  }
  headers[Constants.HttpHeaders.RequestCharge] += getRequestChargeIfAny(toBeMergedHeaders);
  if (toBeMergedHeaders[Constants.HttpHeaders.IsRUPerMinuteUsed]) {
    headers[Constants.HttpHeaders.IsRUPerMinuteUsed] = toBeMergedHeaders[Constants.HttpHeaders.IsRUPerMinuteUsed];
  }
  if (Constants.HttpHeaders.QueryMetrics in toBeMergedHeaders) {
    const headerQueryMetrics = headers[Constants.HttpHeaders.QueryMetrics];
    const toBeMergedHeaderQueryMetrics = toBeMergedHeaders[Constants.HttpHeaders.QueryMetrics];
    for (const partitionId in toBeMergedHeaderQueryMetrics) {
      if (headerQueryMetrics[partitionId]) {
        const combinedQueryMetrics = headerQueryMetrics[partitionId].add([
          toBeMergedHeaderQueryMetrics[partitionId]
        ]);
        headerQueryMetrics[partitionId] = combinedQueryMetrics;
      } else {
        headerQueryMetrics[partitionId] = toBeMergedHeaderQueryMetrics[partitionId];
      }
    }
  }
  if (Constants.HttpHeaders.IndexUtilization in toBeMergedHeaders) {
    headers[Constants.HttpHeaders.IndexUtilization] = toBeMergedHeaders[Constants.HttpHeaders.IndexUtilization];
  }
}

// node_modules/@azure/cosmos/dist-esm/src/indexMetrics/IndexUtilizationInfo.js
var IndexUtilizationInfo = class _IndexUtilizationInfo {
  constructor(UtilizedSingleIndexes, PotentialSingleIndexes, UtilizedCompositeIndexes, PotentialCompositeIndexes) {
    this.UtilizedSingleIndexes = UtilizedSingleIndexes;
    this.PotentialSingleIndexes = PotentialSingleIndexes;
    this.UtilizedCompositeIndexes = UtilizedCompositeIndexes;
    this.PotentialCompositeIndexes = PotentialCompositeIndexes;
  }
  static tryCreateFromDelimitedBase64String(delimitedString, out) {
    if (delimitedString == null) {
      out.result = _IndexUtilizationInfo.Empty;
      return false;
    }
    return _IndexUtilizationInfo.tryCreateFromDelimitedString(Buffer.from(delimitedString, "base64").toString(), out);
  }
  static tryCreateFromDelimitedString(delimitedString, out) {
    if (delimitedString == null) {
      out.result = _IndexUtilizationInfo.Empty;
      return false;
    }
    try {
      out.result = JSON.parse(delimitedString) || _IndexUtilizationInfo.Empty;
      return true;
    } catch (error) {
      out.result = _IndexUtilizationInfo.Empty;
      return false;
    }
  }
  static createFromString(delimitedString, isBase64Encoded) {
    var _a;
    const result = { result: void 0 };
    if (isBase64Encoded) {
      _IndexUtilizationInfo.tryCreateFromDelimitedBase64String(delimitedString, result);
    } else {
      _IndexUtilizationInfo.tryCreateFromDelimitedString(delimitedString, result);
    }
    return (_a = result.result) !== null && _a !== void 0 ? _a : _IndexUtilizationInfo.Empty;
  }
};
IndexUtilizationInfo.Empty = new IndexUtilizationInfo([], [], [], []);

// node_modules/@azure/cosmos/dist-esm/src/indexMetrics/Constants.js
var Constants_default = {
  IndexUtilizationInfo: "Index Utilization Information",
  UtilizedSingleIndexes: "Utilized Single Indexes",
  PotentialSingleIndexes: "Potential Single Indexes",
  UtilizedCompositeIndexes: "Utilized Composite Indexes",
  PotentialCompositeIndexes: "Potential Composite Indexes",
  IndexExpression: "Index Spec",
  IndexImpactScore: "Index Impact Score",
  IndexUtilizationSeparator: "---"
};

// node_modules/@azure/cosmos/dist-esm/src/indexMetrics/IndexMetricWriter.js
var IndexMetricWriter = class {
  writeIndexMetrics(indexUtilizationInfo) {
    let result = "";
    result = this.writeBeforeIndexUtilizationInfo(result);
    result = this.writeIndexUtilizationInfo(result, indexUtilizationInfo);
    result = this.writeAfterIndexUtilizationInfo(result);
    return result;
  }
  writeBeforeIndexUtilizationInfo(result) {
    result = this.appendNewlineToResult(result);
    result = this.appendHeaderToResult(result, Constants_default.IndexUtilizationInfo, 0);
    return result;
  }
  writeIndexUtilizationInfo(result, indexUtilizationInfo) {
    result = this.appendHeaderToResult(result, Constants_default.UtilizedSingleIndexes, 1);
    for (const indexUtilizationEntity of indexUtilizationInfo.UtilizedSingleIndexes) {
      result = this.writeSingleIndexUtilizationEntity(result, indexUtilizationEntity);
    }
    result = this.appendHeaderToResult(result, Constants_default.PotentialSingleIndexes, 1);
    for (const indexUtilizationEntity of indexUtilizationInfo.PotentialSingleIndexes) {
      result = this.writeSingleIndexUtilizationEntity(result, indexUtilizationEntity);
    }
    result = this.appendHeaderToResult(result, Constants_default.UtilizedCompositeIndexes, 1);
    for (const indexUtilizationEntity of indexUtilizationInfo.UtilizedCompositeIndexes) {
      result = this.writeCompositeIndexUtilizationEntity(result, indexUtilizationEntity);
    }
    result = this.appendHeaderToResult(result, Constants_default.PotentialCompositeIndexes, 1);
    for (const indexUtilizationEntity of indexUtilizationInfo.PotentialCompositeIndexes) {
      result = this.writeCompositeIndexUtilizationEntity(result, indexUtilizationEntity);
    }
    return result;
  }
  writeAfterIndexUtilizationInfo(result) {
    return result;
  }
  writeSingleIndexUtilizationEntity(result, indexUtilizationEntity) {
    result = this.appendHeaderToResult(result, `${Constants_default.IndexExpression}: ${indexUtilizationEntity.IndexSpec}`, 2);
    result = this.appendHeaderToResult(result, `${Constants_default.IndexImpactScore}: ${indexUtilizationEntity.IndexImpactScore}`, 2);
    result = this.appendHeaderToResult(result, Constants_default.IndexUtilizationSeparator, 2);
    return result;
  }
  writeCompositeIndexUtilizationEntity(result, indexUtilizationEntity) {
    result = this.appendHeaderToResult(result, `${Constants_default.IndexExpression}: ${indexUtilizationEntity.IndexSpecs.join(", ")}`, 2);
    result = this.appendHeaderToResult(result, `${Constants_default.IndexImpactScore}: ${indexUtilizationEntity.IndexImpactScore}`, 2);
    result = this.appendHeaderToResult(result, Constants_default.IndexUtilizationSeparator, 2);
    return result;
  }
  appendNewlineToResult(result) {
    return this.appendHeaderToResult(result, "", 0);
  }
  appendHeaderToResult(result, headerTitle, indentLevel) {
    const Indent = "  ";
    const header = `${Indent.repeat(indentLevel)}${headerTitle}
`;
    result += header;
    return result;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/request/FeedResponse.js
var FeedResponse = class {
  constructor(resources, headers, hasMoreResults, diagnostics) {
    this.resources = resources;
    this.headers = headers;
    this.hasMoreResults = hasMoreResults;
    this.diagnostics = diagnostics;
  }
  get continuation() {
    return this.continuationToken;
  }
  get continuationToken() {
    return this.headers[Constants.HttpHeaders.Continuation];
  }
  get queryMetrics() {
    return this.headers[Constants.HttpHeaders.QueryMetrics];
  }
  get requestCharge() {
    return getRequestChargeIfAny(this.headers);
  }
  get activityId() {
    return this.headers[Constants.HttpHeaders.ActivityId];
  }
  get indexMetrics() {
    const writer = new IndexMetricWriter();
    const indexUtilizationInfo = IndexUtilizationInfo.createFromString(this.headers[Constants.HttpHeaders.IndexUtilization], true);
    return writer.writeIndexMetrics(indexUtilizationInfo);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/request/TimeoutError.js
var TimeoutErrorCode = "TimeoutError";
var TimeoutError = class extends Error {
  constructor(message = "Timeout Error") {
    super(message);
    this.code = TimeoutErrorCode;
    this.name = TimeoutErrorCode;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/utils/time.js
function getCurrentTimestampInMs() {
  return Date.now();
}

// node_modules/@azure/cosmos/dist-esm/src/diagnostics/CosmosDiagnosticsContext.js
var CosmosDiagnosticContext = class {
  constructor() {
    this.failedAttempts = [];
    this.metadataLookups = [];
    this.gaterwayStatistics = [];
    this.locationEndpointsContacted = /* @__PURE__ */ new Set();
    this.requestStartTimeUTCinMs = getCurrentTimestampInMs();
  }
  recordFailedAttempt(gaterwayStatistics, retryAttemptNumber) {
    const attempt = {
      attemptNumber: retryAttemptNumber,
      startTimeUTCInMs: gaterwayStatistics.startTimeUTCInMs,
      durationInMs: gaterwayStatistics.durationInMs,
      statusCode: gaterwayStatistics.statusCode,
      substatusCode: gaterwayStatistics.subStatusCode,
      requestPayloadLengthInBytes: gaterwayStatistics.requestPayloadLengthInBytes,
      responsePayloadLengthInBytes: gaterwayStatistics.responsePayloadLengthInBytes,
      activityId: gaterwayStatistics.activityId,
      operationType: gaterwayStatistics.operationType,
      resourceType: gaterwayStatistics.resourceType
    };
    this.failedAttempts.push(attempt);
  }
  recordNetworkCall(gaterwayStatistics) {
    this.gaterwayStatistics.push(gaterwayStatistics);
  }
  /**
   * Merge given DiagnosticContext to current node's DiagnosticContext, Treating GatewayRequests of
   * given DiagnosticContext, as metadata requests.
   */
  mergeDiagnostics(childDiagnostics, metadataType) {
    childDiagnostics.locationEndpointsContacted.forEach((endpoint) => this.locationEndpointsContacted.add(endpoint));
    childDiagnostics.gaterwayStatistics.forEach((gateway) => this.metadataLookups.push({
      activityId: gateway.activityId,
      requestPayloadLengthInBytes: gateway.requestPayloadLengthInBytes,
      responsePayloadLengthInBytes: gateway.responsePayloadLengthInBytes,
      startTimeUTCInMs: gateway.startTimeUTCInMs,
      operationType: gateway.operationType,
      resourceType: gateway.resourceType,
      durationInMs: gateway.durationInMs,
      metaDataType: metadataType
    }));
    childDiagnostics.metadataLookups.forEach((lookup) => this.metadataLookups.push(lookup));
    childDiagnostics.failedAttempts.forEach((lookup) => this.failedAttempts.push(lookup));
  }
  getClientSideStats(endTimeUTCInMs = getCurrentTimestampInMs()) {
    return {
      requestStartTimeUTCInMs: this.requestStartTimeUTCinMs,
      requestDurationInMs: endTimeUTCInMs - this.requestStartTimeUTCinMs,
      totalRequestPayloadLengthInBytes: this.getTotalRequestPayloadLength(),
      totalResponsePayloadLengthInBytes: this.getTotalResponsePayloadLength(),
      locationEndpointsContacted: [...this.locationEndpointsContacted.values()],
      metadataDiagnostics: {
        metadataLookups: [...this.metadataLookups]
      },
      retryDiagnostics: {
        failedAttempts: [...this.failedAttempts]
      },
      gatewayStatistics: this.gaterwayStatistics
    };
  }
  getTotalRequestPayloadLength() {
    let totalRequestPayloadLength = 0;
    this.gaterwayStatistics.forEach((req) => totalRequestPayloadLength += req.requestPayloadLengthInBytes);
    this.metadataLookups.forEach((req) => totalRequestPayloadLength += req.requestPayloadLengthInBytes);
    this.failedAttempts.forEach((req) => totalRequestPayloadLength += req.requestPayloadLengthInBytes);
    return totalRequestPayloadLength;
  }
  getTotalResponsePayloadLength() {
    let totalResponsePayloadLength = 0;
    this.gaterwayStatistics.forEach((req) => totalResponsePayloadLength += req.responsePayloadLengthInBytes);
    this.metadataLookups.forEach((req) => totalResponsePayloadLength += req.responsePayloadLengthInBytes);
    this.failedAttempts.forEach((req) => totalResponsePayloadLength += req.responsePayloadLengthInBytes);
    return totalResponsePayloadLength;
  }
  recordEndpointResolution(location) {
    this.locationEndpointsContacted.add(location);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/CosmosDiagnostics.js
var CosmosDiagnostics = class {
  /**
   * @internal
   */
  constructor(clientSideRequestStatistics, diagnosticNode, clientConfig) {
    this.clientSideRequestStatistics = clientSideRequestStatistics;
    this.diagnosticNode = diagnosticNode;
    this.clientConfig = clientConfig;
  }
};
var MetadataLookUpType;
(function(MetadataLookUpType2) {
  MetadataLookUpType2["PartitionKeyRangeLookUp"] = "PARTITION_KEY_RANGE_LOOK_UP";
  MetadataLookUpType2["DatabaseAccountLookUp"] = "DATABASE_ACCOUNT_LOOK_UP";
  MetadataLookUpType2["QueryPlanLookUp"] = "QUERY_PLAN_LOOK_UP";
  MetadataLookUpType2["DatabaseLookUp"] = "DATABASE_LOOK_UP";
  MetadataLookUpType2["ContainerLookUp"] = "CONTAINER_LOOK_UP";
})(MetadataLookUpType || (MetadataLookUpType = {}));
function getRootNode(node) {
  if (node.parent)
    return getRootNode(node.parent);
  else
    return node;
}

// node_modules/@azure/cosmos/dist-esm/src/diagnostics/CosmosDbDiagnosticLevel.js
var CosmosDbDiagnosticLevel;
(function(CosmosDbDiagnosticLevel2) {
  CosmosDbDiagnosticLevel2["info"] = "info";
  CosmosDbDiagnosticLevel2["debug"] = "debug";
  CosmosDbDiagnosticLevel2["debugUnsafe"] = "debug-unsafe";
})(CosmosDbDiagnosticLevel || (CosmosDbDiagnosticLevel = {}));

// node_modules/@azure/cosmos/dist-esm/src/diagnostics/diagnosticLevelComparator.js
var CosmosDbDiagnosticLevelOrder = [
  CosmosDbDiagnosticLevel.info,
  CosmosDbDiagnosticLevel.debug,
  CosmosDbDiagnosticLevel.debugUnsafe
];
function allowTracing(levelToCheck, clientDiagnosticLevel) {
  const indexOfDiagnosticLevelToCheck = CosmosDbDiagnosticLevelOrder.indexOf(levelToCheck);
  const indexOfClientDiagnosticLevel = CosmosDbDiagnosticLevelOrder.indexOf(clientDiagnosticLevel);
  if (indexOfDiagnosticLevelToCheck === -1 || indexOfClientDiagnosticLevel === -1) {
    return false;
  }
  return indexOfDiagnosticLevelToCheck <= indexOfClientDiagnosticLevel;
}

// node_modules/@azure/cosmos/dist-esm/src/diagnostics/DiagnosticNodeInternal.js
var DiagnosticNodeInternal = class _DiagnosticNodeInternal {
  /**
   * @internal
   */
  constructor(diagnosticLevel, type, parent, data = {}, startTimeUTCInMs = getCurrentTimestampInMs(), ctx = new CosmosDiagnosticContext()) {
    this.id = v4_default();
    this.nodeType = type;
    this.startTimeUTCInMs = startTimeUTCInMs;
    this.data = data;
    this.children = [];
    this.durationInMs = 0;
    this.parent = parent;
    this.diagnosticCtx = ctx;
    this.diagnosticLevel = diagnosticLevel;
  }
  /**
   * @internal
   */
  addLog(msg) {
    if (!this.data.log) {
      this.data.log = [];
    }
    this.data.log.push(msg);
  }
  /**
   * @internal
   */
  sanitizeHeaders(headers) {
    return headers;
  }
  /**
   * Updated durationInMs for node, based on endTimeUTCInMs provided.
   * @internal
   */
  updateTimestamp(endTimeUTCInMs = getCurrentTimestampInMs()) {
    this.durationInMs = endTimeUTCInMs - this.startTimeUTCInMs;
  }
  /**
   * @internal
   */
  recordSuccessfulNetworkCall(startTimeUTCInMs, requestContext, pipelineResponse, substatus, url) {
    const responseHeaders = pipelineResponse.headers.toJSON();
    const gatewayRequest = {
      activityId: responseHeaders[Constants.HttpHeaders.ActivityId],
      startTimeUTCInMs,
      durationInMs: getCurrentTimestampInMs() - startTimeUTCInMs,
      statusCode: pipelineResponse.status,
      subStatusCode: substatus,
      requestPayloadLengthInBytes: calculateRequestPayloadLength(requestContext),
      responsePayloadLengthInBytes: calculateResponsePayloadLength(pipelineResponse),
      operationType: requestContext.operationType,
      resourceType: requestContext.resourceType,
      partitionKeyRangeId: requestContext.partitionKeyRangeId
    };
    let requestData = {
      OperationType: gatewayRequest.operationType,
      resourceType: gatewayRequest.resourceType,
      requestPayloadLengthInBytes: gatewayRequest.requestPayloadLengthInBytes
    };
    if (allowTracing(CosmosDbDiagnosticLevel.debugUnsafe, this.diagnosticLevel)) {
      requestData = Object.assign(Object.assign({}, requestData), { headers: this.sanitizeHeaders(requestContext.headers), requestBody: requestContext.body, responseBody: pipelineResponse.bodyAsText, url });
    }
    this.addData({
      requestPayloadLengthInBytes: gatewayRequest.requestPayloadLengthInBytes,
      responsePayloadLengthInBytes: gatewayRequest.responsePayloadLengthInBytes,
      startTimeUTCInMs: gatewayRequest.startTimeUTCInMs,
      durationInMs: gatewayRequest.durationInMs,
      requestData
    });
    this.diagnosticCtx.recordNetworkCall(gatewayRequest);
  }
  /**
   * @internal
   */
  recordFailedNetworkCall(startTimeUTCInMs, requestContext, retryAttemptNumber, statusCode, substatusCode, responseHeaders) {
    this.addData({ failedAttempty: true });
    const requestPayloadLengthInBytes = calculateRequestPayloadLength(requestContext);
    this.diagnosticCtx.recordFailedAttempt({
      activityId: responseHeaders[Constants.HttpHeaders.ActivityId],
      startTimeUTCInMs,
      durationInMs: getCurrentTimestampInMs() - startTimeUTCInMs,
      statusCode,
      subStatusCode: substatusCode,
      requestPayloadLengthInBytes,
      responsePayloadLengthInBytes: 0,
      operationType: requestContext.operationType,
      resourceType: requestContext.resourceType
    }, retryAttemptNumber);
    let requestData = {
      OperationType: requestContext.operationType,
      resourceType: requestContext.resourceType,
      requestPayloadLengthInBytes
    };
    if (allowTracing(CosmosDbDiagnosticLevel.debugUnsafe, this.diagnosticLevel)) {
      requestData = Object.assign(Object.assign({}, requestData), { headers: this.sanitizeHeaders(requestContext.headers), requestBody: requestContext.body, url: prepareURL(requestContext.endpoint, requestContext.path) });
    }
    this.addData({
      failedAttempty: true,
      requestData
    });
  }
  /**
   * @internal
   */
  recordEndpointResolution(location) {
    this.addData({ selectedLocation: location });
    this.diagnosticCtx.recordEndpointResolution(location);
  }
  /**
   * @internal
   */
  addData(data, msg, level = this.diagnosticLevel) {
    if (level !== CosmosDbDiagnosticLevel.info) {
      this.data = Object.assign(Object.assign({}, this.data), data);
      if (msg) {
        this.addLog(msg);
      }
    }
  }
  /**
   * Merge given DiagnosticNodeInternal's context to current node's DiagnosticContext, Treating GatewayRequests of
   * given DiagnosticContext, as metadata requests. Given DiagnosticNodeInternal becomes a child of this node.
   * @internal
   */
  addChildNode(child, level, metadataType) {
    this.diagnosticCtx.mergeDiagnostics(child.diagnosticCtx, metadataType);
    if (allowTracing(level, this.diagnosticLevel)) {
      child.parent = this;
      this.children.push(child);
    }
    return child;
  }
  /**
   * @internal
   */
  initializeChildNode(type, level, data = {}) {
    if (allowTracing(level, this.diagnosticLevel)) {
      const child = new _DiagnosticNodeInternal(this.diagnosticLevel, type, this, data, getCurrentTimestampInMs(), this.diagnosticCtx);
      this.children.push(child);
      return child;
    } else {
      return this;
    }
  }
  /**
   * @internal
   */
  recordQueryResult(resources, level) {
    var _a;
    if (allowTracing(level, this.diagnosticLevel)) {
      const previousCount = (_a = this.data.queryRecordsRead) !== null && _a !== void 0 ? _a : 0;
      if (Array.isArray(resources)) {
        this.data.queryRecordsRead = previousCount + resources.length;
      }
    }
  }
  /**
   * Convert DiagnosticNodeInternal (internal representation) to DiagnosticNode (public, sanitized representation)
   * @internal
   */
  toDiagnosticNode() {
    return {
      id: this.id,
      nodeType: this.nodeType,
      children: this.children.map((child) => child.toDiagnosticNode()),
      data: this.data,
      startTimeUTCInMs: this.startTimeUTCInMs,
      durationInMs: this.durationInMs
    };
  }
  /**
   * Convert to CosmosDiagnostics
   * @internal
   */
  toDiagnostic(clientConfigDiagnostic) {
    const rootNode = getRootNode(this);
    const diagnostiNode = allowTracing(CosmosDbDiagnosticLevel.debug, this.diagnosticLevel) ? rootNode.toDiagnosticNode() : void 0;
    const clientConfig = allowTracing(CosmosDbDiagnosticLevel.debug, this.diagnosticLevel) ? clientConfigDiagnostic : void 0;
    const cosmosDiagnostic = new CosmosDiagnostics(this.diagnosticCtx.getClientSideStats(), diagnostiNode, clientConfig);
    return cosmosDiagnostic;
  }
};
var DiagnosticNodeType;
(function(DiagnosticNodeType2) {
  DiagnosticNodeType2["CLIENT_REQUEST_NODE"] = "CLIENT_REQUEST_NODE";
  DiagnosticNodeType2["METADATA_REQUEST_NODE"] = "METADATA_REQUEST_NODE";
  DiagnosticNodeType2["HTTP_REQUEST"] = "HTTP_REQUEST";
  DiagnosticNodeType2["BATCH_REQUEST"] = "BATCH_REQUEST";
  DiagnosticNodeType2["PARALLEL_QUERY_NODE"] = "PARALLEL_QUERY_NODE";
  DiagnosticNodeType2["DEFAULT_QUERY_NODE"] = "DEFAULT_QUERY_NODE";
  DiagnosticNodeType2["QUERY_REPAIR_NODE"] = "QUERY_REPAIR_NODE";
  DiagnosticNodeType2["BACKGROUND_REFRESH_THREAD"] = "BACKGROUND_REFRESH_THREAD";
  DiagnosticNodeType2["REQUEST_ATTEMPTS"] = "REQUEST_ATTEMPTS";
})(DiagnosticNodeType || (DiagnosticNodeType = {}));
function calculateResponsePayloadLength(response) {
  var _a;
  return ((_a = response === null || response === void 0 ? void 0 : response.bodyAsText) === null || _a === void 0 ? void 0 : _a.length) || 0;
}
function calculateRequestPayloadLength(requestContext) {
  return requestContext.body ? requestContext.body.length : 0;
}

// node_modules/@azure/cosmos/dist-esm/src/utils/diagnostics.js
function getEmptyCosmosDiagnostics() {
  return new CosmosDiagnostics({
    requestDurationInMs: 0,
    requestStartTimeUTCInMs: getCurrentTimestampInMs(),
    totalRequestPayloadLengthInBytes: 0,
    totalResponsePayloadLengthInBytes: 0,
    locationEndpointsContacted: [],
    retryDiagnostics: {
      failedAttempts: []
    },
    metadataDiagnostics: {
      metadataLookups: []
    },
    gatewayStatistics: []
  }, {
    id: v4_default(),
    nodeType: DiagnosticNodeType.CLIENT_REQUEST_NODE,
    children: [],
    data: {},
    startTimeUTCInMs: getCurrentTimestampInMs(),
    durationInMs: 0
  });
}
async function addDignosticChild(callback, node, type, data = {}) {
  const childNode = node.initializeChildNode(type, CosmosDbDiagnosticLevel.debug, data);
  try {
    const response = await callback(childNode);
    childNode.updateTimestamp();
    return response;
  } catch (e) {
    childNode.addData({
      failure: true
    });
    childNode.updateTimestamp();
    throw e;
  }
}
async function withMetadataDiagnostics(callback, node, type) {
  const diagnosticNodeForMetadataCall = new DiagnosticNodeInternal(node.diagnosticLevel, DiagnosticNodeType.METADATA_REQUEST_NODE, null);
  try {
    const response = await callback(diagnosticNodeForMetadataCall);
    node.addChildNode(diagnosticNodeForMetadataCall, CosmosDbDiagnosticLevel.debug, type);
    return response;
  } catch (e) {
    node.addChildNode(diagnosticNodeForMetadataCall, CosmosDbDiagnosticLevel.debug, type);
    throw e;
  }
}
async function withDiagnostics(callback, clientContext, type = DiagnosticNodeType.CLIENT_REQUEST_NODE) {
  const diagnosticNode = new DiagnosticNodeInternal(clientContext.diagnosticLevel, type, null);
  try {
    const response = await callback(diagnosticNode);
    diagnosticNode.updateTimestamp();
    const diagnostics = diagnosticNode.toDiagnostic(clientContext.getClientConfig());
    if (typeof response === "object" && response !== null) {
      response.diagnostics = diagnostics;
    }
    clientContext.recordDiagnostics(diagnostics);
    return response;
  } catch (e) {
    diagnosticNode.updateTimestamp();
    diagnosticNode.addData({
      failure: true
    });
    const diagnostics = diagnosticNode.toDiagnostic(clientContext.getClientConfig());
    e.diagnostics = diagnostics;
    clientContext.recordDiagnostics(diagnostics);
    throw e;
  }
}

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/defaultQueryExecutionContext.js
var logger2 = createClientLogger("ClientContext");
var STATES;
(function(STATES2) {
  STATES2["start"] = "start";
  STATES2["inProgress"] = "inProgress";
  STATES2["ended"] = "ended";
})(STATES || (STATES = {}));
var DefaultQueryExecutionContext = class _DefaultQueryExecutionContext {
  get continuation() {
    return this.continuationToken;
  }
  /**
   * Provides the basic Query Execution Context.
   * This wraps the internal logic query execution using provided fetch functions
   *
   * @param clientContext  - Is used to read the partitionKeyRanges for split proofing
   * @param query          - A SQL query.
   * @param options        - Represents the feed options.
   * @param fetchFunctions - A function to retrieve each page of data.
   *                          An array of functions may be used to query more than one partition.
   * @hidden
   */
  constructor(options, fetchFunctions) {
    this.resources = [];
    this.currentIndex = 0;
    this.currentPartitionIndex = 0;
    this.fetchFunctions = Array.isArray(fetchFunctions) ? fetchFunctions : [fetchFunctions];
    this.options = options || {};
    this.continuationToken = this.options.continuationToken || this.options.continuation || null;
    this.state = _DefaultQueryExecutionContext.STATES.start;
  }
  /**
   * Execute a provided callback on the next element in the execution context.
   */
  async nextItem(diagnosticNode) {
    ++this.currentIndex;
    const response = await this.current(diagnosticNode);
    return response;
  }
  /**
   * Retrieve the current element on the execution context.
   */
  async current(diagnosticNode) {
    if (this.currentIndex < this.resources.length) {
      return {
        result: this.resources[this.currentIndex],
        headers: getInitialHeader()
      };
    }
    if (this._canFetchMore()) {
      const { result: resources, headers } = await this.fetchMore(diagnosticNode);
      this.resources = resources;
      if (this.resources.length === 0) {
        if (!this.continuationToken && this.currentPartitionIndex >= this.fetchFunctions.length) {
          this.state = _DefaultQueryExecutionContext.STATES.ended;
          return { result: void 0, headers };
        } else {
          return this.current(diagnosticNode);
        }
      }
      return { result: this.resources[this.currentIndex], headers };
    } else {
      this.state = _DefaultQueryExecutionContext.STATES.ended;
      return {
        result: void 0,
        headers: getInitialHeader()
      };
    }
  }
  /**
   * Determine if there are still remaining resources to processs based on
   * the value of the continuation token or the elements remaining on the current batch in the execution context.
   *
   * @returns true if there is other elements to process in the DefaultQueryExecutionContext.
   */
  hasMoreResults() {
    return this.state === _DefaultQueryExecutionContext.STATES.start || this.continuationToken !== void 0 || this.currentIndex < this.resources.length - 1 || this.currentPartitionIndex < this.fetchFunctions.length;
  }
  /**
   * Fetches the next batch of the feed and pass them as an array to a callback
   */
  async fetchMore(diagnosticNode) {
    return addDignosticChild(async (childDiagnosticNode) => {
      if (this.currentPartitionIndex >= this.fetchFunctions.length) {
        return {
          headers: getInitialHeader(),
          result: void 0
        };
      }
      const originalContinuation = this.options.continuationToken || this.options.continuation;
      this.options.continuationToken = this.continuationToken;
      if (this.currentPartitionIndex >= this.fetchFunctions.length) {
        return {
          headers: getInitialHeader(),
          result: void 0
        };
      }
      let resources;
      let responseHeaders;
      try {
        let p;
        if (this.nextFetchFunction !== void 0) {
          logger2.verbose("using prefetch");
          p = this.nextFetchFunction;
          this.nextFetchFunction = void 0;
        } else {
          logger2.verbose("using fresh fetch");
          p = this.fetchFunctions[this.currentPartitionIndex](childDiagnosticNode, this.options);
        }
        const response = await p;
        resources = response.result;
        childDiagnosticNode.recordQueryResult(resources, CosmosDbDiagnosticLevel.debugUnsafe);
        responseHeaders = response.headers;
        this.continuationToken = responseHeaders[Constants.HttpHeaders.Continuation];
        if (!this.continuationToken) {
          ++this.currentPartitionIndex;
        }
        if (this.options && this.options.bufferItems === true) {
          const fetchFunction = this.fetchFunctions[this.currentPartitionIndex];
          this.nextFetchFunction = fetchFunction ? fetchFunction(childDiagnosticNode, Object.assign(Object.assign({}, this.options), { continuationToken: this.continuationToken })) : void 0;
        }
      } catch (err) {
        this.state = _DefaultQueryExecutionContext.STATES.ended;
        throw err;
      }
      this.state = _DefaultQueryExecutionContext.STATES.inProgress;
      this.currentIndex = 0;
      this.options.continuationToken = originalContinuation;
      this.options.continuation = originalContinuation;
      if (Constants.HttpHeaders.QueryMetrics in responseHeaders) {
        const delimitedString = responseHeaders[Constants.HttpHeaders.QueryMetrics];
        let queryMetrics = QueryMetrics.createFromDelimitedString(delimitedString);
        if (Constants.HttpHeaders.RequestCharge in responseHeaders) {
          const requestCharge = Number(responseHeaders[Constants.HttpHeaders.RequestCharge]) || 0;
          queryMetrics = new QueryMetrics(queryMetrics.retrievedDocumentCount, queryMetrics.retrievedDocumentSize, queryMetrics.outputDocumentCount, queryMetrics.outputDocumentSize, queryMetrics.indexHitDocumentCount, queryMetrics.totalQueryExecutionTime, queryMetrics.queryPreparationTimes, queryMetrics.indexLookupTime, queryMetrics.documentLoadTime, queryMetrics.vmExecutionTime, queryMetrics.runtimeExecutionTimes, queryMetrics.documentWriteTime, new ClientSideMetrics(requestCharge));
        }
        responseHeaders[Constants.HttpHeaders.QueryMetrics] = {};
        responseHeaders[Constants.HttpHeaders.QueryMetrics]["0"] = queryMetrics;
      }
      return { result: resources, headers: responseHeaders };
    }, diagnosticNode, DiagnosticNodeType.DEFAULT_QUERY_NODE, {
      queryMethodIdentifier: "fetchMore"
    });
  }
  _canFetchMore() {
    const res = this.state === _DefaultQueryExecutionContext.STATES.start || this.continuationToken && this.state === _DefaultQueryExecutionContext.STATES.inProgress || this.currentPartitionIndex < this.fetchFunctions.length && this.state === _DefaultQueryExecutionContext.STATES.inProgress;
    return res;
  }
};
DefaultQueryExecutionContext.STATES = STATES;

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/Aggregators/AverageAggregator.js
var AverageAggregator = class {
  /**
   * Add the provided item to aggregation result.
   */
  aggregate(other) {
    if (other == null || other.sum == null) {
      return;
    }
    if (this.sum == null) {
      this.sum = 0;
      this.count = 0;
    }
    this.sum += other.sum;
    this.count += other.count;
  }
  /**
   * Get the aggregation result.
   */
  getResult() {
    if (this.sum == null || this.count <= 0) {
      return void 0;
    }
    return this.sum / this.count;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/Aggregators/CountAggregator.js
var CountAggregator = class {
  /**
   * Represents an aggregator for COUNT operator.
   * @hidden
   */
  constructor() {
    this.value = 0;
  }
  /**
   * Add the provided item to aggregation result.
   */
  aggregate(other) {
    this.value += other;
  }
  /**
   * Get the aggregation result.
   */
  getResult() {
    return this.value;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/orderByDocumentProducerComparator.js
var TYPEORDCOMPARATOR = Object.freeze({
  NoValue: {
    ord: 0
  },
  undefined: {
    ord: 1
  },
  boolean: {
    ord: 2,
    compFunc: (a, b) => {
      return a === b ? 0 : a > b ? 1 : -1;
    }
  },
  number: {
    ord: 4,
    compFunc: (a, b) => {
      return a === b ? 0 : a > b ? 1 : -1;
    }
  },
  string: {
    ord: 5,
    compFunc: (a, b) => {
      return a === b ? 0 : a > b ? 1 : -1;
    }
  }
});
var OrderByDocumentProducerComparator = class {
  constructor(sortOrder) {
    this.sortOrder = sortOrder;
  }
  // TODO: This should be an enum
  targetPartitionKeyRangeDocProdComparator(docProd1, docProd2) {
    const a = docProd1.getTargetParitionKeyRange()["minInclusive"];
    const b = docProd2.getTargetParitionKeyRange()["minInclusive"];
    return a === b ? 0 : a > b ? 1 : -1;
  }
  compare(docProd1, docProd2) {
    if (docProd1.gotSplit()) {
      return -1;
    }
    if (docProd2.gotSplit()) {
      return 1;
    }
    const orderByItemsRes1 = this.getOrderByItems(docProd1.peekBufferedItems()[0]);
    const orderByItemsRes2 = this.getOrderByItems(docProd2.peekBufferedItems()[0]);
    this.validateOrderByItems(orderByItemsRes1, orderByItemsRes2);
    for (let i = 0; i < orderByItemsRes1.length; i++) {
      const compRes = this.compareOrderByItem(orderByItemsRes1[i], orderByItemsRes2[i]);
      if (compRes !== 0) {
        if (this.sortOrder[i] === "Ascending") {
          return compRes;
        } else if (this.sortOrder[i] === "Descending") {
          return -compRes;
        }
      }
    }
    return this.targetPartitionKeyRangeDocProdComparator(docProd1, docProd2);
  }
  // TODO: This smells funny
  compareValue(item1, type1, item2, type2) {
    if (type1 === "object" || type2 === "object") {
      throw new Error("Tried to compare an object type");
    }
    const type1Ord = TYPEORDCOMPARATOR[type1].ord;
    const type2Ord = TYPEORDCOMPARATOR[type2].ord;
    const typeCmp = type1Ord - type2Ord;
    if (typeCmp !== 0) {
      return typeCmp;
    }
    if (type1Ord === TYPEORDCOMPARATOR["undefined"].ord || type1Ord === TYPEORDCOMPARATOR["NoValue"].ord) {
      return 0;
    }
    const compFunc = TYPEORDCOMPARATOR[type1].compFunc;
    if (typeof compFunc === "undefined") {
      throw new Error("Cannot find the comparison function");
    }
    return compFunc(item1, item2);
  }
  compareOrderByItem(orderByItem1, orderByItem2) {
    const type1 = this.getType(orderByItem1);
    const type2 = this.getType(orderByItem2);
    return this.compareValue(orderByItem1["item"], type1, orderByItem2["item"], type2);
  }
  validateOrderByItems(res1, res2) {
    if (res1.length !== res2.length) {
      throw new Error(`Expected ${res1.length}, but got ${res2.length}.`);
    }
    if (res1.length !== this.sortOrder.length) {
      throw new Error("orderByItems cannot have a different size than sort orders.");
    }
    for (let i = 0; i < this.sortOrder.length; i++) {
      const type1 = this.getType(res1[i]);
      const type2 = this.getType(res2[i]);
      if (type1 !== type2) {
        throw new Error(`Expected ${type1}, but got ${type2}. Cannot execute cross partition order-by queries on mixed types. Consider filtering your query using IS_STRING or IS_NUMBER to get around this exception.`);
      }
    }
  }
  getType(orderByItem) {
    if (orderByItem === void 0 || orderByItem.item === void 0) {
      return "NoValue";
    }
    const type = typeof orderByItem.item;
    if (TYPEORDCOMPARATOR[type] === void 0) {
      throw new Error(`unrecognizable type ${type}`);
    }
    return type;
  }
  getOrderByItems(res) {
    return res["orderByItems"];
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/Aggregators/MaxAggregator.js
var MaxAggregator = class {
  /**
   * Represents an aggregator for MAX operator.
   * @hidden
   */
  constructor() {
    this.value = void 0;
    this.comparer = new OrderByDocumentProducerComparator(["Ascending"]);
  }
  /**
   * Add the provided item to aggregation result.
   */
  aggregate(other) {
    if (this.value === void 0) {
      this.value = other.max;
    } else if (this.comparer.compareValue(other.max, typeof other.max, this.value, typeof this.value) > 0) {
      this.value = other.max;
    }
  }
  /**
   * Get the aggregation result.
   */
  getResult() {
    return this.value;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/Aggregators/MinAggregator.js
var MinAggregator = class {
  /**
   * Represents an aggregator for MIN operator.
   * @hidden
   */
  constructor() {
    this.value = void 0;
    this.comparer = new OrderByDocumentProducerComparator(["Ascending"]);
  }
  /**
   * Add the provided item to aggregation result.
   */
  aggregate(other) {
    if (this.value === void 0) {
      this.value = other.min;
    } else {
      const otherType = other.min === null ? "NoValue" : typeof other.min;
      const thisType = this.value === null ? "NoValue" : typeof this.value;
      if (this.comparer.compareValue(other.min, otherType, this.value, thisType) < 0) {
        this.value = other.min;
      }
    }
  }
  /**
   * Get the aggregation result.
   */
  getResult() {
    return this.value;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/Aggregators/SumAggregator.js
var SumAggregator = class {
  /**
   * Add the provided item to aggregation result.
   */
  aggregate(other) {
    if (other === void 0) {
      return;
    }
    if (this.sum === void 0) {
      this.sum = other;
    } else {
      this.sum += other;
    }
  }
  /**
   * Get the aggregation result.
   */
  getResult() {
    return this.sum;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/Aggregators/StaticValueAggregator.js
var StaticValueAggregator = class {
  aggregate(other) {
    if (this.value === void 0) {
      this.value = other;
    }
  }
  getResult() {
    return this.value;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/Aggregators/index.js
function createAggregator(aggregateType) {
  switch (aggregateType) {
    case "Average":
      return new AverageAggregator();
    case "Count":
      return new CountAggregator();
    case "Max":
      return new MaxAggregator();
    case "Min":
      return new MinAggregator();
    case "Sum":
      return new SumAggregator();
    default:
      return new StaticValueAggregator();
  }
}

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/FetchResult.js
var FetchResultType;
(function(FetchResultType2) {
  FetchResultType2[FetchResultType2["Done"] = 0] = "Done";
  FetchResultType2[FetchResultType2["Exception"] = 1] = "Exception";
  FetchResultType2[FetchResultType2["Result"] = 2] = "Result";
})(FetchResultType || (FetchResultType = {}));
var FetchResult = class {
  /**
   * Wraps fetch results for the document producer.
   * This allows the document producer to buffer exceptions so that actual results don't get flushed during splits.
   *
   * @param feedReponse - The response the document producer got back on a successful fetch
   * @param error - The exception meant to be buffered on an unsuccessful fetch
   * @hidden
   */
  constructor(feedResponse, error) {
    if (feedResponse !== void 0) {
      this.feedResponse = feedResponse;
      this.fetchResultType = FetchResultType.Result;
    } else {
      this.error = error;
      this.fetchResultType = FetchResultType.Exception;
    }
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/documentProducer.js
var DocumentProducer = class _DocumentProducer {
  /**
   * Provides the Target Partition Range Query Execution Context.
   * @param clientContext  - The service endpoint to use to create the client.
   * @param collectionLink - Represents collection link
   * @param query          - A SQL query.
   * @param targetPartitionKeyRange - Query Target Partition key Range
   * @hidden
   */
  constructor(clientContext, collectionLink, query, targetPartitionKeyRange, options) {
    this.clientContext = clientContext;
    this.generation = 0;
    this.fetchFunction = async (diagnosticNode, options2) => {
      const path = getPathFromLink(this.collectionLink, ResourceType.item);
      diagnosticNode.addData({ partitionKeyRangeId: this.targetPartitionKeyRange.id });
      const id = getIdFromLink(this.collectionLink);
      return this.clientContext.queryFeed({
        path,
        resourceType: ResourceType.item,
        resourceId: id,
        resultFn: (result) => result.Documents,
        query: this.query,
        options: options2,
        diagnosticNode,
        partitionKeyRangeId: this.targetPartitionKeyRange["id"]
      });
    };
    this.collectionLink = collectionLink;
    this.query = query;
    this.targetPartitionKeyRange = targetPartitionKeyRange;
    this.fetchResults = [];
    this.allFetched = false;
    this.err = void 0;
    this.previousContinuationToken = void 0;
    this.continuationToken = void 0;
    this.respHeaders = getInitialHeader();
    this.internalExecutionContext = new DefaultQueryExecutionContext(options, this.fetchFunction);
  }
  /**
   * Synchronously gives the contiguous buffered results (stops at the first non result) if any
   * @returns buffered current items if any
   * @hidden
   */
  peekBufferedItems() {
    const bufferedResults = [];
    for (let i = 0, done = false; i < this.fetchResults.length && !done; i++) {
      const fetchResult = this.fetchResults[i];
      switch (fetchResult.fetchResultType) {
        case FetchResultType.Done:
          done = true;
          break;
        case FetchResultType.Exception:
          done = true;
          break;
        case FetchResultType.Result:
          bufferedResults.push(fetchResult.feedResponse);
          break;
      }
    }
    return bufferedResults;
  }
  hasMoreResults() {
    return this.internalExecutionContext.hasMoreResults() || this.fetchResults.length !== 0;
  }
  gotSplit() {
    const fetchResult = this.fetchResults[0];
    if (fetchResult.fetchResultType === FetchResultType.Exception) {
      if (_DocumentProducer._needPartitionKeyRangeCacheRefresh(fetchResult.error)) {
        return true;
      }
    }
    return false;
  }
  _getAndResetActiveResponseHeaders() {
    const ret = this.respHeaders;
    this.respHeaders = getInitialHeader();
    return ret;
  }
  _updateStates(err, allFetched) {
    if (err) {
      this.err = err;
      return;
    }
    if (allFetched) {
      this.allFetched = true;
    }
    if (this.internalExecutionContext.continuationToken === this.continuationToken) {
      return;
    }
    this.previousContinuationToken = this.continuationToken;
    this.continuationToken = this.internalExecutionContext.continuationToken;
  }
  static _needPartitionKeyRangeCacheRefresh(error) {
    return error.code === StatusCodes.Gone && "substatus" in error && error["substatus"] === SubStatusCodes.PartitionKeyRangeGone;
  }
  /**
   * Fetches and bufferes the next page of results and executes the given callback
   */
  async bufferMore(diagnosticNode) {
    if (this.err) {
      throw this.err;
    }
    try {
      const { result: resources, headers: headerResponse } = await this.internalExecutionContext.fetchMore(diagnosticNode);
      ++this.generation;
      this._updateStates(void 0, resources === void 0);
      if (resources !== void 0) {
        resources.forEach((element) => {
          this.fetchResults.push(new FetchResult(element, void 0));
        });
      }
      if (headerResponse != null && Constants.HttpHeaders.QueryMetrics in headerResponse) {
        const queryMetrics = headerResponse[Constants.HttpHeaders.QueryMetrics]["0"];
        headerResponse[Constants.HttpHeaders.QueryMetrics] = {};
        headerResponse[Constants.HttpHeaders.QueryMetrics][this.targetPartitionKeyRange.id] = queryMetrics;
      }
      return { result: resources, headers: headerResponse };
    } catch (err) {
      if (_DocumentProducer._needPartitionKeyRangeCacheRefresh(err)) {
        const bufferedError = new FetchResult(void 0, err);
        this.fetchResults.push(bufferedError);
        return {
          result: [bufferedError],
          headers: err.headers
        };
      } else {
        this._updateStates(err, err.resources === void 0);
        throw err;
      }
    }
  }
  /**
   * Synchronously gives the bufferend current item if any
   * @returns buffered current item if any
   * @hidden
   */
  getTargetParitionKeyRange() {
    return this.targetPartitionKeyRange;
  }
  /**
   * Fetches the next element in the DocumentProducer.
   */
  async nextItem(diagnosticNode) {
    if (this.err) {
      this._updateStates(this.err, void 0);
      throw this.err;
    }
    try {
      const { result, headers } = await this.current(diagnosticNode);
      const fetchResult = this.fetchResults.shift();
      this._updateStates(void 0, result === void 0);
      if (fetchResult.feedResponse !== result) {
        throw new Error(`Expected ${fetchResult.feedResponse} to equal ${result}`);
      }
      switch (fetchResult.fetchResultType) {
        case FetchResultType.Done:
          return { result: void 0, headers };
        case FetchResultType.Exception:
          fetchResult.error.headers = headers;
          throw fetchResult.error;
        case FetchResultType.Result:
          return { result: fetchResult.feedResponse, headers };
      }
    } catch (err) {
      this._updateStates(err, err.item === void 0);
      throw err;
    }
  }
  /**
   * Retrieve the current element on the DocumentProducer.
   */
  async current(diagnosticNode) {
    if (this.fetchResults.length > 0) {
      const fetchResult = this.fetchResults[0];
      switch (fetchResult.fetchResultType) {
        case FetchResultType.Done:
          return {
            result: void 0,
            headers: this._getAndResetActiveResponseHeaders()
          };
        case FetchResultType.Exception:
          fetchResult.error.headers = this._getAndResetActiveResponseHeaders();
          throw fetchResult.error;
        case FetchResultType.Result:
          return {
            result: fetchResult.feedResponse,
            headers: this._getAndResetActiveResponseHeaders()
          };
      }
    }
    if (this.allFetched) {
      return {
        result: void 0,
        headers: this._getAndResetActiveResponseHeaders()
      };
    }
    const { result, headers } = await this.bufferMore(diagnosticNode);
    mergeHeaders(this.respHeaders, headers);
    if (result === void 0) {
      return { result: void 0, headers: this.respHeaders };
    }
    return this.current(diagnosticNode);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/parallelQueryExecutionContextBase.js
var import_priorityqueuejs = __toESM(require_priorityqueuejs());
var import_semaphore = __toESM(require_semaphore());

// node_modules/@azure/cosmos/dist-esm/src/routing/QueryRange.js
var QueryRange = class _QueryRange {
  /**
   * Represents a QueryRange.
   *
   * @param rangeMin                - min
   * @param rangeMin                - max
   * @param isMinInclusive         - isMinInclusive
   * @param isMaxInclusive         - isMaxInclusive
   * @hidden
   */
  constructor(rangeMin, rangeMax, isMinInclusive, isMaxInclusive) {
    this.min = rangeMin;
    this.max = rangeMax;
    this.isMinInclusive = isMinInclusive;
    this.isMaxInclusive = isMaxInclusive;
  }
  overlaps(other) {
    const range1 = this;
    const range2 = other;
    if (range1 === void 0 || range2 === void 0) {
      return false;
    }
    if (range1.isEmpty() || range2.isEmpty()) {
      return false;
    }
    if (range1.min <= range2.max || range2.min <= range1.max) {
      if (range1.min === range2.max && !(range1.isMinInclusive && range2.isMaxInclusive) || range2.min === range1.max && !(range2.isMinInclusive && range1.isMaxInclusive)) {
        return false;
      }
      return true;
    }
    return false;
  }
  isFullRange() {
    return this.min === Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey && this.max === Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey && this.isMinInclusive === true && this.isMaxInclusive === false;
  }
  isEmpty() {
    return !(this.isMinInclusive && this.isMaxInclusive) && this.min === this.max;
  }
  /**
   * Parse a QueryRange from a partitionKeyRange
   * @returns QueryRange
   * @hidden
   */
  static parsePartitionKeyRange(partitionKeyRange) {
    return new _QueryRange(partitionKeyRange[Constants.PartitionKeyRange.MinInclusive], partitionKeyRange[Constants.PartitionKeyRange.MaxExclusive], true, false);
  }
  /**
   * Parse a QueryRange from a dictionary
   * @returns QueryRange
   * @hidden
   */
  static parseFromDict(queryRangeDict) {
    return new _QueryRange(queryRangeDict.min, queryRangeDict.max, queryRangeDict.isMinInclusive, queryRangeDict.isMaxInclusive);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/routing/inMemoryCollectionRoutingMap.js
var InMemoryCollectionRoutingMap = class {
  /**
   * Represents a InMemoryCollectionRoutingMap Object,
   * Stores partition key ranges in an efficient way with some additional information and provides
   * convenience methods for working with set of ranges.
   */
  constructor(orderedPartitionKeyRanges, orderedPartitionInfo) {
    this.orderedPartitionKeyRanges = orderedPartitionKeyRanges;
    this.orderedRanges = orderedPartitionKeyRanges.map((pkr) => {
      return new QueryRange(pkr[Constants.PartitionKeyRange.MinInclusive], pkr[Constants.PartitionKeyRange.MaxExclusive], true, false);
    });
    this.orderedPartitionInfo = orderedPartitionInfo;
  }
  getOrderedParitionKeyRanges() {
    return this.orderedPartitionKeyRanges;
  }
  getOverlappingRanges(providedQueryRanges) {
    const pqr = Array.isArray(providedQueryRanges) ? providedQueryRanges : [providedQueryRanges];
    const minToPartitionRange = {};
    for (const queryRange of pqr) {
      if (queryRange.isEmpty()) {
        continue;
      }
      if (queryRange.isFullRange()) {
        return this.orderedPartitionKeyRanges;
      }
      const minIndex = this.orderedRanges.findIndex((range) => {
        if (queryRange.min > range.min && queryRange.min < range.max) {
          return true;
        }
        if (queryRange.min === range.min) {
          return true;
        }
        if (queryRange.min === range.max) {
          return true;
        }
      });
      if (minIndex < 0) {
        throw new Error("error in collection routing map, queried value is less than the start range.");
      }
      let maxIndex;
      for (let i = this.orderedRanges.length - 1; i >= 0; i--) {
        const range = this.orderedRanges[i];
        if (queryRange.max > range.min && queryRange.max < range.max) {
          maxIndex = i;
          break;
        }
        if (queryRange.max === range.min) {
          maxIndex = i;
          break;
        }
        if (queryRange.max === range.max) {
          maxIndex = i;
          break;
        }
      }
      if (maxIndex > this.orderedRanges.length) {
        throw new Error("error in collection routing map, queried value is greater than the end range.");
      }
      for (let j = minIndex; j < maxIndex + 1; j++) {
        if (queryRange.overlaps(this.orderedRanges[j])) {
          minToPartitionRange[this.orderedPartitionKeyRanges[j][Constants.PartitionKeyRange.MinInclusive]] = this.orderedPartitionKeyRanges[j];
        }
      }
    }
    const overlappingPartitionKeyRanges = Object.keys(minToPartitionRange).map((k) => minToPartitionRange[k]);
    return overlappingPartitionKeyRanges.sort((a, b) => {
      return a[Constants.PartitionKeyRange.MinInclusive].localeCompare(b[Constants.PartitionKeyRange.MinInclusive]);
    });
  }
};

// node_modules/@azure/cosmos/dist-esm/src/routing/CollectionRoutingMapFactory.js
function compareRanges(a, b) {
  const aVal = a[0][Constants.PartitionKeyRange.MinInclusive];
  const bVal = b[0][Constants.PartitionKeyRange.MinInclusive];
  if (aVal > bVal) {
    return 1;
  }
  if (aVal < bVal) {
    return -1;
  }
  return 0;
}
function createCompleteRoutingMap(partitionKeyRangeInfoTuppleList) {
  const rangeById = {};
  const rangeByInfo = {};
  let sortedRanges = [];
  for (const r of partitionKeyRangeInfoTuppleList) {
    rangeById[r[0][Constants.PartitionKeyRange.Id]] = r;
    rangeByInfo[r[1]] = r[0];
    sortedRanges.push(r);
  }
  sortedRanges = sortedRanges.sort(compareRanges);
  const partitionKeyOrderedRange = sortedRanges.map((r) => r[0]);
  const orderedPartitionInfo = sortedRanges.map((r) => r[1]);
  if (!isCompleteSetOfRange(partitionKeyOrderedRange)) {
    return void 0;
  }
  return new InMemoryCollectionRoutingMap(partitionKeyOrderedRange, orderedPartitionInfo);
}
function isCompleteSetOfRange(partitionKeyOrderedRange) {
  let isComplete = false;
  if (partitionKeyOrderedRange.length > 0) {
    const firstRange = partitionKeyOrderedRange[0];
    const lastRange = partitionKeyOrderedRange[partitionKeyOrderedRange.length - 1];
    isComplete = firstRange[Constants.PartitionKeyRange.MinInclusive] === Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey;
    isComplete = isComplete && lastRange[Constants.PartitionKeyRange.MaxExclusive] === Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey;
    for (let i = 1; i < partitionKeyOrderedRange.length; i++) {
      const previousRange = partitionKeyOrderedRange[i - 1];
      const currentRange = partitionKeyOrderedRange[i];
      isComplete = isComplete && previousRange[Constants.PartitionKeyRange.MaxExclusive] === currentRange[Constants.PartitionKeyRange.MinInclusive];
      if (!isComplete) {
        if (previousRange[Constants.PartitionKeyRange.MaxExclusive] > currentRange[Constants.PartitionKeyRange.MinInclusive]) {
          throw Error("Ranges overlap");
        }
        break;
      }
    }
  }
  return isComplete;
}

// node_modules/@azure/cosmos/dist-esm/src/routing/partitionKeyRangeCache.js
var PartitionKeyRangeCache = class {
  constructor(clientContext) {
    this.clientContext = clientContext;
    this.collectionRoutingMapByCollectionId = {};
  }
  /**
   * Finds or Instantiates the requested Collection Routing Map
   * @param collectionLink - Requested collectionLink
   * @hidden
   */
  async onCollectionRoutingMap(collectionLink, diagnosticNode, forceRefresh = false) {
    const collectionId = getIdFromLink(collectionLink);
    if (this.collectionRoutingMapByCollectionId[collectionId] === void 0 || forceRefresh) {
      this.collectionRoutingMapByCollectionId[collectionId] = this.requestCollectionRoutingMap(collectionLink, diagnosticNode);
    }
    return this.collectionRoutingMapByCollectionId[collectionId];
  }
  /**
   * Given the query ranges and a collection, invokes the callback on the list of overlapping partition key ranges
   * @hidden
   */
  async getOverlappingRanges(collectionLink, queryRange, diagnosticNode, forceRefresh = false) {
    const crm = await this.onCollectionRoutingMap(collectionLink, diagnosticNode, forceRefresh);
    return crm.getOverlappingRanges(queryRange);
  }
  async requestCollectionRoutingMap(collectionLink, diagnosticNode) {
    const { resources } = await withMetadataDiagnostics(async (metadataDiagnostics) => {
      return this.clientContext.queryPartitionKeyRanges(collectionLink).fetchAllInternal(metadataDiagnostics);
    }, diagnosticNode, MetadataLookUpType.PartitionKeyRangeLookUp);
    return createCompleteRoutingMap(resources.map((r) => [r, true]));
  }
};

// node_modules/@azure/cosmos/dist-esm/src/routing/smartRoutingMapProvider.js
var PARITIONKEYRANGE = Constants.PartitionKeyRange;
var SmartRoutingMapProvider = class _SmartRoutingMapProvider {
  constructor(clientContext) {
    this.partitionKeyRangeCache = new PartitionKeyRangeCache(clientContext);
  }
  static _secondRangeIsAfterFirstRange(range1, range2) {
    if (typeof range1.max === "undefined") {
      throw new Error("range1 must have max");
    }
    if (typeof range2.min === "undefined") {
      throw new Error("range2 must have min");
    }
    if (range1.max > range2.min) {
      return false;
    } else {
      if (range1.max === range2.min && range1.isMaxInclusive && range2.isMinInclusive) {
        return false;
      }
      return true;
    }
  }
  static _isSortedAndNonOverlapping(ranges) {
    for (let idx = 1; idx < ranges.length; idx++) {
      const previousR = ranges[idx - 1];
      const r = ranges[idx];
      if (!this._secondRangeIsAfterFirstRange(previousR, r)) {
        return false;
      }
    }
    return true;
  }
  static _stringMax(a, b) {
    return a >= b ? a : b;
  }
  static _stringCompare(a, b) {
    return a === b ? 0 : a > b ? 1 : -1;
  }
  static _subtractRange(r, partitionKeyRange) {
    const left = this._stringMax(partitionKeyRange[PARITIONKEYRANGE.MaxExclusive], r.min);
    const leftInclusive = this._stringCompare(left, r.min) === 0 ? r.isMinInclusive : false;
    return new QueryRange(left, r.max, leftInclusive, r.isMaxInclusive);
  }
  /**
   * Given the sorted ranges and a collection, invokes the callback on the list of overlapping partition key ranges
   * @param callback - Function execute on the overlapping partition key ranges result,
   *                   takes two parameters error, partition key ranges
   * @hidden
   */
  async getOverlappingRanges(collectionLink, sortedRanges, diagnosticNode) {
    if (!_SmartRoutingMapProvider._isSortedAndNonOverlapping(sortedRanges)) {
      throw new Error("the list of ranges is not a non-overlapping sorted ranges");
    }
    let partitionKeyRanges = [];
    if (sortedRanges.length === 0) {
      return partitionKeyRanges;
    }
    const collectionRoutingMap = await this.partitionKeyRangeCache.onCollectionRoutingMap(collectionLink, diagnosticNode);
    let index = 0;
    let currentProvidedRange = sortedRanges[index];
    for (; ; ) {
      if (currentProvidedRange.isEmpty()) {
        if (++index >= sortedRanges.length) {
          return partitionKeyRanges;
        }
        currentProvidedRange = sortedRanges[index];
        continue;
      }
      let queryRange;
      if (partitionKeyRanges.length > 0) {
        queryRange = _SmartRoutingMapProvider._subtractRange(currentProvidedRange, partitionKeyRanges[partitionKeyRanges.length - 1]);
      } else {
        queryRange = currentProvidedRange;
      }
      const overlappingRanges = collectionRoutingMap.getOverlappingRanges(queryRange);
      if (overlappingRanges.length <= 0) {
        throw new Error(`error: returned overlapping ranges for queryRange ${queryRange} is empty`);
      }
      partitionKeyRanges = partitionKeyRanges.concat(overlappingRanges);
      const lastKnownTargetRange = QueryRange.parsePartitionKeyRange(partitionKeyRanges[partitionKeyRanges.length - 1]);
      if (!lastKnownTargetRange) {
        throw new Error("expected lastKnowTargetRange to be truthy");
      }
      if (_SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) > 0) {
        throw new Error(`error: returned overlapping ranges ${overlappingRanges}         does not contain the requested range ${queryRange}`);
      }
      if (++index >= sortedRanges.length) {
        return partitionKeyRanges;
      }
      currentProvidedRange = sortedRanges[index];
      while (_SmartRoutingMapProvider._stringCompare(currentProvidedRange.max, lastKnownTargetRange.max) <= 0) {
        if (++index >= sortedRanges.length) {
          return partitionKeyRanges;
        }
        currentProvidedRange = sortedRanges[index];
      }
    }
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/parallelQueryExecutionContextBase.js
var logger3 = createClientLogger("parallelQueryExecutionContextBase");
var ParallelQueryExecutionContextBaseStates;
(function(ParallelQueryExecutionContextBaseStates2) {
  ParallelQueryExecutionContextBaseStates2["started"] = "started";
  ParallelQueryExecutionContextBaseStates2["inProgress"] = "inProgress";
  ParallelQueryExecutionContextBaseStates2["ended"] = "ended";
})(ParallelQueryExecutionContextBaseStates || (ParallelQueryExecutionContextBaseStates = {}));
var ParallelQueryExecutionContextBase = class _ParallelQueryExecutionContextBase {
  /**
   * Provides the ParallelQueryExecutionContextBase.
   * This is the base class that ParallelQueryExecutionContext and OrderByQueryExecutionContext will derive from.
   *
   * When handling a parallelized query, it instantiates one instance of
   * DocumentProcuder per target partition key range and aggregates the result of each.
   *
   * @param clientContext - The service endpoint to use to create the client.
   * @param collectionLink - The Collection Link
   * @param options - Represents the feed options.
   * @param partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo
   * @hidden
   */
  constructor(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo) {
    this.clientContext = clientContext;
    this.collectionLink = collectionLink;
    this.query = query;
    this.options = options;
    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;
    this.clientContext = clientContext;
    this.collectionLink = collectionLink;
    this.query = query;
    this.options = options;
    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;
    this.diagnosticNodeWrapper = {
      consumed: false,
      diagnosticNode: new DiagnosticNodeInternal(clientContext.diagnosticLevel, DiagnosticNodeType.PARALLEL_QUERY_NODE, null)
    };
    this.diagnosticNodeWrapper.diagnosticNode.addData({ stateful: true });
    this.err = void 0;
    this.state = _ParallelQueryExecutionContextBase.STATES.started;
    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);
    this.sortOrders = this.partitionedQueryExecutionInfo.queryInfo.orderBy;
    this.requestContinuation = options ? options.continuationToken || options.continuation : null;
    this.respHeaders = getInitialHeader();
    this.orderByPQ = new import_priorityqueuejs.default((a, b) => this.documentProducerComparator(b, a));
    this.sem = (0, import_semaphore.default)(1);
    const createDocumentProducersAndFillUpPriorityQueueFunc = async () => {
      try {
        const targetPartitionRanges = await this._onTargetPartitionRanges();
        this.waitingForInternalExecutionContexts = targetPartitionRanges.length;
        const maxDegreeOfParallelism = options.maxDegreeOfParallelism === void 0 || options.maxDegreeOfParallelism < 1 ? targetPartitionRanges.length : Math.min(options.maxDegreeOfParallelism, targetPartitionRanges.length);
        logger3.info("Query starting against " + targetPartitionRanges.length + " ranges with parallelism of " + maxDegreeOfParallelism);
        const parallelismSem = (0, import_semaphore.default)(maxDegreeOfParallelism);
        let filteredPartitionKeyRanges = [];
        const targetPartitionQueryExecutionContextList = [];
        if (this.requestContinuation) {
          throw new Error("Continuation tokens are not yet supported for cross partition queries");
        } else {
          filteredPartitionKeyRanges = targetPartitionRanges;
        }
        filteredPartitionKeyRanges.forEach((partitionTargetRange) => {
          targetPartitionQueryExecutionContextList.push(this._createTargetPartitionQueryExecutionContext(partitionTargetRange));
        });
        targetPartitionQueryExecutionContextList.forEach((documentProducer) => {
          const throttledFunc = async () => {
            try {
              const { result: document, headers } = await documentProducer.current(this.getDiagnosticNode());
              this._mergeWithActiveResponseHeaders(headers);
              if (document === void 0) {
                return;
              }
              try {
                this.orderByPQ.enq(documentProducer);
              } catch (e) {
                this.err = e;
              }
            } catch (err) {
              this._mergeWithActiveResponseHeaders(err.headers);
              this.err = err;
            } finally {
              parallelismSem.leave();
              this._decrementInitiationLock();
            }
          };
          parallelismSem.take(throttledFunc);
        });
      } catch (err) {
        this.err = err;
        this.sem.leave();
        return;
      }
    };
    this.sem.take(createDocumentProducersAndFillUpPriorityQueueFunc);
  }
  _decrementInitiationLock() {
    this.waitingForInternalExecutionContexts = this.waitingForInternalExecutionContexts - 1;
    if (this.waitingForInternalExecutionContexts === 0) {
      this.sem.leave();
      if (this.orderByPQ.size() === 0) {
        this.state = _ParallelQueryExecutionContextBase.STATES.inProgress;
      }
    }
  }
  _mergeWithActiveResponseHeaders(headers) {
    mergeHeaders(this.respHeaders, headers);
  }
  _getAndResetActiveResponseHeaders() {
    const ret = this.respHeaders;
    this.respHeaders = getInitialHeader();
    return ret;
  }
  getDiagnosticNode() {
    return this.diagnosticNodeWrapper.diagnosticNode;
  }
  async _onTargetPartitionRanges() {
    const parsedRanges = this.partitionedQueryExecutionInfo.queryRanges;
    const queryRanges = parsedRanges.map((item) => QueryRange.parseFromDict(item));
    return this.routingProvider.getOverlappingRanges(this.collectionLink, queryRanges, this.getDiagnosticNode());
  }
  /**
   * Gets the replacement ranges for a partitionkeyrange that has been split
   */
  async _getReplacementPartitionKeyRanges(documentProducer) {
    const partitionKeyRange = documentProducer.targetPartitionKeyRange;
    this.routingProvider = new SmartRoutingMapProvider(this.clientContext);
    const queryRange = QueryRange.parsePartitionKeyRange(partitionKeyRange);
    return this.routingProvider.getOverlappingRanges(this.collectionLink, [queryRange], this.getDiagnosticNode());
  }
  // TODO: P0 Code smell - can barely tell what this is doing
  /**
   * Removes the current document producer from the priqueue,
   * replaces that document producer with child document producers,
   * then reexecutes the originFunction with the corrrected executionContext
   */
  async _repairExecutionContext(diagnosticNode, originFunction) {
    const parentDocumentProducer = this.orderByPQ.deq();
    try {
      const replacementPartitionKeyRanges = await this._getReplacementPartitionKeyRanges(parentDocumentProducer);
      const replacementDocumentProducers = [];
      replacementPartitionKeyRanges.forEach((partitionKeyRange) => {
        const replacementDocumentProducer = this._createTargetPartitionQueryExecutionContext(partitionKeyRange, parentDocumentProducer.continuationToken);
        replacementDocumentProducers.push(replacementDocumentProducer);
      });
      const checkAndEnqueueDocumentProducer = async (documentProducerToCheck, checkNextDocumentProducerCallback) => {
        try {
          const { result: afterItem } = await documentProducerToCheck.current(diagnosticNode);
          if (afterItem === void 0) {
          } else {
            this.orderByPQ.enq(documentProducerToCheck);
          }
          await checkNextDocumentProducerCallback();
        } catch (err) {
          this.err = err;
          return;
        }
      };
      const checkAndEnqueueDocumentProducers = async (rdp) => {
        if (rdp.length > 0) {
          const replacementDocumentProducer = rdp.shift();
          await checkAndEnqueueDocumentProducer(replacementDocumentProducer, async () => {
            await checkAndEnqueueDocumentProducers(rdp);
          });
        } else {
          return originFunction();
        }
      };
      await checkAndEnqueueDocumentProducers(replacementDocumentProducers);
    } catch (err) {
      this.err = err;
      throw err;
    }
  }
  static _needPartitionKeyRangeCacheRefresh(error) {
    return error.code === StatusCodes.Gone && "substatus" in error && error["substatus"] === SubStatusCodes.PartitionKeyRangeGone;
  }
  /**
   * Checks to see if the executionContext needs to be repaired.
   * if so it repairs the execution context and executes the ifCallback,
   * else it continues with the current execution context and executes the elseCallback
   */
  async _repairExecutionContextIfNeeded(diagnosticNode, ifCallback, elseCallback) {
    const documentProducer = this.orderByPQ.peek();
    try {
      await documentProducer.current(diagnosticNode);
      elseCallback();
    } catch (err) {
      if (_ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {
        return addDignosticChild((childNode) => this._repairExecutionContext(childNode, ifCallback), diagnosticNode, DiagnosticNodeType.QUERY_REPAIR_NODE);
      } else {
        this.err = err;
        throw err;
      }
    }
  }
  /**
   * Fetches the next element in the ParallelQueryExecutionContextBase.
   */
  async nextItem(diagnosticNode) {
    if (this.err) {
      throw this.err;
    }
    return new Promise((resolve, reject) => {
      this.sem.take(() => {
        if (!this.diagnosticNodeWrapper.consumed) {
          diagnosticNode.addChildNode(this.diagnosticNodeWrapper.diagnosticNode, CosmosDbDiagnosticLevel.debug, MetadataLookUpType.QueryPlanLookUp);
          this.diagnosticNodeWrapper.diagnosticNode = void 0;
          this.diagnosticNodeWrapper.consumed = true;
        } else {
          this.diagnosticNodeWrapper.diagnosticNode = diagnosticNode;
        }
        if (this.err) {
          this.sem.leave();
          this.err.headers = this._getAndResetActiveResponseHeaders();
          reject(this.err);
          return;
        }
        if (this.orderByPQ.size() === 0) {
          this.state = _ParallelQueryExecutionContextBase.STATES.ended;
          this.sem.leave();
          return resolve({
            result: void 0,
            headers: this._getAndResetActiveResponseHeaders()
          });
        }
        const ifCallback = () => {
          this.sem.leave();
          return resolve(this.nextItem(diagnosticNode));
        };
        const elseCallback = async () => {
          let documentProducer;
          try {
            documentProducer = this.orderByPQ.deq();
          } catch (e) {
            this.err = e;
            this.sem.leave();
            this.err.headers = this._getAndResetActiveResponseHeaders();
            reject(this.err);
            return;
          }
          let item;
          let headers;
          try {
            const response = await documentProducer.nextItem(diagnosticNode);
            item = response.result;
            headers = response.headers;
            this._mergeWithActiveResponseHeaders(headers);
            if (item === void 0) {
              this.err = new Error(`Extracted DocumentProducer from the priority queue                                             doesn't have any buffered item!`);
              this.sem.leave();
              return resolve({
                result: void 0,
                headers: this._getAndResetActiveResponseHeaders()
              });
            }
          } catch (err) {
            this.err = new Error(`Extracted DocumentProducer from the priority queue fails to get the                                     buffered item. Due to ${JSON.stringify(err)}`);
            this.err.headers = this._getAndResetActiveResponseHeaders();
            this.sem.leave();
            reject(this.err);
            return;
          }
          try {
            const { result: afterItem, headers: otherHeaders } = await documentProducer.current(diagnosticNode);
            this._mergeWithActiveResponseHeaders(otherHeaders);
            if (afterItem === void 0) {
            } else {
              try {
                const headItem = documentProducer.fetchResults[0];
                if (typeof headItem === "undefined") {
                  throw new Error("Extracted DocumentProducer from PQ is invalid state with no result!");
                }
                this.orderByPQ.enq(documentProducer);
              } catch (e) {
                this.err = e;
              }
            }
          } catch (err) {
            if (_ParallelQueryExecutionContextBase._needPartitionKeyRangeCacheRefresh(err)) {
              this.orderByPQ.enq(documentProducer);
            } else {
              this.err = err;
              reject(this.err);
            }
          } finally {
            this.sem.leave();
          }
          return resolve({
            result: item,
            headers: this._getAndResetActiveResponseHeaders()
          });
        };
        this._repairExecutionContextIfNeeded(diagnosticNode, ifCallback, elseCallback).catch(reject);
      });
    });
  }
  /**
   * Determine if there are still remaining resources to processs based on the value of the continuation
   * token or the elements remaining on the current batch in the QueryIterator.
   * @returns true if there is other elements to process in the ParallelQueryExecutionContextBase.
   */
  hasMoreResults() {
    return !(this.state === _ParallelQueryExecutionContextBase.STATES.ended || this.err !== void 0);
  }
  /**
   * Creates document producers
   */
  _createTargetPartitionQueryExecutionContext(partitionKeyTargetRange, continuationToken) {
    let rewrittenQuery = this.partitionedQueryExecutionInfo.queryInfo.rewrittenQuery;
    let sqlQuerySpec;
    const query = this.query;
    if (typeof query === "string") {
      sqlQuerySpec = { query };
    } else {
      sqlQuerySpec = query;
    }
    const formatPlaceHolder = "{documentdb-formattableorderbyquery-filter}";
    if (rewrittenQuery) {
      sqlQuerySpec = JSON.parse(JSON.stringify(sqlQuerySpec));
      rewrittenQuery = rewrittenQuery.replace(formatPlaceHolder, "true");
      sqlQuerySpec["query"] = rewrittenQuery;
    }
    const options = Object.assign({}, this.options);
    options.continuationToken = continuationToken;
    return new DocumentProducer(this.clientContext, this.collectionLink, sqlQuerySpec, partitionKeyTargetRange, options);
  }
};
ParallelQueryExecutionContextBase.STATES = ParallelQueryExecutionContextBaseStates;

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/parallelQueryExecutionContext.js
var ParallelQueryExecutionContext = class extends ParallelQueryExecutionContextBase {
  // Instance members are inherited
  // Overriding documentProducerComparator for ParallelQueryExecutionContexts
  /**
   * Provides a Comparator for document producers using the min value of the corresponding target partition.
   * @returns Comparator Function
   * @hidden
   */
  documentProducerComparator(docProd1, docProd2) {
    return docProd1.generation - docProd2.generation;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/orderByQueryExecutionContext.js
var OrderByQueryExecutionContext = class extends ParallelQueryExecutionContextBase {
  /**
   * Provides the OrderByQueryExecutionContext.
   * This class is capable of handling orderby queries and dervives from ParallelQueryExecutionContextBase.
   *
   * When handling a parallelized query, it instantiates one instance of
   * DocumentProcuder per target partition key range and aggregates the result of each.
   *
   * @param clientContext - The service endpoint to use to create the client.
   * @param collectionLink - The Collection Link
   * @param options - Represents the feed options.
   * @param partitionedQueryExecutionInfo - PartitionedQueryExecutionInfo
   * @hidden
   */
  constructor(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo) {
    super(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo);
    this.orderByComparator = new OrderByDocumentProducerComparator(this.sortOrders);
  }
  // Instance members are inherited
  // Overriding documentProducerComparator for OrderByQueryExecutionContexts
  /**
   * Provides a Comparator for document producers which respects orderby sort order.
   * @returns Comparator Function
   * @hidden
   */
  documentProducerComparator(docProd1, docProd2) {
    return this.orderByComparator.compare(docProd1, docProd2);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/EndpointComponent/OffsetLimitEndpointComponent.js
var OffsetLimitEndpointComponent = class {
  constructor(executionContext, offset, limit) {
    this.executionContext = executionContext;
    this.offset = offset;
    this.limit = limit;
  }
  async nextItem(diagnosticNode) {
    const aggregateHeaders = getInitialHeader();
    while (this.offset > 0) {
      const { headers } = await this.executionContext.nextItem(diagnosticNode);
      this.offset--;
      mergeHeaders(aggregateHeaders, headers);
    }
    if (this.limit > 0) {
      const { result, headers } = await this.executionContext.nextItem(diagnosticNode);
      this.limit--;
      mergeHeaders(aggregateHeaders, headers);
      return { result, headers: aggregateHeaders };
    }
    return {
      result: void 0,
      headers: getInitialHeader()
    };
  }
  hasMoreResults() {
    return (this.offset > 0 || this.limit > 0) && this.executionContext.hasMoreResults();
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/EndpointComponent/OrderByEndpointComponent.js
var OrderByEndpointComponent = class {
  /**
   * Represents an endpoint in handling an order by query. For each processed orderby
   * result it returns 'payload' item of the result
   *
   * @param executionContext - Underlying Execution Context
   * @hidden
   */
  constructor(executionContext) {
    this.executionContext = executionContext;
  }
  /**
   * Execute a provided function on the next element in the OrderByEndpointComponent.
   */
  async nextItem(diagnosticNode) {
    const { result: item, headers } = await this.executionContext.nextItem(diagnosticNode);
    return {
      result: item !== void 0 ? item.payload : void 0,
      headers
    };
  }
  /**
   * Determine if there are still remaining resources to processs.
   * @returns true if there is other elements to process in the OrderByEndpointComponent.
   */
  hasMoreResults() {
    return this.executionContext.hasMoreResults();
  }
};

// node_modules/@azure/cosmos/dist-esm/src/utils/digest.browser.js
async function digest(str) {
  const data = encodeUTF8(str);
  const hash = await globalCrypto.subtle.digest("SHA-256", data);
  return bufferToHex(hash);
}
function bufferToHex(buffer) {
  return Array.prototype.map.call(new Uint8Array(buffer), (item) => ("00" + item.toString(16)).slice(-2)).join("");
}

// node_modules/@azure/cosmos/dist-esm/src/utils/hashObject.js
var import_fast_json_stable_stringify = __toESM(require_fast_json_stable_stringify());
async function hashObject(object) {
  const stringifiedObject = (0, import_fast_json_stable_stringify.default)(object);
  return digest(stringifiedObject);
}

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/EndpointComponent/OrderedDistinctEndpointComponent.js
var OrderedDistinctEndpointComponent = class {
  constructor(executionContext) {
    this.executionContext = executionContext;
  }
  async nextItem(diagnosticNode) {
    const { headers, result } = await this.executionContext.nextItem(diagnosticNode);
    if (result) {
      const hashedResult = await hashObject(result);
      if (hashedResult === this.hashedLastResult) {
        return { result: void 0, headers };
      }
      this.hashedLastResult = hashedResult;
    }
    return { result, headers };
  }
  hasMoreResults() {
    return this.executionContext.hasMoreResults();
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/EndpointComponent/UnorderedDistinctEndpointComponent.js
var UnorderedDistinctEndpointComponent = class {
  constructor(executionContext) {
    this.executionContext = executionContext;
    this.hashedResults = /* @__PURE__ */ new Set();
  }
  async nextItem(diagnosticNode) {
    const { headers, result } = await this.executionContext.nextItem(diagnosticNode);
    if (result) {
      const hashedResult = await hashObject(result);
      if (this.hashedResults.has(hashedResult)) {
        return { result: void 0, headers };
      }
      this.hashedResults.add(hashedResult);
    }
    return { result, headers };
  }
  hasMoreResults() {
    return this.executionContext.hasMoreResults();
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/EndpointComponent/emptyGroup.js
var emptyGroup = "__empty__";
var extractAggregateResult = (payload) => Object.keys(payload).length > 0 ? payload.item2 ? payload.item2 : payload.item : null;

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/EndpointComponent/GroupByEndpointComponent.js
var GroupByEndpointComponent = class {
  constructor(executionContext, queryInfo) {
    this.executionContext = executionContext;
    this.queryInfo = queryInfo;
    this.groupings = /* @__PURE__ */ new Map();
    this.aggregateResultArray = [];
    this.completed = false;
  }
  async nextItem(diagnosticNode) {
    if (this.aggregateResultArray.length > 0) {
      return {
        result: this.aggregateResultArray.pop(),
        headers: getInitialHeader()
      };
    }
    if (this.completed) {
      return {
        result: void 0,
        headers: getInitialHeader()
      };
    }
    const aggregateHeaders = getInitialHeader();
    while (this.executionContext.hasMoreResults()) {
      const { result, headers } = await this.executionContext.nextItem(diagnosticNode);
      mergeHeaders(aggregateHeaders, headers);
      if (result) {
        const group = result.groupByItems ? await hashObject(result.groupByItems) : emptyGroup;
        const aggregators = this.groupings.get(group);
        const payload = result.payload;
        if (aggregators) {
          Object.keys(payload).map((key) => {
            const effectiveGroupByValue = payload[key] ? payload[key] : (/* @__PURE__ */ new Map()).set("item2", null);
            const aggregateResult = extractAggregateResult(effectiveGroupByValue);
            aggregators.get(key).aggregate(aggregateResult);
          });
        } else {
          const grouping = /* @__PURE__ */ new Map();
          this.groupings.set(group, grouping);
          Object.keys(payload).map((key) => {
            const aggregateType = this.queryInfo.groupByAliasToAggregateType[key];
            const aggregator = createAggregator(aggregateType);
            grouping.set(key, aggregator);
            if (aggregateType) {
              const aggregateResult = extractAggregateResult(payload[key]);
              aggregator.aggregate(aggregateResult);
            } else {
              aggregator.aggregate(payload[key]);
            }
          });
        }
      }
    }
    for (const grouping of this.groupings.values()) {
      const groupResult = {};
      for (const [aggregateKey, aggregator] of grouping.entries()) {
        groupResult[aggregateKey] = aggregator.getResult();
      }
      this.aggregateResultArray.push(groupResult);
    }
    this.completed = true;
    return {
      result: this.aggregateResultArray.pop(),
      headers: aggregateHeaders
    };
  }
  hasMoreResults() {
    return this.executionContext.hasMoreResults() || this.aggregateResultArray.length > 0;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/EndpointComponent/GroupByValueEndpointComponent.js
var GroupByValueEndpointComponent = class {
  constructor(executionContext, queryInfo) {
    this.executionContext = executionContext;
    this.queryInfo = queryInfo;
    this.aggregators = /* @__PURE__ */ new Map();
    this.aggregateResultArray = [];
    this.completed = false;
    this.aggregateType = this.queryInfo.aggregates[0];
  }
  async nextItem(diagnosticNode) {
    if (this.aggregateResultArray.length > 0) {
      return {
        result: this.aggregateResultArray.pop(),
        headers: getInitialHeader()
      };
    }
    if (this.completed) {
      return {
        result: void 0,
        headers: getInitialHeader()
      };
    }
    const aggregateHeaders = getInitialHeader();
    while (this.executionContext.hasMoreResults()) {
      const { result, headers } = await this.executionContext.nextItem(diagnosticNode);
      mergeHeaders(aggregateHeaders, headers);
      if (result) {
        let grouping = emptyGroup;
        let payload = result;
        if (result.groupByItems) {
          payload = result.payload;
          grouping = await hashObject(result.groupByItems);
        }
        const aggregator = this.aggregators.get(grouping);
        if (!aggregator) {
          this.aggregators.set(grouping, createAggregator(this.aggregateType));
        }
        if (this.aggregateType) {
          const aggregateResult = extractAggregateResult(payload[0]);
          if (aggregateResult === null) {
            this.completed = true;
          }
          this.aggregators.get(grouping).aggregate(aggregateResult);
        } else {
          this.aggregators.get(grouping).aggregate(payload);
        }
      }
    }
    if (this.completed) {
      return {
        result: void 0,
        headers: aggregateHeaders
      };
    }
    for (const aggregator of this.aggregators.values()) {
      this.aggregateResultArray.push(aggregator.getResult());
    }
    this.completed = true;
    return {
      result: this.aggregateResultArray.pop(),
      headers: aggregateHeaders
    };
  }
  hasMoreResults() {
    return this.executionContext.hasMoreResults() || this.aggregateResultArray.length > 0;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/queryExecutionContext/pipelinedQueryExecutionContext.js
var PipelinedQueryExecutionContext = class _PipelinedQueryExecutionContext {
  constructor(clientContext, collectionLink, query, options, partitionedQueryExecutionInfo) {
    this.clientContext = clientContext;
    this.collectionLink = collectionLink;
    this.query = query;
    this.options = options;
    this.partitionedQueryExecutionInfo = partitionedQueryExecutionInfo;
    this.endpoint = null;
    this.pageSize = options["maxItemCount"];
    if (this.pageSize === void 0) {
      this.pageSize = _PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;
    }
    const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;
    if (Array.isArray(sortOrders) && sortOrders.length > 0) {
      this.endpoint = new OrderByEndpointComponent(new OrderByQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo));
    } else {
      this.endpoint = new ParallelQueryExecutionContext(this.clientContext, this.collectionLink, this.query, this.options, this.partitionedQueryExecutionInfo);
    }
    if (Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length > 0 || partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 || partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0) {
      if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {
        this.endpoint = new GroupByValueEndpointComponent(this.endpoint, partitionedQueryExecutionInfo.queryInfo);
      } else {
        this.endpoint = new GroupByEndpointComponent(this.endpoint, partitionedQueryExecutionInfo.queryInfo);
      }
    }
    const top = partitionedQueryExecutionInfo.queryInfo.top;
    if (typeof top === "number") {
      this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);
    }
    const limit = partitionedQueryExecutionInfo.queryInfo.limit;
    const offset = partitionedQueryExecutionInfo.queryInfo.offset;
    if (typeof limit === "number" && typeof offset === "number") {
      this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);
    }
    const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;
    if (distinctType === "Ordered") {
      this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);
    }
    if (distinctType === "Unordered") {
      this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);
    }
  }
  async nextItem(diagnosticNode) {
    return this.endpoint.nextItem(diagnosticNode);
  }
  // Removed callback here beacuse it wouldn't have ever worked...
  hasMoreResults() {
    return this.endpoint.hasMoreResults();
  }
  async fetchMore(diagnosticNode) {
    if (typeof this.endpoint.fetchMore === "function") {
      return this.endpoint.fetchMore(diagnosticNode);
    } else {
      this.fetchBuffer = [];
      this.fetchMoreRespHeaders = getInitialHeader();
      return this._fetchMoreImplementation(diagnosticNode);
    }
  }
  async _fetchMoreImplementation(diagnosticNode) {
    try {
      const { result: item, headers } = await this.endpoint.nextItem(diagnosticNode);
      mergeHeaders(this.fetchMoreRespHeaders, headers);
      if (item === void 0) {
        if (this.fetchBuffer.length === 0) {
          return {
            result: void 0,
            headers: this.fetchMoreRespHeaders
          };
        } else {
          const temp = this.fetchBuffer;
          this.fetchBuffer = [];
          return { result: temp, headers: this.fetchMoreRespHeaders };
        }
      } else {
        this.fetchBuffer.push(item);
        if (this.fetchBuffer.length >= this.pageSize) {
          const temp = this.fetchBuffer.slice(0, this.pageSize);
          this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);
          return { result: temp, headers: this.fetchMoreRespHeaders };
        } else {
          return this._fetchMoreImplementation(diagnosticNode);
        }
      }
    } catch (err) {
      mergeHeaders(this.fetchMoreRespHeaders, err.headers);
      err.headers = this.fetchMoreRespHeaders;
      if (err) {
        throw err;
      }
    }
  }
};
PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE = 10;

// node_modules/@azure/cosmos/dist-esm/src/queryIterator.js
var QueryIterator = class {
  /**
   * @hidden
   */
  constructor(clientContext, query, options, fetchFunctions, resourceLink, resourceType) {
    this.clientContext = clientContext;
    this.query = query;
    this.options = options;
    this.fetchFunctions = fetchFunctions;
    this.resourceLink = resourceLink;
    this.resourceType = resourceType;
    this.query = query;
    this.fetchFunctions = fetchFunctions;
    this.options = options || {};
    this.resourceLink = resourceLink;
    this.fetchAllLastResHeaders = getInitialHeader();
    this.reset();
    this.isInitialized = false;
  }
  /**
   * Gets an async iterator that will yield results until completion.
   *
   * NOTE: AsyncIterators are a very new feature and you might need to
   * use polyfils/etc. in order to use them in your code.
   *
   * If you're using TypeScript, you can use the following polyfill as long
   * as you target ES6 or higher and are running on Node 6 or higher.
   *
   * ```typescript
   * if (!Symbol || !Symbol.asyncIterator) {
   *   (Symbol as any).asyncIterator = Symbol.for("Symbol.asyncIterator");
   * }
   * ```
   *
   * @example Iterate over all databases
   * ```typescript
   * for await(const { resources: db } of client.databases.readAll().getAsyncIterator()) {
   *   console.log(`Got ${db} from AsyncIterator`);
   * }
   * ```
   */
  getAsyncIterator() {
    return __asyncGenerator(this, arguments, function* getAsyncIterator_1() {
      this.reset();
      let diagnosticNode = new DiagnosticNodeInternal(this.clientContext.diagnosticLevel, DiagnosticNodeType.CLIENT_REQUEST_NODE, null);
      this.queryPlanPromise = this.fetchQueryPlan(diagnosticNode);
      while (this.queryExecutionContext.hasMoreResults()) {
        let response;
        try {
          response = yield __await(this.queryExecutionContext.fetchMore(diagnosticNode));
        } catch (error) {
          if (this.needsQueryPlan(error)) {
            yield __await(this.createPipelinedExecutionContext());
            try {
              response = yield __await(this.queryExecutionContext.fetchMore(diagnosticNode));
            } catch (queryError) {
              this.handleSplitError(queryError);
            }
          } else {
            throw error;
          }
        }
        const feedResponse = new FeedResponse(response.result, response.headers, this.queryExecutionContext.hasMoreResults(), diagnosticNode.toDiagnostic(this.clientContext.getClientConfig()));
        diagnosticNode = new DiagnosticNodeInternal(this.clientContext.diagnosticLevel, DiagnosticNodeType.CLIENT_REQUEST_NODE, null);
        if (response.result !== void 0) {
          yield yield __await(feedResponse);
        }
      }
    });
  }
  /**
   * Determine if there are still remaining resources to process based on the value of the continuation token or the
   * elements remaining on the current batch in the QueryIterator.
   * @returns true if there is other elements to process in the QueryIterator.
   */
  hasMoreResults() {
    return this.queryExecutionContext.hasMoreResults();
  }
  /**
   * Fetch all pages for the query and return a single FeedResponse.
   */
  async fetchAll() {
    return withDiagnostics(async (diagnosticNode) => {
      return this.fetchAllInternal(diagnosticNode);
    }, this.clientContext);
  }
  /**
   * @hidden
   */
  async fetchAllInternal(diagnosticNode) {
    this.reset();
    let response;
    try {
      response = await this.toArrayImplementation(diagnosticNode);
    } catch (error) {
      this.handleSplitError(error);
    }
    return response;
  }
  /**
   * Retrieve the next batch from the feed.
   *
   * This may or may not fetch more pages from the backend depending on your settings
   * and the type of query. Aggregate queries will generally fetch all backend pages
   * before returning the first batch of responses.
   */
  async fetchNext() {
    return withDiagnostics(async (diagnosticNode) => {
      this.queryPlanPromise = withMetadataDiagnostics(async (metadataNode) => {
        return this.fetchQueryPlan(metadataNode);
      }, diagnosticNode, MetadataLookUpType.QueryPlanLookUp);
      if (!this.isInitialized) {
        await this.init();
      }
      let response;
      try {
        response = await this.queryExecutionContext.fetchMore(diagnosticNode);
      } catch (error) {
        if (this.needsQueryPlan(error)) {
          await this.createPipelinedExecutionContext();
          try {
            response = await this.queryExecutionContext.fetchMore(diagnosticNode);
          } catch (queryError) {
            this.handleSplitError(queryError);
          }
        } else {
          throw error;
        }
      }
      return new FeedResponse(response.result, response.headers, this.queryExecutionContext.hasMoreResults(), getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Reset the QueryIterator to the beginning and clear all the resources inside it
   */
  reset() {
    this.queryPlanPromise = void 0;
    this.fetchAllLastResHeaders = getInitialHeader();
    this.fetchAllTempResources = [];
    this.queryExecutionContext = new DefaultQueryExecutionContext(this.options, this.fetchFunctions);
  }
  async toArrayImplementation(diagnosticNode) {
    this.queryPlanPromise = withMetadataDiagnostics(async (metadataNode) => {
      return this.fetchQueryPlan(metadataNode);
    }, diagnosticNode, MetadataLookUpType.QueryPlanLookUp);
    if (!this.isInitialized) {
      await this.init();
    }
    while (this.queryExecutionContext.hasMoreResults()) {
      let response;
      try {
        response = await this.queryExecutionContext.nextItem(diagnosticNode);
      } catch (error) {
        if (this.needsQueryPlan(error)) {
          await this.createPipelinedExecutionContext();
          response = await this.queryExecutionContext.nextItem(diagnosticNode);
        } else {
          throw error;
        }
      }
      const { result, headers } = response;
      mergeHeaders(this.fetchAllLastResHeaders, headers);
      if (result !== void 0) {
        this.fetchAllTempResources.push(result);
      }
    }
    return new FeedResponse(this.fetchAllTempResources, this.fetchAllLastResHeaders, this.queryExecutionContext.hasMoreResults(), getEmptyCosmosDiagnostics());
  }
  async createPipelinedExecutionContext() {
    const queryPlanResponse = await this.queryPlanPromise;
    if (queryPlanResponse instanceof Error) {
      throw queryPlanResponse;
    }
    const queryPlan = queryPlanResponse.result;
    const queryInfo = queryPlan.queryInfo;
    if (queryInfo.aggregates.length > 0 && queryInfo.hasSelectValue === false) {
      throw new Error("Aggregate queries must use the VALUE keyword");
    }
    this.queryExecutionContext = new PipelinedQueryExecutionContext(this.clientContext, this.resourceLink, this.query, this.options, queryPlan);
  }
  async fetchQueryPlan(diagnosticNode) {
    if (!this.queryPlanPromise && this.resourceType === ResourceType.item) {
      return this.clientContext.getQueryPlan(getPathFromLink(this.resourceLink) + "/docs", ResourceType.item, this.resourceLink, this.query, this.options, diagnosticNode).catch((error) => error);
    }
    return this.queryPlanPromise;
  }
  needsQueryPlan(error) {
    var _a;
    if (((_a = error.body) === null || _a === void 0 ? void 0 : _a.additionalErrorInfo) || error.message.includes("Cross partition query only supports")) {
      return error.code === StatusCodes.BadRequest && this.resourceType === ResourceType.item;
    } else {
      throw error;
    }
  }
  async init() {
    if (this.isInitialized === true) {
      return;
    }
    if (this.initPromise === void 0) {
      this.initPromise = this._init();
    }
    return this.initPromise;
  }
  async _init() {
    if (this.options.forceQueryPlan === true && this.resourceType === ResourceType.item) {
      await this.createPipelinedExecutionContext();
    }
    this.isInitialized = true;
  }
  handleSplitError(err) {
    if (err.code === 410) {
      const error = new Error("Encountered partition split and could not recover. This request is retryable");
      error.code = 503;
      error.originalError = err;
      throw error;
    } else {
      throw err;
    }
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Conflict/ConflictResponse.js
var ConflictResponse = class extends ResourceResponse {
  constructor(resource, headers, statusCode, conflict, diagnostics) {
    super(resource, headers, statusCode, diagnostics);
    this.conflict = conflict;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ClientUtils.js
async function readPartitionKeyDefinition(diagnosticNode, container) {
  const partitionKeyDefinition = await container.readPartitionKeyDefinition(diagnosticNode);
  return partitionKeyDefinition.resource;
}

// node_modules/@azure/cosmos/dist-esm/src/client/Conflict/Conflict.js
var Conflict = class {
  /**
   * Returns a reference URL to the resource. Used for linking in Permissions.
   */
  get url() {
    return `/${this.container.url}/${Constants.Path.ConflictsPathSegment}/${this.id}`;
  }
  /**
   * @hidden
   * @param container - The parent {@link Container}.
   * @param id - The id of the given {@link Conflict}.
   */
  constructor(container, id, clientContext, partitionKey) {
    this.container = container;
    this.id = id;
    this.clientContext = clientContext;
    this.partitionKey = partitionKey;
    this.partitionKey = partitionKey;
  }
  /**
   * Read the {@link ConflictDefinition} for the given {@link Conflict}.
   */
  async read(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url, ResourceType.conflicts);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.read({
        path,
        resourceType: ResourceType.user,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new ConflictResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Delete the given {@link ConflictDefinition}.
   */
  async delete(options) {
    return withDiagnostics(async (diagnosticNode) => {
      if (this.partitionKey === void 0) {
        const partitionKeyDefinition = await readPartitionKeyDefinition(diagnosticNode, this.container);
        this.partitionKey = undefinedPartitionKey(partitionKeyDefinition);
      }
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.delete({
        path,
        resourceType: ResourceType.conflicts,
        resourceId: id,
        options,
        partitionKey: this.partitionKey,
        diagnosticNode
      });
      return new ConflictResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Conflict/Conflicts.js
var Conflicts = class {
  constructor(container, clientContext) {
    this.container = container;
    this.clientContext = clientContext;
  }
  query(query, options) {
    const path = getPathFromLink(this.container.url, ResourceType.conflicts);
    const id = getIdFromLink(this.container.url);
    return new QueryIterator(this.clientContext, query, options, (diagNode, innerOptions) => {
      return this.clientContext.queryFeed({
        path,
        resourceType: ResourceType.conflicts,
        resourceId: id,
        resultFn: (result) => result.Conflicts,
        query,
        options: innerOptions,
        diagnosticNode: diagNode
      });
    });
  }
  /**
   * Reads all conflicts
   * @param options - Use to set options like response page size, continuation tokens, etc.
   */
  readAll(options) {
    return this.query(void 0, options);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Conflict/ConflictResolutionMode.js
var ConflictResolutionMode;
(function(ConflictResolutionMode2) {
  ConflictResolutionMode2["Custom"] = "Custom";
  ConflictResolutionMode2["LastWriterWins"] = "LastWriterWins";
})(ConflictResolutionMode || (ConflictResolutionMode = {}));

// node_modules/@azure/cosmos/dist-esm/src/client/Item/ItemResponse.js
var ItemResponse = class extends ResourceResponse {
  constructor(resource, headers, statusCode, subsstatusCode, item, diagnostics) {
    super(resource, headers, statusCode, diagnostics, subsstatusCode);
    this.item = item;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Item/Item.js
var Item = class {
  /**
   * Returns a reference URL to the resource. Used for linking in Permissions.
   */
  get url() {
    return createDocumentUri(this.container.database.id, this.container.id, this.id);
  }
  /**
   * @hidden
   * @param container - The parent {@link Container}.
   * @param id - The id of the given {@link Item}.
   * @param partitionKey - The primary key of the given {@link Item} (only for partitioned containers).
   */
  constructor(container, id, clientContext, partitionKey) {
    this.container = container;
    this.id = id;
    this.clientContext = clientContext;
    this.partitionKey = partitionKey === void 0 ? void 0 : convertToInternalPartitionKey(partitionKey);
  }
  /**
   * Read the item's definition.
   *
   * Any provided type, T, is not necessarily enforced by the SDK.
   * You may get more or less properties and it's up to your logic to enforce it.
   * If the type, T, is a class, it won't pass `typeof` comparisons, because it won't have a match prototype.
   * It's recommended to only use interfaces.
   *
   * There is no set schema for JSON items. They may contain any number of custom properties.
   *
   * @param options - Additional options for the request
   *
   * @example Using custom type for response
   * ```typescript
   * interface TodoItem {
   *   title: string;
   *   done: bool;
   *   id: string;
   * }
   *
   * let item: TodoItem;
   * ({body: item} = await item.read<TodoItem>());
   * ```
   */
  async read(options = {}) {
    return withDiagnostics(async (diagnosticNode) => {
      if (this.partitionKey === void 0) {
        const partitionKeyDefinition = await readPartitionKeyDefinition(diagnosticNode, this.container);
        this.partitionKey = undefinedPartitionKey(partitionKeyDefinition);
      }
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      let response;
      try {
        response = await this.clientContext.read({
          path,
          resourceType: ResourceType.item,
          resourceId: id,
          options,
          partitionKey: this.partitionKey,
          diagnosticNode
        });
      } catch (error) {
        if (error.code !== StatusCodes.NotFound) {
          throw error;
        }
        response = error;
      }
      return new ItemResponse(response.result, response.headers, response.code, response.substatus, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  async replace(body, options = {}) {
    return withDiagnostics(async (diagnosticNode) => {
      if (this.partitionKey === void 0) {
        const partitionKeyResponse = await readPartitionKeyDefinition(diagnosticNode, this.container);
        this.partitionKey = extractPartitionKeys(body, partitionKeyResponse);
      }
      const err = {};
      if (!isItemResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.replace({
        body,
        path,
        resourceType: ResourceType.item,
        resourceId: id,
        options,
        partitionKey: this.partitionKey,
        diagnosticNode
      });
      return new ItemResponse(response.result, response.headers, response.code, response.substatus, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Delete the item.
   *
   * Any provided type, T, is not necessarily enforced by the SDK.
   * You may get more or less properties and it's up to your logic to enforce it.
   *
   * @param options - Additional options for the request
   */
  async delete(options = {}) {
    return withDiagnostics(async (diagnosticNode) => {
      if (this.partitionKey === void 0) {
        const partitionKeyResponse = await readPartitionKeyDefinition(diagnosticNode, this.container);
        this.partitionKey = undefinedPartitionKey(partitionKeyResponse);
      }
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.delete({
        path,
        resourceType: ResourceType.item,
        resourceId: id,
        options,
        partitionKey: this.partitionKey,
        diagnosticNode
      });
      return new ItemResponse(response.result, response.headers, response.code, response.substatus, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Perform a JSONPatch on the item.
   *
   * Any provided type, T, is not necessarily enforced by the SDK.
   * You may get more or less properties and it's up to your logic to enforce it.
   *
   * @param options - Additional options for the request
   */
  async patch(body, options = {}) {
    return withDiagnostics(async (diagnosticNode) => {
      if (this.partitionKey === void 0) {
        const partitionKeyResponse = await readPartitionKeyDefinition(diagnosticNode, this.container);
        this.partitionKey = extractPartitionKeys(body, partitionKeyResponse);
      }
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.patch({
        body,
        path,
        resourceType: ResourceType.item,
        resourceId: id,
        options,
        partitionKey: this.partitionKey,
        diagnosticNode
      });
      return new ItemResponse(response.result, response.headers, response.code, response.substatus, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/ChangeFeedResponse.js
var ChangeFeedResponse = class {
  /**
   * @internal
   */
  constructor(result, count, statusCode, headers, diagnostics) {
    this.result = result;
    this.count = count;
    this.statusCode = statusCode;
    this.diagnostics = diagnostics;
    this.headers = Object.freeze(headers);
  }
  /**
   * Gets the request charge for this request from the Azure Cosmos DB service.
   */
  get requestCharge() {
    const rus = this.headers[Constants.HttpHeaders.RequestCharge];
    return rus ? parseInt(rus, 10) : null;
  }
  /**
   * Gets the activity ID for the request from the Azure Cosmos DB service.
   */
  get activityId() {
    return this.headers[Constants.HttpHeaders.ActivityId];
  }
  /**
   * Gets the continuation token to be used for continuing enumeration of the Azure Cosmos DB service.
   *
   * This is equivalent to the `etag` property.
   */
  get continuation() {
    return this.etag;
  }
  /**
   * Gets the session token for use in session consistency reads from the Azure Cosmos DB service.
   */
  get sessionToken() {
    return this.headers[Constants.HttpHeaders.SessionToken];
  }
  /**
   * Gets the entity tag associated with last transaction in the Azure Cosmos DB service,
   * which can be used as If-Non-Match Access condition for ReadFeed REST request or
   * `continuation` property of `ChangeFeedOptions` parameter for
   * `Items.changeFeed()`
   * to get feed changes since the transaction specified by this entity tag.
   *
   * This is equivalent to the `continuation` property.
   */
  get etag() {
    return this.headers[Constants.HttpHeaders.ETag];
  }
};

// node_modules/@azure/cosmos/dist-esm/src/ChangeFeedIterator.js
var ChangeFeedIterator = class _ChangeFeedIterator {
  /**
   * @internal
   */
  constructor(clientContext, resourceId, resourceLink, partitionKey, changeFeedOptions) {
    this.clientContext = clientContext;
    this.resourceId = resourceId;
    this.resourceLink = resourceLink;
    this.partitionKey = partitionKey;
    this.changeFeedOptions = changeFeedOptions;
    const partitionKeyValid = partitionKey !== void 0;
    this.isPartitionSpecified = partitionKeyValid;
    let canUseStartFromBeginning = true;
    if (changeFeedOptions.continuation) {
      this.nextIfNoneMatch = changeFeedOptions.continuation;
      canUseStartFromBeginning = false;
    }
    if (changeFeedOptions.startTime) {
      this.ifModifiedSince = changeFeedOptions.startTime.toUTCString();
      canUseStartFromBeginning = false;
    }
    if (canUseStartFromBeginning && !changeFeedOptions.startFromBeginning) {
      this.nextIfNoneMatch = _ChangeFeedIterator.IfNoneMatchAllHeaderValue;
    }
  }
  /**
   * Gets a value indicating whether there are potentially additional results that can be retrieved.
   *
   * Initially returns true. This value is set based on whether the last execution returned a continuation token.
   *
   * @returns Boolean value representing if whether there are potentially additional results that can be retrieved.
   */
  get hasMoreResults() {
    return this.lastStatusCode !== StatusCodes.NotModified;
  }
  /**
   * Gets an async iterator which will yield pages of results from Azure Cosmos DB.
   */
  getAsyncIterator() {
    return __asyncGenerator(this, arguments, function* getAsyncIterator_1() {
      do {
        const result = yield __await(this.fetchNext());
        if (result.count > 0) {
          yield yield __await(result);
        }
      } while (this.hasMoreResults);
    });
  }
  /**
   * Read feed and retrieves the next page of results in Azure Cosmos DB.
   */
  async fetchNext() {
    return withDiagnostics(async (diagnosticNode) => {
      const response = await this.getFeedResponse(diagnosticNode);
      this.lastStatusCode = response.statusCode;
      this.nextIfNoneMatch = response.headers[Constants.HttpHeaders.ETag];
      return response;
    }, this.clientContext);
  }
  async getFeedResponse(diagnosticNode) {
    if (!this.isPartitionSpecified) {
      throw new Error("Container is partitioned, but no partition key or partition key range id was specified.");
    }
    const feedOptions = { initialHeaders: {}, useIncrementalFeed: true };
    if (typeof this.changeFeedOptions.maxItemCount === "number") {
      feedOptions.maxItemCount = this.changeFeedOptions.maxItemCount;
    }
    if (this.changeFeedOptions.sessionToken) {
      feedOptions.sessionToken = this.changeFeedOptions.sessionToken;
    }
    if (this.nextIfNoneMatch) {
      feedOptions.accessCondition = {
        type: Constants.HttpHeaders.IfNoneMatch,
        condition: this.nextIfNoneMatch
      };
    }
    if (this.ifModifiedSince) {
      feedOptions.initialHeaders[Constants.HttpHeaders.IfModifiedSince] = this.ifModifiedSince;
    }
    const response = await this.clientContext.queryFeed({
      path: this.resourceLink,
      resourceType: ResourceType.item,
      resourceId: this.resourceId,
      resultFn: (result) => result ? result.Documents : [],
      query: void 0,
      options: feedOptions,
      partitionKey: this.partitionKey,
      diagnosticNode
    });
    return new ChangeFeedResponse(response.result, response.result ? response.result.length : 0, response.code, response.headers, getEmptyCosmosDiagnostics());
  }
};
ChangeFeedIterator.IfNoneMatchAllHeaderValue = "*";

// node_modules/jsbi/dist/jsbi.mjs
var JSBI = class _JSBI extends Array {
  constructor(i, _) {
    if (super(i), this.sign = _, i > _JSBI.__kMaxLength)
      throw new RangeError("Maximum BigInt size exceeded");
  }
  static BigInt(i) {
    var _ = Math.floor, t = Number.isFinite;
    if ("number" == typeof i) {
      if (0 === i)
        return _JSBI.__zero();
      if (_JSBI.__isOneDigitInt(i))
        return 0 > i ? _JSBI.__oneDigit(-i, true) : _JSBI.__oneDigit(i, false);
      if (!t(i) || _(i) !== i)
        throw new RangeError("The number " + i + " cannot be converted to BigInt because it is not an integer");
      return _JSBI.__fromDouble(i);
    }
    if ("string" == typeof i) {
      const _2 = _JSBI.__fromString(i);
      if (null === _2)
        throw new SyntaxError("Cannot convert " + i + " to a BigInt");
      return _2;
    }
    if ("boolean" == typeof i)
      return true === i ? _JSBI.__oneDigit(1, false) : _JSBI.__zero();
    if ("object" == typeof i) {
      if (i.constructor === _JSBI)
        return i;
      const _2 = _JSBI.__toPrimitive(i);
      return _JSBI.BigInt(_2);
    }
    throw new TypeError("Cannot convert " + i + " to a BigInt");
  }
  toDebugString() {
    const i = ["BigInt["];
    for (const _ of this)
      i.push((_ ? (_ >>> 0).toString(16) : _) + ", ");
    return i.push("]"), i.join("");
  }
  toString(i = 10) {
    if (2 > i || 36 < i)
      throw new RangeError("toString() radix argument must be between 2 and 36");
    return 0 === this.length ? "0" : 0 == (i & i - 1) ? _JSBI.__toStringBasePowerOfTwo(this, i) : _JSBI.__toStringGeneric(this, i, false);
  }
  static toNumber(i) {
    const _ = i.length;
    if (0 === _)
      return 0;
    if (1 === _) {
      const _2 = i.__unsignedDigit(0);
      return i.sign ? -_2 : _2;
    }
    const t = i.__digit(_ - 1), e = _JSBI.__clz30(t), n = 30 * _ - e;
    if (1024 < n)
      return i.sign ? -Infinity : 1 / 0;
    let g = n - 1, o = t, s = _ - 1;
    const l = e + 3;
    let r = 32 === l ? 0 : o << l;
    r >>>= 12;
    const a = l - 12;
    let u = 12 <= l ? 0 : o << 20 + l, d = 20 + l;
    for (0 < a && 0 < s && (s--, o = i.__digit(s), r |= o >>> 30 - a, u = o << a + 2, d = a + 2); 0 < d && 0 < s; )
      s--, o = i.__digit(s), u |= 30 <= d ? o << d - 30 : o >>> 30 - d, d -= 30;
    const h = _JSBI.__decideRounding(i, d, s, o);
    if ((1 === h || 0 === h && 1 == (1 & u)) && (u = u + 1 >>> 0, 0 === u && (r++, 0 != r >>> 20 && (r = 0, g++, 1023 < g))))
      return i.sign ? -Infinity : 1 / 0;
    const m = i.sign ? -2147483648 : 0;
    return g = g + 1023 << 20, _JSBI.__kBitConversionInts[1] = m | g | r, _JSBI.__kBitConversionInts[0] = u, _JSBI.__kBitConversionDouble[0];
  }
  static unaryMinus(i) {
    if (0 === i.length)
      return i;
    const _ = i.__copy();
    return _.sign = !i.sign, _;
  }
  static bitwiseNot(i) {
    return i.sign ? _JSBI.__absoluteSubOne(i).__trim() : _JSBI.__absoluteAddOne(i, true);
  }
  static exponentiate(i, _) {
    if (_.sign)
      throw new RangeError("Exponent must be positive");
    if (0 === _.length)
      return _JSBI.__oneDigit(1, false);
    if (0 === i.length)
      return i;
    if (1 === i.length && 1 === i.__digit(0))
      return i.sign && 0 == (1 & _.__digit(0)) ? _JSBI.unaryMinus(i) : i;
    if (1 < _.length)
      throw new RangeError("BigInt too big");
    let t = _.__unsignedDigit(0);
    if (1 === t)
      return i;
    if (t >= _JSBI.__kMaxLengthBits)
      throw new RangeError("BigInt too big");
    if (1 === i.length && 2 === i.__digit(0)) {
      const _2 = 1 + (0 | t / 30), e2 = i.sign && 0 != (1 & t), n2 = new _JSBI(_2, e2);
      n2.__initializeDigits();
      const g = 1 << t % 30;
      return n2.__setDigit(_2 - 1, g), n2;
    }
    let e = null, n = i;
    for (0 != (1 & t) && (e = i), t >>= 1; 0 !== t; t >>= 1)
      n = _JSBI.multiply(n, n), 0 != (1 & t) && (null === e ? e = n : e = _JSBI.multiply(e, n));
    return e;
  }
  static multiply(_, t) {
    if (0 === _.length)
      return _;
    if (0 === t.length)
      return t;
    let i = _.length + t.length;
    30 <= _.__clzmsd() + t.__clzmsd() && i--;
    const e = new _JSBI(i, _.sign !== t.sign);
    e.__initializeDigits();
    for (let n = 0; n < _.length; n++)
      _JSBI.__multiplyAccumulate(t, _.__digit(n), e, n);
    return e.__trim();
  }
  static divide(i, _) {
    if (0 === _.length)
      throw new RangeError("Division by zero");
    if (0 > _JSBI.__absoluteCompare(i, _))
      return _JSBI.__zero();
    const t = i.sign !== _.sign, e = _.__unsignedDigit(0);
    let n;
    if (1 === _.length && 32767 >= e) {
      if (1 === e)
        return t === i.sign ? i : _JSBI.unaryMinus(i);
      n = _JSBI.__absoluteDivSmall(i, e, null);
    } else
      n = _JSBI.__absoluteDivLarge(i, _, true, false);
    return n.sign = t, n.__trim();
  }
  static remainder(i, _) {
    if (0 === _.length)
      throw new RangeError("Division by zero");
    if (0 > _JSBI.__absoluteCompare(i, _))
      return i;
    const t = _.__unsignedDigit(0);
    if (1 === _.length && 32767 >= t) {
      if (1 === t)
        return _JSBI.__zero();
      const _2 = _JSBI.__absoluteModSmall(i, t);
      return 0 === _2 ? _JSBI.__zero() : _JSBI.__oneDigit(_2, i.sign);
    }
    const e = _JSBI.__absoluteDivLarge(i, _, false, true);
    return e.sign = i.sign, e.__trim();
  }
  static add(i, _) {
    const t = i.sign;
    return t === _.sign ? _JSBI.__absoluteAdd(i, _, t) : 0 <= _JSBI.__absoluteCompare(i, _) ? _JSBI.__absoluteSub(i, _, t) : _JSBI.__absoluteSub(_, i, !t);
  }
  static subtract(i, _) {
    const t = i.sign;
    return t === _.sign ? 0 <= _JSBI.__absoluteCompare(i, _) ? _JSBI.__absoluteSub(i, _, t) : _JSBI.__absoluteSub(_, i, !t) : _JSBI.__absoluteAdd(i, _, t);
  }
  static leftShift(i, _) {
    return 0 === _.length || 0 === i.length ? i : _.sign ? _JSBI.__rightShiftByAbsolute(i, _) : _JSBI.__leftShiftByAbsolute(i, _);
  }
  static signedRightShift(i, _) {
    return 0 === _.length || 0 === i.length ? i : _.sign ? _JSBI.__leftShiftByAbsolute(i, _) : _JSBI.__rightShiftByAbsolute(i, _);
  }
  static unsignedRightShift() {
    throw new TypeError("BigInts have no unsigned right shift; use >> instead");
  }
  static lessThan(i, _) {
    return 0 > _JSBI.__compareToBigInt(i, _);
  }
  static lessThanOrEqual(i, _) {
    return 0 >= _JSBI.__compareToBigInt(i, _);
  }
  static greaterThan(i, _) {
    return 0 < _JSBI.__compareToBigInt(i, _);
  }
  static greaterThanOrEqual(i, _) {
    return 0 <= _JSBI.__compareToBigInt(i, _);
  }
  static equal(_, t) {
    if (_.sign !== t.sign)
      return false;
    if (_.length !== t.length)
      return false;
    for (let e = 0; e < _.length; e++)
      if (_.__digit(e) !== t.__digit(e))
        return false;
    return true;
  }
  static notEqual(i, _) {
    return !_JSBI.equal(i, _);
  }
  static bitwiseAnd(i, _) {
    var t = Math.max;
    if (!i.sign && !_.sign)
      return _JSBI.__absoluteAnd(i, _).__trim();
    if (i.sign && _.sign) {
      const e = t(i.length, _.length) + 1;
      let n = _JSBI.__absoluteSubOne(i, e);
      const g = _JSBI.__absoluteSubOne(_);
      return n = _JSBI.__absoluteOr(n, g, n), _JSBI.__absoluteAddOne(n, true, n).__trim();
    }
    return i.sign && ([i, _] = [_, i]), _JSBI.__absoluteAndNot(i, _JSBI.__absoluteSubOne(_)).__trim();
  }
  static bitwiseXor(i, _) {
    var t = Math.max;
    if (!i.sign && !_.sign)
      return _JSBI.__absoluteXor(i, _).__trim();
    if (i.sign && _.sign) {
      const e2 = t(i.length, _.length), n2 = _JSBI.__absoluteSubOne(i, e2), g = _JSBI.__absoluteSubOne(_);
      return _JSBI.__absoluteXor(n2, g, n2).__trim();
    }
    const e = t(i.length, _.length) + 1;
    i.sign && ([i, _] = [_, i]);
    let n = _JSBI.__absoluteSubOne(_, e);
    return n = _JSBI.__absoluteXor(n, i, n), _JSBI.__absoluteAddOne(n, true, n).__trim();
  }
  static bitwiseOr(i, _) {
    var t = Math.max;
    const e = t(i.length, _.length);
    if (!i.sign && !_.sign)
      return _JSBI.__absoluteOr(i, _).__trim();
    if (i.sign && _.sign) {
      let t2 = _JSBI.__absoluteSubOne(i, e);
      const n2 = _JSBI.__absoluteSubOne(_);
      return t2 = _JSBI.__absoluteAnd(t2, n2, t2), _JSBI.__absoluteAddOne(t2, true, t2).__trim();
    }
    i.sign && ([i, _] = [_, i]);
    let n = _JSBI.__absoluteSubOne(_, e);
    return n = _JSBI.__absoluteAndNot(n, i, n), _JSBI.__absoluteAddOne(n, true, n).__trim();
  }
  static asIntN(_, t) {
    var i = Math.floor;
    if (0 === t.length)
      return t;
    if (_ = i(_), 0 > _)
      throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (0 === _)
      return _JSBI.__zero();
    if (_ >= _JSBI.__kMaxLengthBits)
      return t;
    const e = 0 | (_ + 29) / 30;
    if (t.length < e)
      return t;
    const g = t.__unsignedDigit(e - 1), o = 1 << (_ - 1) % 30;
    if (t.length === e && g < o)
      return t;
    if (!((g & o) === o))
      return _JSBI.__truncateToNBits(_, t);
    if (!t.sign)
      return _JSBI.__truncateAndSubFromPowerOfTwo(_, t, true);
    if (0 == (g & o - 1)) {
      for (let n = e - 2; 0 <= n; n--)
        if (0 !== t.__digit(n))
          return _JSBI.__truncateAndSubFromPowerOfTwo(_, t, false);
      return t.length === e && g === o ? t : _JSBI.__truncateToNBits(_, t);
    }
    return _JSBI.__truncateAndSubFromPowerOfTwo(_, t, false);
  }
  static asUintN(i, _) {
    var t = Math.floor;
    if (0 === _.length)
      return _;
    if (i = t(i), 0 > i)
      throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (0 === i)
      return _JSBI.__zero();
    if (_.sign) {
      if (i > _JSBI.__kMaxLengthBits)
        throw new RangeError("BigInt too big");
      return _JSBI.__truncateAndSubFromPowerOfTwo(i, _, false);
    }
    if (i >= _JSBI.__kMaxLengthBits)
      return _;
    const e = 0 | (i + 29) / 30;
    if (_.length < e)
      return _;
    const g = i % 30;
    if (_.length == e) {
      if (0 === g)
        return _;
      const i2 = _.__digit(e - 1);
      if (0 == i2 >>> g)
        return _;
    }
    return _JSBI.__truncateToNBits(i, _);
  }
  static ADD(i, _) {
    if (i = _JSBI.__toPrimitive(i), _ = _JSBI.__toPrimitive(_), "string" == typeof i)
      return "string" != typeof _ && (_ = _.toString()), i + _;
    if ("string" == typeof _)
      return i.toString() + _;
    if (i = _JSBI.__toNumeric(i), _ = _JSBI.__toNumeric(_), _JSBI.__isBigInt(i) && _JSBI.__isBigInt(_))
      return _JSBI.add(i, _);
    if ("number" == typeof i && "number" == typeof _)
      return i + _;
    throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
  }
  static LT(i, _) {
    return _JSBI.__compare(i, _, 0);
  }
  static LE(i, _) {
    return _JSBI.__compare(i, _, 1);
  }
  static GT(i, _) {
    return _JSBI.__compare(i, _, 2);
  }
  static GE(i, _) {
    return _JSBI.__compare(i, _, 3);
  }
  static EQ(i, _) {
    for (; ; ) {
      if (_JSBI.__isBigInt(i))
        return _JSBI.__isBigInt(_) ? _JSBI.equal(i, _) : _JSBI.EQ(_, i);
      if ("number" == typeof i) {
        if (_JSBI.__isBigInt(_))
          return _JSBI.__equalToNumber(_, i);
        if ("object" != typeof _)
          return i == _;
        _ = _JSBI.__toPrimitive(_);
      } else if ("string" == typeof i) {
        if (_JSBI.__isBigInt(_))
          return i = _JSBI.__fromString(i), null !== i && _JSBI.equal(i, _);
        if ("object" != typeof _)
          return i == _;
        _ = _JSBI.__toPrimitive(_);
      } else if ("boolean" == typeof i) {
        if (_JSBI.__isBigInt(_))
          return _JSBI.__equalToNumber(_, +i);
        if ("object" != typeof _)
          return i == _;
        _ = _JSBI.__toPrimitive(_);
      } else if ("symbol" == typeof i) {
        if (_JSBI.__isBigInt(_))
          return false;
        if ("object" != typeof _)
          return i == _;
        _ = _JSBI.__toPrimitive(_);
      } else if ("object" == typeof i) {
        if ("object" == typeof _ && _.constructor !== _JSBI)
          return i == _;
        i = _JSBI.__toPrimitive(i);
      } else
        return i == _;
    }
  }
  static NE(i, _) {
    return !_JSBI.EQ(i, _);
  }
  static __zero() {
    return new _JSBI(0, false);
  }
  static __oneDigit(i, _) {
    const t = new _JSBI(1, _);
    return t.__setDigit(0, i), t;
  }
  __copy() {
    const _ = new _JSBI(this.length, this.sign);
    for (let t = 0; t < this.length; t++)
      _[t] = this[t];
    return _;
  }
  __trim() {
    let i = this.length, _ = this[i - 1];
    for (; 0 === _; )
      i--, _ = this[i - 1], this.pop();
    return 0 === i && (this.sign = false), this;
  }
  __initializeDigits() {
    for (let _ = 0; _ < this.length; _++)
      this[_] = 0;
  }
  static __decideRounding(i, _, t, e) {
    if (0 < _)
      return -1;
    let n;
    if (0 > _)
      n = -_ - 1;
    else {
      if (0 === t)
        return -1;
      t--, e = i.__digit(t), n = 29;
    }
    let g = 1 << n;
    if (0 == (e & g))
      return -1;
    if (g -= 1, 0 != (e & g))
      return 1;
    for (; 0 < t; )
      if (t--, 0 !== i.__digit(t))
        return 1;
    return 0;
  }
  static __fromDouble(i) {
    _JSBI.__kBitConversionDouble[0] = i;
    const _ = 2047 & _JSBI.__kBitConversionInts[1] >>> 20, t = _ - 1023, e = (0 | t / 30) + 1, n = new _JSBI(e, 0 > i);
    let g = 1048575 & _JSBI.__kBitConversionInts[1] | 1048576, o = _JSBI.__kBitConversionInts[0];
    const s = 20, l = t % 30;
    let r, a = 0;
    if (l < 20) {
      const i2 = s - l;
      a = i2 + 32, r = g >>> i2, g = g << 32 - i2 | o >>> i2, o <<= 32 - i2;
    } else if (l === 20)
      a = 32, r = g, g = o, o = 0;
    else {
      const i2 = l - s;
      a = 32 - i2, r = g << i2 | o >>> 32 - i2, g = o << i2, o = 0;
    }
    n.__setDigit(e - 1, r);
    for (let _2 = e - 2; 0 <= _2; _2--)
      0 < a ? (a -= 30, r = g >>> 2, g = g << 30 | o >>> 2, o <<= 30) : r = 0, n.__setDigit(_2, r);
    return n.__trim();
  }
  static __isWhitespace(i) {
    return !!(13 >= i && 9 <= i) || (159 >= i ? 32 == i : 131071 >= i ? 160 == i || 5760 == i : 196607 >= i ? (i &= 131071, 10 >= i || 40 == i || 41 == i || 47 == i || 95 == i || 4096 == i) : 65279 == i);
  }
  static __fromString(i, _ = 0) {
    let t = 0;
    const e = i.length;
    let n = 0;
    if (n === e)
      return _JSBI.__zero();
    let g = i.charCodeAt(n);
    for (; _JSBI.__isWhitespace(g); ) {
      if (++n === e)
        return _JSBI.__zero();
      g = i.charCodeAt(n);
    }
    if (43 === g) {
      if (++n === e)
        return null;
      g = i.charCodeAt(n), t = 1;
    } else if (45 === g) {
      if (++n === e)
        return null;
      g = i.charCodeAt(n), t = -1;
    }
    if (0 === _) {
      if (_ = 10, 48 === g) {
        if (++n === e)
          return _JSBI.__zero();
        if (g = i.charCodeAt(n), 88 === g || 120 === g) {
          if (_ = 16, ++n === e)
            return null;
          g = i.charCodeAt(n);
        } else if (79 === g || 111 === g) {
          if (_ = 8, ++n === e)
            return null;
          g = i.charCodeAt(n);
        } else if (66 === g || 98 === g) {
          if (_ = 2, ++n === e)
            return null;
          g = i.charCodeAt(n);
        }
      }
    } else if (16 === _ && 48 === g) {
      if (++n === e)
        return _JSBI.__zero();
      if (g = i.charCodeAt(n), 88 === g || 120 === g) {
        if (++n === e)
          return null;
        g = i.charCodeAt(n);
      }
    }
    if (0 != t && 10 !== _)
      return null;
    for (; 48 === g; ) {
      if (++n === e)
        return _JSBI.__zero();
      g = i.charCodeAt(n);
    }
    const o = e - n;
    let s = _JSBI.__kMaxBitsPerChar[_], l = _JSBI.__kBitsPerCharTableMultiplier - 1;
    if (o > 1073741824 / s)
      return null;
    const r = s * o + l >>> _JSBI.__kBitsPerCharTableShift, a = new _JSBI(0 | (r + 29) / 30, false), u = 10 > _ ? _ : 10, h = 10 < _ ? _ - 10 : 0;
    if (0 == (_ & _ - 1)) {
      s >>= _JSBI.__kBitsPerCharTableShift;
      const _2 = [], t2 = [];
      let o2 = false;
      do {
        let l2 = 0, r2 = 0;
        for (; ; ) {
          let _3;
          if (g - 48 >>> 0 < u)
            _3 = g - 48;
          else if ((32 | g) - 97 >>> 0 < h)
            _3 = (32 | g) - 87;
          else {
            o2 = true;
            break;
          }
          if (r2 += s, l2 = l2 << s | _3, ++n === e) {
            o2 = true;
            break;
          }
          if (g = i.charCodeAt(n), 30 < r2 + s)
            break;
        }
        _2.push(l2), t2.push(r2);
      } while (!o2);
      _JSBI.__fillFromParts(a, _2, t2);
    } else {
      a.__initializeDigits();
      let t2 = false, o2 = 0;
      do {
        let r2 = 0, b = 1;
        for (; ; ) {
          let s2;
          if (g - 48 >>> 0 < u)
            s2 = g - 48;
          else if ((32 | g) - 97 >>> 0 < h)
            s2 = (32 | g) - 87;
          else {
            t2 = true;
            break;
          }
          const l2 = b * _;
          if (1073741823 < l2)
            break;
          if (b = l2, r2 = r2 * _ + s2, o2++, ++n === e) {
            t2 = true;
            break;
          }
          g = i.charCodeAt(n);
        }
        l = 30 * _JSBI.__kBitsPerCharTableMultiplier - 1;
        const D = 0 | (s * o2 + l >>> _JSBI.__kBitsPerCharTableShift) / 30;
        a.__inplaceMultiplyAdd(b, r2, D);
      } while (!t2);
    }
    if (n !== e) {
      if (!_JSBI.__isWhitespace(g))
        return null;
      for (n++; n < e; n++)
        if (g = i.charCodeAt(n), !_JSBI.__isWhitespace(g))
          return null;
    }
    return a.sign = -1 == t, a.__trim();
  }
  static __fillFromParts(_, t, e) {
    let n = 0, g = 0, o = 0;
    for (let s = t.length - 1; 0 <= s; s--) {
      const i = t[s], l = e[s];
      g |= i << o, o += l, 30 === o ? (_.__setDigit(n++, g), o = 0, g = 0) : 30 < o && (_.__setDigit(n++, 1073741823 & g), o -= 30, g = i >>> l - o);
    }
    if (0 !== g) {
      if (n >= _.length)
        throw new Error("implementation bug");
      _.__setDigit(n++, g);
    }
    for (; n < _.length; n++)
      _.__setDigit(n, 0);
  }
  static __toStringBasePowerOfTwo(_, i) {
    const t = _.length;
    let e = i - 1;
    e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e);
    const n = e, g = i - 1, o = _.__digit(t - 1), s = _JSBI.__clz30(o);
    let l = 0 | (30 * t - s + n - 1) / n;
    if (_.sign && l++, 268435456 < l)
      throw new Error("string too long");
    const r = Array(l);
    let a = l - 1, u = 0, d = 0;
    for (let e2 = 0; e2 < t - 1; e2++) {
      const i2 = _.__digit(e2), t2 = (u | i2 << d) & g;
      r[a--] = _JSBI.__kConversionChars[t2];
      const o2 = n - d;
      for (u = i2 >>> o2, d = 30 - o2; d >= n; )
        r[a--] = _JSBI.__kConversionChars[u & g], u >>>= n, d -= n;
    }
    const h = (u | o << d) & g;
    for (r[a--] = _JSBI.__kConversionChars[h], u = o >>> n - d; 0 !== u; )
      r[a--] = _JSBI.__kConversionChars[u & g], u >>>= n;
    if (_.sign && (r[a--] = "-"), -1 != a)
      throw new Error("implementation bug");
    return r.join("");
  }
  static __toStringGeneric(_, i, t) {
    const e = _.length;
    if (0 === e)
      return "";
    if (1 === e) {
      let e2 = _.__unsignedDigit(0).toString(i);
      return false === t && _.sign && (e2 = "-" + e2), e2;
    }
    const n = 30 * e - _JSBI.__clz30(_.__digit(e - 1)), g = _JSBI.__kMaxBitsPerChar[i], o = g - 1;
    let s = n * _JSBI.__kBitsPerCharTableMultiplier;
    s += o - 1, s = 0 | s / o;
    const l = s + 1 >> 1, r = _JSBI.exponentiate(_JSBI.__oneDigit(i, false), _JSBI.__oneDigit(l, false));
    let a, u;
    const d = r.__unsignedDigit(0);
    if (1 === r.length && 32767 >= d) {
      a = new _JSBI(_.length, false), a.__initializeDigits();
      let t2 = 0;
      for (let e2 = 2 * _.length - 1; 0 <= e2; e2--) {
        const i2 = t2 << 15 | _.__halfDigit(e2);
        a.__setHalfDigit(e2, 0 | i2 / d), t2 = 0 | i2 % d;
      }
      u = t2.toString(i);
    } else {
      const t2 = _JSBI.__absoluteDivLarge(_, r, true, true);
      a = t2.quotient;
      const e2 = t2.remainder.__trim();
      u = _JSBI.__toStringGeneric(e2, i, true);
    }
    a.__trim();
    let h = _JSBI.__toStringGeneric(a, i, true);
    for (; u.length < l; )
      u = "0" + u;
    return false === t && _.sign && (h = "-" + h), h + u;
  }
  static __unequalSign(i) {
    return i ? -1 : 1;
  }
  static __absoluteGreater(i) {
    return i ? -1 : 1;
  }
  static __absoluteLess(i) {
    return i ? 1 : -1;
  }
  static __compareToBigInt(i, _) {
    const t = i.sign;
    if (t !== _.sign)
      return _JSBI.__unequalSign(t);
    const e = _JSBI.__absoluteCompare(i, _);
    return 0 < e ? _JSBI.__absoluteGreater(t) : 0 > e ? _JSBI.__absoluteLess(t) : 0;
  }
  static __compareToNumber(i, _) {
    if (_JSBI.__isOneDigitInt(_)) {
      const t = i.sign, e = 0 > _;
      if (t !== e)
        return _JSBI.__unequalSign(t);
      if (0 === i.length) {
        if (e)
          throw new Error("implementation bug");
        return 0 === _ ? 0 : -1;
      }
      if (1 < i.length)
        return _JSBI.__absoluteGreater(t);
      const n = Math.abs(_), g = i.__unsignedDigit(0);
      return g > n ? _JSBI.__absoluteGreater(t) : g < n ? _JSBI.__absoluteLess(t) : 0;
    }
    return _JSBI.__compareToDouble(i, _);
  }
  static __compareToDouble(i, _) {
    if (_ !== _)
      return _;
    if (_ === 1 / 0)
      return -1;
    if (_ === -Infinity)
      return 1;
    const t = i.sign;
    if (t !== 0 > _)
      return _JSBI.__unequalSign(t);
    if (0 === _)
      throw new Error("implementation bug: should be handled elsewhere");
    if (0 === i.length)
      return -1;
    _JSBI.__kBitConversionDouble[0] = _;
    const e = 2047 & _JSBI.__kBitConversionInts[1] >>> 20;
    if (2047 == e)
      throw new Error("implementation bug: handled elsewhere");
    const n = e - 1023;
    if (0 > n)
      return _JSBI.__absoluteGreater(t);
    const g = i.length;
    let o = i.__digit(g - 1);
    const s = _JSBI.__clz30(o), l = 30 * g - s, r = n + 1;
    if (l < r)
      return _JSBI.__absoluteLess(t);
    if (l > r)
      return _JSBI.__absoluteGreater(t);
    let a = 1048576 | 1048575 & _JSBI.__kBitConversionInts[1], u = _JSBI.__kBitConversionInts[0];
    const d = 20, h = 29 - s;
    if (h !== (0 | (l - 1) % 30))
      throw new Error("implementation bug");
    let m, b = 0;
    if (20 > h) {
      const i2 = d - h;
      b = i2 + 32, m = a >>> i2, a = a << 32 - i2 | u >>> i2, u <<= 32 - i2;
    } else if (20 === h)
      b = 32, m = a, a = u, u = 0;
    else {
      const i2 = h - d;
      b = 32 - i2, m = a << i2 | u >>> 32 - i2, a = u << i2, u = 0;
    }
    if (o >>>= 0, m >>>= 0, o > m)
      return _JSBI.__absoluteGreater(t);
    if (o < m)
      return _JSBI.__absoluteLess(t);
    for (let e2 = g - 2; 0 <= e2; e2--) {
      0 < b ? (b -= 30, m = a >>> 2, a = a << 30 | u >>> 2, u <<= 30) : m = 0;
      const _2 = i.__unsignedDigit(e2);
      if (_2 > m)
        return _JSBI.__absoluteGreater(t);
      if (_2 < m)
        return _JSBI.__absoluteLess(t);
    }
    if (0 !== a || 0 !== u) {
      if (0 === b)
        throw new Error("implementation bug");
      return _JSBI.__absoluteLess(t);
    }
    return 0;
  }
  static __equalToNumber(i, _) {
    var t = Math.abs;
    return _JSBI.__isOneDigitInt(_) ? 0 === _ ? 0 === i.length : 1 === i.length && i.sign === 0 > _ && i.__unsignedDigit(0) === t(_) : 0 === _JSBI.__compareToDouble(i, _);
  }
  static __comparisonResultToBool(i, _) {
    return 0 === _ ? 0 > i : 1 === _ ? 0 >= i : 2 === _ ? 0 < i : 3 === _ ? 0 <= i : void 0;
  }
  static __compare(i, _, t) {
    if (i = _JSBI.__toPrimitive(i), _ = _JSBI.__toPrimitive(_), "string" == typeof i && "string" == typeof _)
      switch (t) {
        case 0:
          return i < _;
        case 1:
          return i <= _;
        case 2:
          return i > _;
        case 3:
          return i >= _;
      }
    if (_JSBI.__isBigInt(i) && "string" == typeof _)
      return _ = _JSBI.__fromString(_), null !== _ && _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i, _), t);
    if ("string" == typeof i && _JSBI.__isBigInt(_))
      return i = _JSBI.__fromString(i), null !== i && _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i, _), t);
    if (i = _JSBI.__toNumeric(i), _ = _JSBI.__toNumeric(_), _JSBI.__isBigInt(i)) {
      if (_JSBI.__isBigInt(_))
        return _JSBI.__comparisonResultToBool(_JSBI.__compareToBigInt(i, _), t);
      if ("number" != typeof _)
        throw new Error("implementation bug");
      return _JSBI.__comparisonResultToBool(_JSBI.__compareToNumber(i, _), t);
    }
    if ("number" != typeof i)
      throw new Error("implementation bug");
    if (_JSBI.__isBigInt(_))
      return _JSBI.__comparisonResultToBool(_JSBI.__compareToNumber(_, i), 2 ^ t);
    if ("number" != typeof _)
      throw new Error("implementation bug");
    return 0 === t ? i < _ : 1 === t ? i <= _ : 2 === t ? i > _ : 3 === t ? i >= _ : void 0;
  }
  __clzmsd() {
    return _JSBI.__clz30(this.__digit(this.length - 1));
  }
  static __absoluteAdd(_, t, e) {
    if (_.length < t.length)
      return _JSBI.__absoluteAdd(t, _, e);
    if (0 === _.length)
      return _;
    if (0 === t.length)
      return _.sign === e ? _ : _JSBI.unaryMinus(_);
    let n = _.length;
    (0 === _.__clzmsd() || t.length === _.length && 0 === t.__clzmsd()) && n++;
    const g = new _JSBI(n, e);
    let o = 0, s = 0;
    for (; s < t.length; s++) {
      const i = _.__digit(s) + t.__digit(s) + o;
      o = i >>> 30, g.__setDigit(s, 1073741823 & i);
    }
    for (; s < _.length; s++) {
      const i = _.__digit(s) + o;
      o = i >>> 30, g.__setDigit(s, 1073741823 & i);
    }
    return s < g.length && g.__setDigit(s, o), g.__trim();
  }
  static __absoluteSub(_, t, e) {
    if (0 === _.length)
      return _;
    if (0 === t.length)
      return _.sign === e ? _ : _JSBI.unaryMinus(_);
    const n = new _JSBI(_.length, e);
    let g = 0, o = 0;
    for (; o < t.length; o++) {
      const i = _.__digit(o) - t.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    for (; o < _.length; o++) {
      const i = _.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    return n.__trim();
  }
  static __absoluteAddOne(_, i, t = null) {
    const e = _.length;
    null === t ? t = new _JSBI(e, i) : t.sign = i;
    let n = 1;
    for (let g = 0; g < e; g++) {
      const i2 = _.__digit(g) + n;
      n = i2 >>> 30, t.__setDigit(g, 1073741823 & i2);
    }
    return 0 != n && t.__setDigitGrow(e, 1), t;
  }
  static __absoluteSubOne(_, t) {
    const e = _.length;
    t = t || e;
    const n = new _JSBI(t, false);
    let g = 1;
    for (let o = 0; o < e; o++) {
      const i = _.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    if (0 != g)
      throw new Error("implementation bug");
    for (let g2 = e; g2 < t; g2++)
      n.__setDigit(g2, 0);
    return n;
  }
  static __absoluteAnd(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = o;
    null === e ? e = new _JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) & t.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteAndNot(_, t, e = null) {
    const n = _.length, g = t.length;
    let o = g;
    n < g && (o = n);
    let s = n;
    null === e ? e = new _JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) & ~t.__digit(l));
    for (; l < n; l++)
      e.__setDigit(l, _.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteOr(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = n;
    null === e ? e = new _JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) | t.__digit(l));
    for (; l < n; l++)
      e.__setDigit(l, _.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteXor(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = n;
    null === e ? e = new _JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) ^ t.__digit(l));
    for (; l < n; l++)
      e.__setDigit(l, _.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteCompare(_, t) {
    const e = _.length - t.length;
    if (0 != e)
      return e;
    let n = _.length - 1;
    for (; 0 <= n && _.__digit(n) === t.__digit(n); )
      n--;
    return 0 > n ? 0 : _.__unsignedDigit(n) > t.__unsignedDigit(n) ? 1 : -1;
  }
  static __multiplyAccumulate(_, t, e, n) {
    if (0 === t)
      return;
    const g = 32767 & t, o = t >>> 15;
    let s = 0, l = 0;
    for (let r, a = 0; a < _.length; a++, n++) {
      r = e.__digit(n);
      const i = _.__digit(a), t2 = 32767 & i, u = i >>> 15, d = _JSBI.__imul(t2, g), h = _JSBI.__imul(t2, o), m = _JSBI.__imul(u, g), b = _JSBI.__imul(u, o);
      r += l + d + s, s = r >>> 30, r &= 1073741823, r += ((32767 & h) << 15) + ((32767 & m) << 15), s += r >>> 30, l = b + (h >>> 15) + (m >>> 15), e.__setDigit(n, 1073741823 & r);
    }
    for (; 0 != s || 0 !== l; n++) {
      let i = e.__digit(n);
      i += s + l, l = 0, s = i >>> 30, e.__setDigit(n, 1073741823 & i);
    }
  }
  static __internalMultiplyAdd(_, t, e, g, o) {
    let s = e, l = 0;
    for (let n = 0; n < g; n++) {
      const i = _.__digit(n), e2 = _JSBI.__imul(32767 & i, t), g2 = _JSBI.__imul(i >>> 15, t), a = e2 + ((32767 & g2) << 15) + l + s;
      s = a >>> 30, l = g2 >>> 15, o.__setDigit(n, 1073741823 & a);
    }
    if (o.length > g)
      for (o.__setDigit(g++, s + l); g < o.length; )
        o.__setDigit(g++, 0);
    else if (0 !== s + l)
      throw new Error("implementation bug");
  }
  __inplaceMultiplyAdd(i, _, t) {
    t > this.length && (t = this.length);
    const e = 32767 & i, n = i >>> 15;
    let g = 0, o = _;
    for (let s = 0; s < t; s++) {
      const i2 = this.__digit(s), _2 = 32767 & i2, t2 = i2 >>> 15, l = _JSBI.__imul(_2, e), r = _JSBI.__imul(_2, n), a = _JSBI.__imul(t2, e), u = _JSBI.__imul(t2, n);
      let d = o + l + g;
      g = d >>> 30, d &= 1073741823, d += ((32767 & r) << 15) + ((32767 & a) << 15), g += d >>> 30, o = u + (r >>> 15) + (a >>> 15), this.__setDigit(s, 1073741823 & d);
    }
    if (0 != g || 0 !== o)
      throw new Error("implementation bug");
  }
  static __absoluteDivSmall(_, t, e = null) {
    null === e && (e = new _JSBI(_.length, false));
    let n = 0;
    for (let g, o = 2 * _.length - 1; 0 <= o; o -= 2) {
      g = (n << 15 | _.__halfDigit(o)) >>> 0;
      const i = 0 | g / t;
      n = 0 | g % t, g = (n << 15 | _.__halfDigit(o - 1)) >>> 0;
      const s = 0 | g / t;
      n = 0 | g % t, e.__setDigit(o >>> 1, i << 15 | s);
    }
    return e;
  }
  static __absoluteModSmall(_, t) {
    let e = 0;
    for (let n = 2 * _.length - 1; 0 <= n; n--) {
      const i = (e << 15 | _.__halfDigit(n)) >>> 0;
      e = 0 | i % t;
    }
    return e;
  }
  static __absoluteDivLarge(i, _, t, e) {
    const g = _.__halfDigitLength(), n = _.length, o = i.__halfDigitLength() - g;
    let s = null;
    t && (s = new _JSBI(o + 2 >>> 1, false), s.__initializeDigits());
    const l = new _JSBI(g + 2 >>> 1, false);
    l.__initializeDigits();
    const r = _JSBI.__clz15(_.__halfDigit(g - 1));
    0 < r && (_ = _JSBI.__specialLeftShift(_, r, 0));
    const a = _JSBI.__specialLeftShift(i, r, 1), u = _.__halfDigit(g - 1);
    let d = 0;
    for (let r2, h = o; 0 <= h; h--) {
      r2 = 32767;
      const i2 = a.__halfDigit(h + g);
      if (i2 !== u) {
        const t2 = (i2 << 15 | a.__halfDigit(h + g - 1)) >>> 0;
        r2 = 0 | t2 / u;
        let e3 = 0 | t2 % u;
        const n2 = _.__halfDigit(g - 2), o2 = a.__halfDigit(h + g - 2);
        for (; _JSBI.__imul(r2, n2) >>> 0 > (e3 << 16 | o2) >>> 0 && (r2--, e3 += u, !(32767 < e3)); )
          ;
      }
      _JSBI.__internalMultiplyAdd(_, r2, 0, n, l);
      let e2 = a.__inplaceSub(l, h, g + 1);
      0 !== e2 && (e2 = a.__inplaceAdd(_, h, g), a.__setHalfDigit(h + g, 32767 & a.__halfDigit(h + g) + e2), r2--), t && (1 & h ? d = r2 << 15 : s.__setDigit(h >>> 1, d | r2));
    }
    if (e)
      return a.__inplaceRightShift(r), t ? { quotient: s, remainder: a } : a;
    if (t)
      return s;
    throw new Error("unreachable");
  }
  static __clz15(i) {
    return _JSBI.__clz30(i) - 15;
  }
  __inplaceAdd(_, t, e) {
    let n = 0;
    for (let g = 0; g < e; g++) {
      const i = this.__halfDigit(t + g) + _.__halfDigit(g) + n;
      n = i >>> 15, this.__setHalfDigit(t + g, 32767 & i);
    }
    return n;
  }
  __inplaceSub(_, t, e) {
    let n = 0;
    if (1 & t) {
      t >>= 1;
      let g = this.__digit(t), o = 32767 & g, s = 0;
      for (; s < e - 1 >>> 1; s++) {
        const i2 = _.__digit(s), e2 = (g >>> 15) - (32767 & i2) - n;
        n = 1 & e2 >>> 15, this.__setDigit(t + s, (32767 & e2) << 15 | 32767 & o), g = this.__digit(t + s + 1), o = (32767 & g) - (i2 >>> 15) - n, n = 1 & o >>> 15;
      }
      const i = _.__digit(s), l = (g >>> 15) - (32767 & i) - n;
      n = 1 & l >>> 15, this.__setDigit(t + s, (32767 & l) << 15 | 32767 & o);
      if (t + s + 1 >= this.length)
        throw new RangeError("out of bounds");
      0 == (1 & e) && (g = this.__digit(t + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15, this.__setDigit(t + _.length, 1073709056 & g | 32767 & o));
    } else {
      t >>= 1;
      let g = 0;
      for (; g < _.length - 1; g++) {
        const i2 = this.__digit(t + g), e2 = _.__digit(g), o2 = (32767 & i2) - (32767 & e2) - n;
        n = 1 & o2 >>> 15;
        const s2 = (i2 >>> 15) - (e2 >>> 15) - n;
        n = 1 & s2 >>> 15, this.__setDigit(t + g, (32767 & s2) << 15 | 32767 & o2);
      }
      const i = this.__digit(t + g), o = _.__digit(g), s = (32767 & i) - (32767 & o) - n;
      n = 1 & s >>> 15;
      let l = 0;
      0 == (1 & e) && (l = (i >>> 15) - (o >>> 15) - n, n = 1 & l >>> 15), this.__setDigit(t + g, (32767 & l) << 15 | 32767 & s);
    }
    return n;
  }
  __inplaceRightShift(_) {
    if (0 === _)
      return;
    let t = this.__digit(0) >>> _;
    const e = this.length - 1;
    for (let n = 0; n < e; n++) {
      const i = this.__digit(n + 1);
      this.__setDigit(n, 1073741823 & i << 30 - _ | t), t = i >>> _;
    }
    this.__setDigit(e, t);
  }
  static __specialLeftShift(_, t, e) {
    const g = _.length, n = new _JSBI(g + e, false);
    if (0 === t) {
      for (let t2 = 0; t2 < g; t2++)
        n.__setDigit(t2, _.__digit(t2));
      return 0 < e && n.__setDigit(g, 0), n;
    }
    let o = 0;
    for (let s = 0; s < g; s++) {
      const i = _.__digit(s);
      n.__setDigit(s, 1073741823 & i << t | o), o = i >>> 30 - t;
    }
    return 0 < e && n.__setDigit(g, o), n;
  }
  static __leftShiftByAbsolute(_, i) {
    const t = _JSBI.__toShiftAmount(i);
    if (0 > t)
      throw new RangeError("BigInt too big");
    const e = 0 | t / 30, n = t % 30, g = _.length, o = 0 !== n && 0 != _.__digit(g - 1) >>> 30 - n, s = g + e + (o ? 1 : 0), l = new _JSBI(s, _.sign);
    if (0 === n) {
      let t2 = 0;
      for (; t2 < e; t2++)
        l.__setDigit(t2, 0);
      for (; t2 < s; t2++)
        l.__setDigit(t2, _.__digit(t2 - e));
    } else {
      let t2 = 0;
      for (let _2 = 0; _2 < e; _2++)
        l.__setDigit(_2, 0);
      for (let o2 = 0; o2 < g; o2++) {
        const i2 = _.__digit(o2);
        l.__setDigit(o2 + e, 1073741823 & i2 << n | t2), t2 = i2 >>> 30 - n;
      }
      if (o)
        l.__setDigit(g + e, t2);
      else if (0 !== t2)
        throw new Error("implementation bug");
    }
    return l.__trim();
  }
  static __rightShiftByAbsolute(_, i) {
    const t = _.length, e = _.sign, n = _JSBI.__toShiftAmount(i);
    if (0 > n)
      return _JSBI.__rightShiftByMaximum(e);
    const g = 0 | n / 30, o = n % 30;
    let s = t - g;
    if (0 >= s)
      return _JSBI.__rightShiftByMaximum(e);
    let l = false;
    if (e) {
      if (0 != (_.__digit(g) & (1 << o) - 1))
        l = true;
      else
        for (let t2 = 0; t2 < g; t2++)
          if (0 !== _.__digit(t2)) {
            l = true;
            break;
          }
    }
    if (l && 0 === o) {
      const i2 = _.__digit(t - 1);
      0 == ~i2 && s++;
    }
    let r = new _JSBI(s, e);
    if (0 === o) {
      r.__setDigit(s - 1, 0);
      for (let e2 = g; e2 < t; e2++)
        r.__setDigit(e2 - g, _.__digit(e2));
    } else {
      let e2 = _.__digit(g) >>> o;
      const n2 = t - g - 1;
      for (let t2 = 0; t2 < n2; t2++) {
        const i2 = _.__digit(t2 + g + 1);
        r.__setDigit(t2, 1073741823 & i2 << 30 - o | e2), e2 = i2 >>> o;
      }
      r.__setDigit(n2, e2);
    }
    return l && (r = _JSBI.__absoluteAddOne(r, true, r)), r.__trim();
  }
  static __rightShiftByMaximum(i) {
    return i ? _JSBI.__oneDigit(1, true) : _JSBI.__zero();
  }
  static __toShiftAmount(i) {
    if (1 < i.length)
      return -1;
    const _ = i.__unsignedDigit(0);
    return _ > _JSBI.__kMaxLengthBits ? -1 : _;
  }
  static __toPrimitive(i, _ = "default") {
    if ("object" != typeof i)
      return i;
    if (i.constructor === _JSBI)
      return i;
    if ("undefined" != typeof Symbol && "symbol" == typeof Symbol.toPrimitive) {
      const t2 = i[Symbol.toPrimitive];
      if (t2) {
        const i2 = t2(_);
        if ("object" != typeof i2)
          return i2;
        throw new TypeError("Cannot convert object to primitive value");
      }
    }
    const t = i.valueOf;
    if (t) {
      const _2 = t.call(i);
      if ("object" != typeof _2)
        return _2;
    }
    const e = i.toString;
    if (e) {
      const _2 = e.call(i);
      if ("object" != typeof _2)
        return _2;
    }
    throw new TypeError("Cannot convert object to primitive value");
  }
  static __toNumeric(i) {
    return _JSBI.__isBigInt(i) ? i : +i;
  }
  static __isBigInt(i) {
    return "object" == typeof i && null !== i && i.constructor === _JSBI;
  }
  static __truncateToNBits(i, _) {
    const t = 0 | (i + 29) / 30, e = new _JSBI(t, _.sign), n = t - 1;
    for (let t2 = 0; t2 < n; t2++)
      e.__setDigit(t2, _.__digit(t2));
    let g = _.__digit(n);
    if (0 != i % 30) {
      const _2 = 32 - i % 30;
      g = g << _2 >>> _2;
    }
    return e.__setDigit(n, g), e.__trim();
  }
  static __truncateAndSubFromPowerOfTwo(_, t, e) {
    var n = Math.min;
    const g = 0 | (_ + 29) / 30, o = new _JSBI(g, e);
    let s = 0;
    const l = g - 1;
    let a = 0;
    for (const i = n(l, t.length); s < i; s++) {
      const i2 = 0 - t.__digit(s) - a;
      a = 1 & i2 >>> 30, o.__setDigit(s, 1073741823 & i2);
    }
    for (; s < l; s++)
      o.__setDigit(s, 0 | 1073741823 & -a);
    let u = l < t.length ? t.__digit(l) : 0;
    const d = _ % 30;
    let h;
    if (0 == d)
      h = 0 - u - a, h &= 1073741823;
    else {
      const i = 32 - d;
      u = u << i >>> i;
      const _2 = 1 << 32 - i;
      h = _2 - u - a, h &= _2 - 1;
    }
    return o.__setDigit(l, h), o.__trim();
  }
  __digit(_) {
    return this[_];
  }
  __unsignedDigit(_) {
    return this[_] >>> 0;
  }
  __setDigit(_, i) {
    this[_] = 0 | i;
  }
  __setDigitGrow(_, i) {
    this[_] = 0 | i;
  }
  __halfDigitLength() {
    const i = this.length;
    return 32767 >= this.__unsignedDigit(i - 1) ? 2 * i - 1 : 2 * i;
  }
  __halfDigit(_) {
    return 32767 & this[_ >>> 1] >>> 15 * (1 & _);
  }
  __setHalfDigit(_, i) {
    const t = _ >>> 1, e = this.__digit(t), n = 1 & _ ? 32767 & e | i << 15 : 1073709056 & e | 32767 & i;
    this.__setDigit(t, n);
  }
  static __digitPow(i, _) {
    let t = 1;
    for (; 0 < _; )
      1 & _ && (t *= i), _ >>>= 1, i *= i;
    return t;
  }
  static __isOneDigitInt(i) {
    return (1073741823 & i) === i;
  }
};
JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__clz30 = Math.clz32 ? function(i) {
  return Math.clz32(i) - 2;
} : function(i) {
  return 0 === i ? 30 : 0 | 29 - (0 | Math.log(i >>> 0) / Math.LN2);
}, JSBI.__imul = Math.imul || function(i, _) {
  return 0 | i * _;
};
var jsbi_default = JSBI;

// node_modules/@azure/cosmos/dist-esm/src/utils/hashing/encoding/prefix.js
var BytePrefix = {
  Undefined: "00",
  Null: "01",
  False: "02",
  True: "03",
  MinNumber: "04",
  Number: "05",
  MaxNumber: "06",
  MinString: "07",
  String: "08",
  MaxString: "09",
  Int64: "0a",
  Int32: "0b",
  Int16: "0c",
  Int8: "0d",
  Uint64: "0e",
  Uint32: "0f",
  Uint16: "10",
  Uint8: "11",
  Binary: "12",
  Guid: "13",
  Float: "14",
  Infinity: "FF"
};

// node_modules/@azure/cosmos/dist-esm/src/utils/hashing/encoding/number.js
function writeNumberForBinaryEncodingJSBI(hash) {
  let payload = encodeNumberAsUInt64JSBI(hash);
  let outputStream = Buffer.from(BytePrefix.Number, "hex");
  const firstChunk = jsbi_default.asUintN(64, jsbi_default.signedRightShift(payload, jsbi_default.BigInt(56)));
  outputStream = Buffer.concat([outputStream, Buffer.from(firstChunk.toString(16), "hex")]);
  payload = jsbi_default.asUintN(64, jsbi_default.leftShift(jsbi_default.BigInt(payload), jsbi_default.BigInt(8)));
  let byteToWrite = jsbi_default.BigInt(0);
  let firstIteration = false;
  let shifted;
  let padded;
  do {
    if (!firstIteration) {
      padded = byteToWrite.toString(16).padStart(2, "0");
      if (padded !== "00") {
        outputStream = Buffer.concat([outputStream, Buffer.from(padded, "hex")]);
      }
    } else {
      firstIteration = false;
    }
    shifted = jsbi_default.asUintN(64, jsbi_default.signedRightShift(payload, jsbi_default.BigInt(56)));
    byteToWrite = jsbi_default.asUintN(64, jsbi_default.bitwiseOr(shifted, jsbi_default.BigInt(1)));
    payload = jsbi_default.asUintN(64, jsbi_default.leftShift(payload, jsbi_default.BigInt(7)));
  } while (jsbi_default.notEqual(payload, jsbi_default.BigInt(0)));
  const lastChunk = jsbi_default.asUintN(64, jsbi_default.bitwiseAnd(byteToWrite, jsbi_default.BigInt(254)));
  padded = lastChunk.toString(16).padStart(2, "0");
  if (padded !== "00") {
    outputStream = Buffer.concat([outputStream, Buffer.from(padded, "hex")]);
  }
  return outputStream;
}
function encodeNumberAsUInt64JSBI(value) {
  const rawValueBits = getRawBitsJSBI(value);
  const mask = jsbi_default.BigInt(9223372036854776e3);
  const returned = rawValueBits < mask ? jsbi_default.bitwiseXor(rawValueBits, mask) : jsbi_default.add(jsbi_default.bitwiseNot(rawValueBits), jsbi_default.BigInt(1));
  return returned;
}
function doubleToByteArrayJSBI(double) {
  const output = Buffer.alloc(8);
  const lng = getRawBitsJSBI(double);
  for (let i = 0; i < 8; i++) {
    output[i] = jsbi_default.toNumber(jsbi_default.bitwiseAnd(jsbi_default.signedRightShift(lng, jsbi_default.multiply(jsbi_default.BigInt(i), jsbi_default.BigInt(8))), jsbi_default.BigInt(255)));
  }
  return output;
}
function getRawBitsJSBI(value) {
  const view = new DataView(new ArrayBuffer(8));
  view.setFloat64(0, value);
  return jsbi_default.BigInt(`0x${buf2hex(view.buffer)}`);
}
function buf2hex(buffer) {
  return Array.prototype.map.call(new Uint8Array(buffer), (x) => ("00" + x.toString(16)).slice(-2)).join("");
}

// node_modules/@azure/cosmos/dist-esm/src/utils/hashing/murmurHash.js
function _x86Multiply(m, n) {
  return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
}
function _x86Rotl(m, n) {
  return m << n | m >>> 32 - n;
}
function _x86Fmix(h) {
  h ^= h >>> 16;
  h = _x86Multiply(h, 2246822507);
  h ^= h >>> 13;
  h = _x86Multiply(h, 3266489909);
  h ^= h >>> 16;
  return h;
}
function _x64Add(m, n) {
  m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
  n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
  const o = [0, 0, 0, 0];
  o[3] += m[3] + n[3];
  o[2] += o[3] >>> 16;
  o[3] &= 65535;
  o[2] += m[2] + n[2];
  o[1] += o[2] >>> 16;
  o[2] &= 65535;
  o[1] += m[1] + n[1];
  o[0] += o[1] >>> 16;
  o[1] &= 65535;
  o[0] += m[0] + n[0];
  o[0] &= 65535;
  return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
}
function _x64Multiply(m, n) {
  m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
  n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
  const o = [0, 0, 0, 0];
  o[3] += m[3] * n[3];
  o[2] += o[3] >>> 16;
  o[3] &= 65535;
  o[2] += m[2] * n[3];
  o[1] += o[2] >>> 16;
  o[2] &= 65535;
  o[2] += m[3] * n[2];
  o[1] += o[2] >>> 16;
  o[2] &= 65535;
  o[1] += m[1] * n[3];
  o[0] += o[1] >>> 16;
  o[1] &= 65535;
  o[1] += m[2] * n[2];
  o[0] += o[1] >>> 16;
  o[1] &= 65535;
  o[1] += m[3] * n[1];
  o[0] += o[1] >>> 16;
  o[1] &= 65535;
  o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
  o[0] &= 65535;
  return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
}
function _x64Rotl(m, n) {
  n %= 64;
  if (n === 32) {
    return [m[1], m[0]];
  } else if (n < 32) {
    return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
  } else {
    n -= 32;
    return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
  }
}
function _x64LeftShift(m, n) {
  n %= 64;
  if (n === 0) {
    return m;
  } else if (n < 32) {
    return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
  } else {
    return [m[1] << n - 32, 0];
  }
}
function _x64Xor(m, n) {
  return [m[0] ^ n[0], m[1] ^ n[1]];
}
function _x64Fmix(h) {
  h = _x64Xor(h, [0, h[0] >>> 1]);
  h = _x64Multiply(h, [4283543511, 3981806797]);
  h = _x64Xor(h, [0, h[0] >>> 1]);
  h = _x64Multiply(h, [3301882366, 444984403]);
  h = _x64Xor(h, [0, h[0] >>> 1]);
  return h;
}
function x86Hash32(bytes, seed) {
  seed = seed || 0;
  const remainder = bytes.length % 4;
  const blocks = bytes.length - remainder;
  let h1 = seed;
  let k1 = 0;
  const c1 = 3432918353;
  const c2 = 461845907;
  let j = 0;
  for (let i = 0; i < blocks; i = i + 4) {
    k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
    k1 = _x86Multiply(k1, c1);
    k1 = _x86Rotl(k1, 15);
    k1 = _x86Multiply(k1, c2);
    h1 ^= k1;
    h1 = _x86Rotl(h1, 13);
    h1 = _x86Multiply(h1, 5) + 3864292196;
    j = i + 4;
  }
  k1 = 0;
  switch (remainder) {
    case 3:
      k1 ^= bytes[j + 2] << 16;
    case 2:
      k1 ^= bytes[j + 1] << 8;
    case 1:
      k1 ^= bytes[j];
      k1 = _x86Multiply(k1, c1);
      k1 = _x86Rotl(k1, 15);
      k1 = _x86Multiply(k1, c2);
      h1 ^= k1;
  }
  h1 ^= bytes.length;
  h1 = _x86Fmix(h1);
  return h1 >>> 0;
}
function x86Hash128(bytes, seed) {
  seed = seed || 0;
  const remainder = bytes.length % 16;
  const blocks = bytes.length - remainder;
  let h1 = seed;
  let h2 = seed;
  let h3 = seed;
  let h4 = seed;
  let k1 = 0;
  let k2 = 0;
  let k3 = 0;
  let k4 = 0;
  const c1 = 597399067;
  const c2 = 2869860233;
  const c3 = 951274213;
  const c4 = 2716044179;
  let j = 0;
  for (let i = 0; i < blocks; i = i + 16) {
    k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
    k2 = bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24;
    k3 = bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24;
    k4 = bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24;
    k1 = _x86Multiply(k1, c1);
    k1 = _x86Rotl(k1, 15);
    k1 = _x86Multiply(k1, c2);
    h1 ^= k1;
    h1 = _x86Rotl(h1, 19);
    h1 += h2;
    h1 = _x86Multiply(h1, 5) + 1444728091;
    k2 = _x86Multiply(k2, c2);
    k2 = _x86Rotl(k2, 16);
    k2 = _x86Multiply(k2, c3);
    h2 ^= k2;
    h2 = _x86Rotl(h2, 17);
    h2 += h3;
    h2 = _x86Multiply(h2, 5) + 197830471;
    k3 = _x86Multiply(k3, c3);
    k3 = _x86Rotl(k3, 17);
    k3 = _x86Multiply(k3, c4);
    h3 ^= k3;
    h3 = _x86Rotl(h3, 15);
    h3 += h4;
    h3 = _x86Multiply(h3, 5) + 2530024501;
    k4 = _x86Multiply(k4, c4);
    k4 = _x86Rotl(k4, 18);
    k4 = _x86Multiply(k4, c1);
    h4 ^= k4;
    h4 = _x86Rotl(h4, 13);
    h4 += h1;
    h4 = _x86Multiply(h4, 5) + 850148119;
    j = i + 16;
  }
  k1 = 0;
  k2 = 0;
  k3 = 0;
  k4 = 0;
  switch (remainder) {
    case 15:
      k4 ^= bytes[j + 14] << 16;
    case 14:
      k4 ^= bytes[j + 13] << 8;
    case 13:
      k4 ^= bytes[j + 12];
      k4 = _x86Multiply(k4, c4);
      k4 = _x86Rotl(k4, 18);
      k4 = _x86Multiply(k4, c1);
      h4 ^= k4;
    case 12:
      k3 ^= bytes[j + 11] << 24;
    case 11:
      k3 ^= bytes[j + 10] << 16;
    case 10:
      k3 ^= bytes[j + 9] << 8;
    case 9:
      k3 ^= bytes[j + 8];
      k3 = _x86Multiply(k3, c3);
      k3 = _x86Rotl(k3, 17);
      k3 = _x86Multiply(k3, c4);
      h3 ^= k3;
    case 8:
      k2 ^= bytes[j + 7] << 24;
    case 7:
      k2 ^= bytes[j + 6] << 16;
    case 6:
      k2 ^= bytes[j + 5] << 8;
    case 5:
      k2 ^= bytes[j + 4];
      k2 = _x86Multiply(k2, c2);
      k2 = _x86Rotl(k2, 16);
      k2 = _x86Multiply(k2, c3);
      h2 ^= k2;
    case 4:
      k1 ^= bytes[j + 3] << 24;
    case 3:
      k1 ^= bytes[j + 2] << 16;
    case 2:
      k1 ^= bytes[j + 1] << 8;
    case 1:
      k1 ^= bytes[j];
      k1 = _x86Multiply(k1, c1);
      k1 = _x86Rotl(k1, 15);
      k1 = _x86Multiply(k1, c2);
      h1 ^= k1;
  }
  h1 ^= bytes.length;
  h2 ^= bytes.length;
  h3 ^= bytes.length;
  h4 ^= bytes.length;
  h1 += h2;
  h1 += h3;
  h1 += h4;
  h2 += h1;
  h3 += h1;
  h4 += h1;
  h1 = _x86Fmix(h1);
  h2 = _x86Fmix(h2);
  h3 = _x86Fmix(h3);
  h4 = _x86Fmix(h4);
  h1 += h2;
  h1 += h3;
  h1 += h4;
  h2 += h1;
  h3 += h1;
  h4 += h1;
  return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
}
function x64Hash128(bytes, seed) {
  seed = seed || 0;
  const remainder = bytes.length % 16;
  const blocks = bytes.length - remainder;
  let h1 = [0, seed];
  let h2 = [0, seed];
  let k1 = [0, 0];
  let k2 = [0, 0];
  const c1 = [2277735313, 289559509];
  const c2 = [1291169091, 658871167];
  let j = 0;
  for (let i = 0; i < blocks; i = i + 16) {
    k1 = [
      bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24,
      bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24
    ];
    k2 = [
      bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24,
      bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24
    ];
    k1 = _x64Multiply(k1, c1);
    k1 = _x64Rotl(k1, 31);
    k1 = _x64Multiply(k1, c2);
    h1 = _x64Xor(h1, k1);
    h1 = _x64Rotl(h1, 27);
    h1 = _x64Add(h1, h2);
    h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
    k2 = _x64Multiply(k2, c2);
    k2 = _x64Rotl(k2, 33);
    k2 = _x64Multiply(k2, c1);
    h2 = _x64Xor(h2, k2);
    h2 = _x64Rotl(h2, 31);
    h2 = _x64Add(h2, h1);
    h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
    j = i + 16;
  }
  k1 = [0, 0];
  k2 = [0, 0];
  switch (remainder) {
    case 15:
      k2 = _x64Xor(k2, _x64LeftShift([0, bytes[j + 14]], 48));
    case 14:
      k2 = _x64Xor(k2, _x64LeftShift([0, bytes[j + 13]], 40));
    case 13:
      k2 = _x64Xor(k2, _x64LeftShift([0, bytes[j + 12]], 32));
    case 12:
      k2 = _x64Xor(k2, _x64LeftShift([0, bytes[j + 11]], 24));
    case 11:
      k2 = _x64Xor(k2, _x64LeftShift([0, bytes[j + 10]], 16));
    case 10:
      k2 = _x64Xor(k2, _x64LeftShift([0, bytes[j + 9]], 8));
    case 9:
      k2 = _x64Xor(k2, [0, bytes[j + 8]]);
      k2 = _x64Multiply(k2, c2);
      k2 = _x64Rotl(k2, 33);
      k2 = _x64Multiply(k2, c1);
      h2 = _x64Xor(h2, k2);
    case 8:
      k1 = _x64Xor(k1, _x64LeftShift([0, bytes[j + 7]], 56));
    case 7:
      k1 = _x64Xor(k1, _x64LeftShift([0, bytes[j + 6]], 48));
    case 6:
      k1 = _x64Xor(k1, _x64LeftShift([0, bytes[j + 5]], 40));
    case 5:
      k1 = _x64Xor(k1, _x64LeftShift([0, bytes[j + 4]], 32));
    case 4:
      k1 = _x64Xor(k1, _x64LeftShift([0, bytes[j + 3]], 24));
    case 3:
      k1 = _x64Xor(k1, _x64LeftShift([0, bytes[j + 2]], 16));
    case 2:
      k1 = _x64Xor(k1, _x64LeftShift([0, bytes[j + 1]], 8));
    case 1:
      k1 = _x64Xor(k1, [0, bytes[j]]);
      k1 = _x64Multiply(k1, c1);
      k1 = _x64Rotl(k1, 31);
      k1 = _x64Multiply(k1, c2);
      h1 = _x64Xor(h1, k1);
  }
  h1 = _x64Xor(h1, [0, bytes.length]);
  h2 = _x64Xor(h2, [0, bytes.length]);
  h1 = _x64Add(h1, h2);
  h2 = _x64Add(h2, h1);
  h1 = _x64Fmix(h1);
  h2 = _x64Fmix(h2);
  h1 = _x64Add(h1, h2);
  h2 = _x64Add(h2, h1);
  const h1Buff = Buffer.from(("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8), "hex");
  const h1Reversed = reverse(h1Buff).toString("hex");
  const h2Buff = Buffer.from(("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8), "hex");
  const h2Reversed = reverse(h2Buff).toString("hex");
  return h1Reversed + h2Reversed;
}
function reverse(buff) {
  const buffer = Buffer.allocUnsafe(buff.length);
  for (let i = 0, j = buff.length - 1; i <= j; ++i, --j) {
    buffer[i] = buff[j];
    buffer[j] = buff[i];
  }
  return buffer;
}
var murmurHash_default = {
  version: "3.0.0",
  x86: {
    hash32: x86Hash32,
    hash128: x86Hash128
  },
  x64: {
    hash128: x64Hash128
  },
  inputValidation: true
};

// node_modules/@azure/cosmos/dist-esm/src/utils/hashing/v2.js
function hashV2PartitionKey(partitionKey) {
  const toHash = Buffer.concat(partitionKey.map(prefixKeyByType));
  const hash = murmurHash_default.x64.hash128(toHash);
  const reverseBuff = reverse2(Buffer.from(hash, "hex"));
  reverseBuff[0] &= 63;
  return reverseBuff.toString("hex").toUpperCase();
}
function prefixKeyByType(key) {
  let bytes;
  switch (typeof key) {
    case "string": {
      bytes = Buffer.concat([
        Buffer.from(BytePrefix.String, "hex"),
        Buffer.from(key),
        Buffer.from(BytePrefix.Infinity, "hex")
      ]);
      return bytes;
    }
    case "number": {
      const numberBytes = doubleToByteArrayJSBI(key);
      bytes = Buffer.concat([Buffer.from(BytePrefix.Number, "hex"), numberBytes]);
      return bytes;
    }
    case "boolean": {
      const prefix = key ? BytePrefix.True : BytePrefix.False;
      return Buffer.from(prefix, "hex");
    }
    case "object": {
      if (key === null) {
        return Buffer.from(BytePrefix.Null, "hex");
      }
      return Buffer.from(BytePrefix.Undefined, "hex");
    }
    case "undefined": {
      return Buffer.from(BytePrefix.Undefined, "hex");
    }
    default:
      throw new Error(`Unexpected type: ${typeof key}`);
  }
}
function reverse2(buff) {
  const buffer = Buffer.allocUnsafe(buff.length);
  for (let i = 0, j = buff.length - 1; i <= j; ++i, --j) {
    buffer[i] = buff[j];
    buffer[j] = buff[i];
  }
  return buffer;
}

// node_modules/@azure/cosmos/dist-esm/src/utils/hashing/multiHash.js
function hashMultiHashPartitionKey(partitionKey) {
  return partitionKey.map((keys) => hashV2PartitionKey([keys])).join("");
}

// node_modules/@azure/cosmos/dist-esm/src/utils/hashing/encoding/string.js
function writeStringForBinaryEncoding(payload) {
  let outputStream = Buffer.from(BytePrefix.String, "hex");
  const MAX_STRING_BYTES_TO_APPEND = 100;
  const byteArray = [...Buffer.from(payload)];
  const isShortString = payload.length <= MAX_STRING_BYTES_TO_APPEND;
  for (let index = 0; index < (isShortString ? byteArray.length : MAX_STRING_BYTES_TO_APPEND + 1); index++) {
    let charByte = byteArray[index];
    if (charByte < 255) {
      charByte++;
    }
    outputStream = Buffer.concat([outputStream, Buffer.from(charByte.toString(16), "hex")]);
  }
  if (isShortString) {
    outputStream = Buffer.concat([outputStream, Buffer.from(BytePrefix.Undefined, "hex")]);
  }
  return outputStream;
}

// node_modules/@azure/cosmos/dist-esm/src/utils/hashing/v1.js
var MAX_STRING_CHARS = 100;
function hashV1PartitionKey(partitionKey) {
  const key = partitionKey[0];
  const toHash = prefixKeyByType2(key);
  const hash = murmurHash_default.x86.hash32(toHash);
  const encodedJSBI = writeNumberForBinaryEncodingJSBI(hash);
  const encodedValue = encodeByType(key);
  const finalHash = Buffer.concat([encodedJSBI, encodedValue]).toString("hex").toUpperCase();
  return finalHash;
}
function prefixKeyByType2(key) {
  let bytes;
  switch (typeof key) {
    case "string": {
      const truncated = key.substr(0, MAX_STRING_CHARS);
      bytes = Buffer.concat([
        Buffer.from(BytePrefix.String, "hex"),
        Buffer.from(truncated),
        Buffer.from(BytePrefix.Undefined, "hex")
      ]);
      return bytes;
    }
    case "number": {
      const numberBytes = doubleToByteArrayJSBI(key);
      bytes = Buffer.concat([Buffer.from(BytePrefix.Number, "hex"), numberBytes]);
      return bytes;
    }
    case "boolean": {
      const prefix = key ? BytePrefix.True : BytePrefix.False;
      return Buffer.from(prefix, "hex");
    }
    case "object": {
      if (key === null) {
        return Buffer.from(BytePrefix.Null, "hex");
      }
      return Buffer.from(BytePrefix.Undefined, "hex");
    }
    case "undefined": {
      return Buffer.from(BytePrefix.Undefined, "hex");
    }
    default:
      throw new Error(`Unexpected type: ${typeof key}`);
  }
}
function encodeByType(key) {
  switch (typeof key) {
    case "string": {
      const truncated = key.substr(0, MAX_STRING_CHARS);
      return writeStringForBinaryEncoding(truncated);
    }
    case "number": {
      const encodedJSBI = writeNumberForBinaryEncodingJSBI(key);
      return encodedJSBI;
    }
    case "boolean": {
      const prefix = key ? BytePrefix.True : BytePrefix.False;
      return Buffer.from(prefix, "hex");
    }
    case "object":
      if (key === null) {
        return Buffer.from(BytePrefix.Null, "hex");
      }
      return Buffer.from(BytePrefix.Undefined, "hex");
    case "undefined":
      return Buffer.from(BytePrefix.Undefined, "hex");
    default:
      throw new Error(`Unexpected type: ${typeof key}`);
  }
}

// node_modules/@azure/cosmos/dist-esm/src/utils/hashing/hash.js
function hashPartitionKey(partitionKey, partitionDefinition) {
  const kind = (partitionDefinition === null || partitionDefinition === void 0 ? void 0 : partitionDefinition.kind) || PartitionKeyKind.Hash;
  const isV2 = partitionDefinition && partitionDefinition.version && partitionDefinition.version === PartitionKeyDefinitionVersion.V2;
  switch (kind) {
    case PartitionKeyKind.Hash:
      return isV2 ? hashV2PartitionKey(partitionKey) : hashV1PartitionKey(partitionKey);
    case PartitionKeyKind.MultiHash:
      return hashMultiHashPartitionKey(partitionKey);
  }
}

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/ChangeFeedRange.js
var ChangeFeedRange = class {
  constructor(minInclusive, maxExclusive, continuationToken, epkMinHeader, epkMaxHeader) {
    this.minInclusive = minInclusive;
    this.maxExclusive = maxExclusive;
    this.continuationToken = continuationToken;
    this.epkMinHeader = epkMinHeader;
    this.epkMaxHeader = epkMaxHeader;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/ChangeFeedIteratorResponse.js
var ChangeFeedIteratorResponse = class {
  /**
   * @internal
   */
  constructor(result, count, statusCode, headers, diagnostics, subStatusCode) {
    this.result = result;
    this.count = count;
    this.statusCode = statusCode;
    this.diagnostics = diagnostics;
    this.subStatusCode = subStatusCode;
    this.headers = headers;
  }
  /**
   * Gets the request charge for this request from the Azure Cosmos DB service.
   */
  get requestCharge() {
    const rus = this.headers[Constants.HttpHeaders.RequestCharge];
    return rus ? parseInt(rus, 10) : null;
  }
  /**
   * Gets the activity ID for the request from the Azure Cosmos DB service.
   */
  get activityId() {
    return this.headers[Constants.HttpHeaders.ActivityId];
  }
  /**
   * Gets the continuation token to be used for continuing enumeration of the Azure Cosmos DB service.
   */
  get continuationToken() {
    return this.headers[Constants.HttpHeaders.ContinuationToken];
  }
  /**
   * Gets the session token for use in session consistency reads from the Azure Cosmos DB service.
   */
  get sessionToken() {
    return this.headers[Constants.HttpHeaders.SessionToken];
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/FeedRangeQueue.js
var FeedRangeQueue = class {
  constructor() {
    this.elements = [];
  }
  modifyFirstElement(newItem) {
    if (!this.isEmpty()) {
      this.elements[0] = newItem;
    }
  }
  enqueue(item) {
    this.elements.push(item);
  }
  dequeue() {
    return this.elements.shift();
  }
  peek() {
    return !this.isEmpty() ? this.elements[0] : void 0;
  }
  isEmpty() {
    return this.elements.length === 0;
  }
  moveFirstElementToTheEnd() {
    if (!this.isEmpty()) {
      this.elements.push(this.dequeue());
    }
  }
  /**
   * Returns a snapshot of the queue as an array to be used as Continuation token.
   */
  returnSnapshot() {
    const allFeedRanges = [];
    this.elements.map((element) => {
      const minInclusive = element.epkMinHeader ? element.epkMinHeader : element.minInclusive;
      const maxExclusive = element.epkMaxHeader ? element.epkMaxHeader : element.maxExclusive;
      const feedRangeElement = new ChangeFeedRange(minInclusive, maxExclusive, element.continuationToken);
      allFeedRanges.push(feedRangeElement);
    });
    return allFeedRanges;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/CompositeContinuationToken.js
var CompositeContinuationToken = class {
  constructor(rid, Continuation) {
    this.rid = rid;
    this.Continuation = Continuation;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/ChangeFeedStartFromBeginning.js
var ChangeFeedStartFromBeginning = class {
  constructor(cfResource) {
    this.cfResource = cfResource;
  }
  getCfResource() {
    return this.cfResource;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/ChangeFeedStartFromNow.js
var ChangeFeedStartFromNow = class {
  constructor(cfResource) {
    this.cfResource = cfResource;
  }
  getCfResource() {
    return this.cfResource;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/ChangeFeedStartFromTime.js
var ChangeFeedStartFromTime = class {
  constructor(startTime, cfResource) {
    this.startTime = startTime;
    this.cfResource = cfResource;
  }
  getCfResource() {
    return this.cfResource;
  }
  getStartTime() {
    return this.startTime;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/FeedRange.js
var FeedRange = class _FeedRange {
  /**
   * @internal
   */
  constructor(minInclusive, maxExclusive) {
    if (new.target === _FeedRange) {
      throw new ErrorResponse("Cannot instantiate abstract class FeedRange");
    }
    this.minInclusive = minInclusive;
    this.maxExclusive = maxExclusive;
  }
};
var FeedRangeInternal = class extends FeedRange {
  /* eslint-disable @typescript-eslint/no-useless-constructor */
  constructor(minInclusive, maxExclusive) {
    super(minInclusive, maxExclusive);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/changeFeedUtils.js
function validateChangeFeedIteratorOptions(options) {
  if (!isChangeFeedIteratorOptions(options)) {
    throw new ErrorResponse("Invalid Changefeed Iterator Options.");
  }
  if ((options === null || options === void 0 ? void 0 : options.maxItemCount) && typeof (options === null || options === void 0 ? void 0 : options.maxItemCount) !== "number") {
    throw new ErrorResponse("maxItemCount must be number");
  }
  if ((options === null || options === void 0 ? void 0 : options.maxItemCount) !== void 0 && (options === null || options === void 0 ? void 0 : options.maxItemCount) < 1) {
    throw new ErrorResponse("maxItemCount must be a positive number");
  }
}
function isChangeFeedIteratorOptions(options) {
  if (typeof options !== "object") {
    return false;
  }
  if (Object.keys(options).length === 0 && JSON.stringify(options) === "{}") {
    return true;
  }
  return options && !(isPrimitivePartitionKeyValue(options) || Array.isArray(options));
}
async function extractOverlappingRanges(epkRange, overLappingRange) {
  if (overLappingRange.minInclusive >= epkRange.min && overLappingRange.maxExclusive <= epkRange.max) {
    return [void 0, void 0];
  } else if (overLappingRange.minInclusive <= epkRange.min && overLappingRange.maxExclusive >= epkRange.max) {
    return [epkRange.min, epkRange.max];
  } else if (overLappingRange.minInclusive <= epkRange.min && overLappingRange.maxExclusive <= epkRange.max && overLappingRange.maxExclusive >= epkRange.min) {
    return [epkRange.min, overLappingRange.maxExclusive];
  } else {
    return [overLappingRange.minInclusive, epkRange.max];
  }
}
function isEpkRange(obj) {
  return obj instanceof FeedRangeInternal && typeof obj.minInclusive === "string" && typeof obj.maxExclusive === "string" && obj.minInclusive >= Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey && obj.maxExclusive <= Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey && obj.maxExclusive > obj.minInclusive;
}
function buildInternalChangeFeedOptions(options, continuationToken, startTime) {
  const internalCfOptions = {};
  internalCfOptions.maxItemCount = options === null || options === void 0 ? void 0 : options.maxItemCount;
  internalCfOptions.sessionToken = options === null || options === void 0 ? void 0 : options.sessionToken;
  internalCfOptions.continuationToken = continuationToken;
  internalCfOptions.startTime = startTime;
  return internalCfOptions;
}
function fetchStartTime(changeFeedStartFrom) {
  if (changeFeedStartFrom instanceof ChangeFeedStartFromBeginning) {
    return void 0;
  } else if (changeFeedStartFrom instanceof ChangeFeedStartFromNow) {
    return /* @__PURE__ */ new Date();
  } else if (changeFeedStartFrom instanceof ChangeFeedStartFromTime) {
    return changeFeedStartFrom.getStartTime();
  }
}
function isNullOrEmpty(text) {
  return text === null || text === void 0 || text.trim() === "";
}

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/ChangeFeedForEpkRange.js
var ChangeFeedForEpkRange = class {
  /**
   * @internal
   */
  constructor(clientContext, container, partitionKeyRangeCache, resourceId, resourceLink, url, changeFeedOptions, epkRange) {
    this.clientContext = clientContext;
    this.container = container;
    this.partitionKeyRangeCache = partitionKeyRangeCache;
    this.resourceId = resourceId;
    this.resourceLink = resourceLink;
    this.url = url;
    this.changeFeedOptions = changeFeedOptions;
    this.epkRange = epkRange;
    this.generateContinuationToken = () => {
      return JSON.stringify(new CompositeContinuationToken(this.rId, this.queue.returnSnapshot()));
    };
    this.queue = new FeedRangeQueue();
    this.continuationToken = changeFeedOptions.continuationToken ? JSON.parse(changeFeedOptions.continuationToken) : void 0;
    this.startTime = changeFeedOptions.startTime ? changeFeedOptions.startTime.toUTCString() : void 0;
    this.isInstantiated = false;
  }
  async setIteratorRid(diagnosticNode) {
    const { resource } = await this.container.readInternal(diagnosticNode);
    this.rId = resource._rid;
  }
  continuationTokenRidMatchContainerRid() {
    if (this.continuationToken.rid !== this.rId) {
      return false;
    }
    return true;
  }
  async fillChangeFeedQueue(diagnosticNode) {
    if (this.continuationToken) {
      await this.fetchContinuationTokenFeedRanges(diagnosticNode);
    } else {
      await this.fetchOverLappingFeedRanges(diagnosticNode);
    }
    this.isInstantiated = true;
  }
  /**
   * Fill the queue with the feed ranges overlapping with the given epk range.
   */
  async fetchOverLappingFeedRanges(diagnosticNode) {
    try {
      const overLappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(this.url, this.epkRange, diagnosticNode);
      for (const overLappingRange of overLappingRanges) {
        const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(this.epkRange, overLappingRange);
        const feedRange = new ChangeFeedRange(overLappingRange.minInclusive, overLappingRange.maxExclusive, "", epkMinHeader, epkMaxHeader);
        this.queue.enqueue(feedRange);
      }
    } catch (err) {
      throw new ErrorResponse(err.message);
    }
  }
  /**
   * Fill the queue with feed ranges from continuation token
   */
  async fetchContinuationTokenFeedRanges(diagnosticNode) {
    const contToken = this.continuationToken;
    if (!this.continuationTokenRidMatchContainerRid()) {
      throw new ErrorResponse("The continuation token is not for the current container definition");
    } else {
      for (const cToken of contToken.Continuation) {
        const queryRange = new QueryRange(cToken.minInclusive, cToken.maxExclusive, true, false);
        try {
          const overLappingRanges = await this.partitionKeyRangeCache.getOverlappingRanges(this.url, queryRange, diagnosticNode);
          for (const overLappingRange of overLappingRanges) {
            const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(queryRange, overLappingRange);
            const feedRange = new ChangeFeedRange(overLappingRange.minInclusive, overLappingRange.maxExclusive, cToken.continuationToken, epkMinHeader, epkMaxHeader);
            this.queue.enqueue(feedRange);
          }
        } catch (err) {
          throw new ErrorResponse(err.message);
        }
      }
    }
  }
  /**
   * Change feed is an infinite feed. hasMoreResults is always true.
   */
  get hasMoreResults() {
    return true;
  }
  /**
   * Gets an async iterator which will yield change feed results.
   */
  getAsyncIterator() {
    return __asyncGenerator(this, arguments, function* getAsyncIterator_1() {
      do {
        const result = yield __await(this.readNext());
        yield yield __await(result);
      } while (this.hasMoreResults);
    });
  }
  /**
   * Gets an async iterator which will yield pages of results from Azure Cosmos DB.
   *
   * Keeps iterating over the feedranges and checks if any feed range has new result. Keeps note of the last feed range which returned non 304 result.
   *
   * When same feed range is reached and no new changes are found, a 304 (not Modified) is returned to the end user. Then starts process all over again.
   */
  async readNext() {
    return withDiagnostics(async (diagnosticNode) => {
      if (!this.isInstantiated) {
        await this.setIteratorRid(diagnosticNode);
        await this.fillChangeFeedQueue(diagnosticNode);
      }
      let firstNotModifiedFeedRange = void 0;
      let result;
      do {
        const [processedFeedRange, response] = await this.fetchNext(diagnosticNode);
        result = response;
        if (result !== void 0) {
          {
            if (firstNotModifiedFeedRange === void 0) {
              firstNotModifiedFeedRange = processedFeedRange;
            }
            this.queue.moveFirstElementToTheEnd();
            if (result.statusCode === StatusCodes.Ok) {
              result.headers[Constants.HttpHeaders.ContinuationToken] = this.generateContinuationToken();
              return result;
            }
          }
        }
      } while (!this.checkedAllFeedRanges(firstNotModifiedFeedRange));
      result.headers[Constants.HttpHeaders.ContinuationToken] = this.generateContinuationToken();
      return result;
    }, this.clientContext);
  }
  /**
   * Read feed and retrieves the next page of results in Azure Cosmos DB.
   */
  async fetchNext(diagnosticNode) {
    const feedRange = this.queue.peek();
    if (feedRange) {
      const result = await this.getFeedResponse(feedRange, diagnosticNode);
      const shouldRetry = await this.shouldRetryOnFailure(feedRange, result, diagnosticNode);
      if (shouldRetry) {
        this.queue.dequeue();
        return this.fetchNext(diagnosticNode);
      } else {
        const continuationValueForFeedRange = result.headers[Constants.HttpHeaders.ETag];
        const newFeedRange = this.queue.peek();
        newFeedRange.continuationToken = continuationValueForFeedRange;
        return [[newFeedRange.minInclusive, newFeedRange.maxExclusive], result];
      }
    } else {
      return [[void 0, void 0], void 0];
    }
  }
  checkedAllFeedRanges(firstNotModifiedFeedRange) {
    if (firstNotModifiedFeedRange === void 0) {
      return false;
    }
    const feedRangeQueueFirstElement = this.queue.peek();
    return firstNotModifiedFeedRange[0] === (feedRangeQueueFirstElement === null || feedRangeQueueFirstElement === void 0 ? void 0 : feedRangeQueueFirstElement.minInclusive) && firstNotModifiedFeedRange[1] === (feedRangeQueueFirstElement === null || feedRangeQueueFirstElement === void 0 ? void 0 : feedRangeQueueFirstElement.maxExclusive);
  }
  /**
   * Checks whether the current EpkRange is split into multiple ranges or not.
   *
   * If yes, it force refreshes the partitionKeyRange cache and enqueue children epk ranges.
   */
  async shouldRetryOnFailure(feedRange, response, diagnosticNode) {
    if (response.statusCode === StatusCodes.Ok || response.statusCode === StatusCodes.NotModified) {
      return false;
    }
    const partitionSplit = response.statusCode === StatusCodes.Gone && (response.subStatusCode === SubStatusCodes.PartitionKeyRangeGone || response.subStatusCode === SubStatusCodes.CompletingSplit);
    if (partitionSplit) {
      const queryRange = new QueryRange(feedRange.minInclusive, feedRange.maxExclusive, true, false);
      const resolvedRanges = await this.partitionKeyRangeCache.getOverlappingRanges(this.url, queryRange, diagnosticNode, true);
      if (resolvedRanges.length < 1) {
        throw new ErrorResponse("Partition split/merge detected but no overlapping ranges found.");
      }
      if (resolvedRanges.length >= 1) {
        await this.handleSplit(false, resolvedRanges, queryRange, feedRange.continuationToken);
      }
      return true;
    }
    return false;
  }
  /*
   * Enqueues all the children feed ranges for the given feed range.
   */
  async handleSplit(shiftLeft, resolvedRanges, oldFeedRange, continuationToken) {
    let flag = 0;
    if (shiftLeft) {
      const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(oldFeedRange, resolvedRanges[0]);
      const newFeedRange = new ChangeFeedRange(resolvedRanges[0].minInclusive, resolvedRanges[0].maxExclusive, continuationToken, epkMinHeader, epkMaxHeader);
      this.queue.modifyFirstElement(newFeedRange);
      flag = 1;
    }
    for (let i = flag; i < resolvedRanges.length; i++) {
      const [epkMinHeader, epkMaxHeader] = await extractOverlappingRanges(oldFeedRange, resolvedRanges[i]);
      const newFeedRange = new ChangeFeedRange(resolvedRanges[i].minInclusive, resolvedRanges[i].maxExclusive, continuationToken, epkMinHeader, epkMaxHeader);
      this.queue.enqueue(newFeedRange);
    }
  }
  /**
   * Fetch the partitionKeyRangeId for the given feed range.
   *
   * This partitionKeyRangeId is passed to queryFeed to fetch the results.
   */
  async getPartitionRangeId(feedRange, diagnosticNode) {
    const min = feedRange.epkMinHeader ? feedRange.epkMinHeader : feedRange.minInclusive;
    const max2 = feedRange.epkMaxHeader ? feedRange.epkMaxHeader : feedRange.maxExclusive;
    const queryRange = new QueryRange(min, max2, true, false);
    const resolvedRanges = await this.partitionKeyRangeCache.getOverlappingRanges(this.url, queryRange, diagnosticNode, false);
    if (resolvedRanges.length < 1) {
      throw new ErrorResponse("No overlapping ranges found.");
    }
    const firstResolvedRange = resolvedRanges[0];
    if (resolvedRanges.length > 1) {
      await this.handleSplit(true, resolvedRanges, queryRange, feedRange.continuationToken);
    }
    return firstResolvedRange.id;
  }
  async getFeedResponse(feedRange, diagnosticNode) {
    const feedOptions = { initialHeaders: {}, useIncrementalFeed: true };
    if (typeof this.changeFeedOptions.maxItemCount === "number") {
      feedOptions.maxItemCount = this.changeFeedOptions.maxItemCount;
    }
    if (this.changeFeedOptions.sessionToken) {
      feedOptions.sessionToken = this.changeFeedOptions.sessionToken;
    }
    if (feedRange.continuationToken) {
      feedOptions.accessCondition = {
        type: Constants.HttpHeaders.IfNoneMatch,
        condition: feedRange.continuationToken
      };
    }
    if (this.startTime) {
      feedOptions.initialHeaders[Constants.HttpHeaders.IfModifiedSince] = this.startTime;
    }
    const rangeId = await this.getPartitionRangeId(feedRange, diagnosticNode);
    try {
      const response = await this.clientContext.queryFeed({
        path: this.resourceLink,
        resourceType: ResourceType.item,
        resourceId: this.resourceId,
        resultFn: (result) => result ? result.Documents : [],
        query: void 0,
        options: feedOptions,
        diagnosticNode,
        partitionKey: void 0,
        partitionKeyRangeId: rangeId,
        startEpk: feedRange.epkMinHeader,
        endEpk: feedRange.epkMaxHeader
      });
      return new ChangeFeedIteratorResponse(response.result, response.result ? response.result.length : 0, response.code, response.headers, getEmptyCosmosDiagnostics());
    } catch (err) {
      return new ChangeFeedIteratorResponse([], 0, err.code, err.headers, getEmptyCosmosDiagnostics(), err.substatus);
    }
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/ContinuationTokenForPartitionKey.js
var ContinuationTokenForPartitionKey = class {
  constructor(rid, partitionKey, continuation) {
    this.rid = rid;
    this.partitionKey = partitionKey;
    this.Continuation = continuation;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/ChangeFeedForPartitionKey.js
var ChangeFeedForPartitionKey = class {
  /**
   * @internal
   */
  constructor(clientContext, container, resourceId, resourceLink, partitionKey, changeFeedOptions) {
    this.clientContext = clientContext;
    this.container = container;
    this.resourceId = resourceId;
    this.resourceLink = resourceLink;
    this.partitionKey = partitionKey;
    this.changeFeedOptions = changeFeedOptions;
    this.continuationToken = changeFeedOptions.continuationToken ? JSON.parse(changeFeedOptions.continuationToken) : void 0;
    this.isInstantiated = false;
    if (changeFeedOptions.startTime) {
      this.startTime = changeFeedOptions.startTime.toUTCString();
    }
  }
  async instantiateIterator(diagnosticNode) {
    await this.setIteratorRid(diagnosticNode);
    if (this.continuationToken) {
      if (!this.continuationTokenRidMatchContainerRid()) {
        throw new ErrorResponse("The continuation is not for the current container definition.");
      }
    } else {
      this.continuationToken = new ContinuationTokenForPartitionKey(this.rId, this.partitionKey, "");
    }
    this.isInstantiated = true;
  }
  continuationTokenRidMatchContainerRid() {
    if (this.continuationToken.rid !== this.rId) {
      return false;
    }
    return true;
  }
  async setIteratorRid(diagnosticNode) {
    const { resource } = await this.container.readInternal(diagnosticNode);
    this.rId = resource._rid;
  }
  /**
   * Change feed is an infinite feed. hasMoreResults is always true.
   */
  get hasMoreResults() {
    return true;
  }
  /**
   * Gets an async iterator which will yield change feed results.
   */
  getAsyncIterator() {
    return __asyncGenerator(this, arguments, function* getAsyncIterator_1() {
      do {
        const result = yield __await(this.readNext());
        yield yield __await(result);
      } while (this.hasMoreResults);
    });
  }
  /**
   * Returns the result of change feed from Azure Cosmos DB.
   */
  async readNext() {
    return withDiagnostics(async (diagnosticNode) => {
      if (!this.isInstantiated) {
        await this.instantiateIterator(diagnosticNode);
      }
      const result = await this.fetchNext(diagnosticNode);
      return result;
    }, this.clientContext);
  }
  /**
   * Read feed and retrieves the next set of results in Azure Cosmos DB.
   */
  async fetchNext(diagnosticNode) {
    const response = await this.getFeedResponse(diagnosticNode);
    this.continuationToken.Continuation = response.headers[Constants.HttpHeaders.ETag];
    response.headers[Constants.HttpHeaders.ContinuationToken] = JSON.stringify(this.continuationToken);
    return response;
  }
  async getFeedResponse(diagnosticNode) {
    const feedOptions = { initialHeaders: {}, useIncrementalFeed: true };
    if (typeof this.changeFeedOptions.maxItemCount === "number") {
      feedOptions.maxItemCount = this.changeFeedOptions.maxItemCount;
    }
    if (this.changeFeedOptions.sessionToken) {
      feedOptions.sessionToken = this.changeFeedOptions.sessionToken;
    }
    const continuation = this.continuationToken.Continuation;
    if (continuation) {
      feedOptions.accessCondition = {
        type: Constants.HttpHeaders.IfNoneMatch,
        condition: continuation
      };
    }
    if (this.startTime) {
      feedOptions.initialHeaders[Constants.HttpHeaders.IfModifiedSince] = this.startTime;
    }
    const response = await this.clientContext.queryFeed({
      path: this.resourceLink,
      resourceType: ResourceType.item,
      resourceId: this.resourceId,
      resultFn: (result) => result ? result.Documents : [],
      diagnosticNode,
      query: void 0,
      options: feedOptions,
      partitionKey: this.partitionKey
    });
    return new ChangeFeedIteratorResponse(response.result, response.result ? response.result.length : 0, response.code, response.headers, getEmptyCosmosDiagnostics());
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/ChangeFeedEnums.js
var ChangeFeedResourceType;
(function(ChangeFeedResourceType2) {
  ChangeFeedResourceType2[ChangeFeedResourceType2["FeedRange"] = 0] = "FeedRange";
  ChangeFeedResourceType2[ChangeFeedResourceType2["PartitionKey"] = 1] = "PartitionKey";
})(ChangeFeedResourceType || (ChangeFeedResourceType = {}));

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/ChangeFeedStartFromContinuation.js
var ChangeFeedStartFromContinuation = class {
  constructor(continuation) {
    this.continuationToken = continuation;
  }
  getCfResource() {
    return this.continuationToken;
  }
  getCfResourceJson() {
    return JSON.parse(this.continuationToken);
  }
  getResourceType() {
    const cToken = this.getCfResourceJson();
    if (Object.prototype.hasOwnProperty.call(cToken, "partitionKey") && Object.prototype.hasOwnProperty.call(cToken, "Continuation") && typeof cToken.Continuation === "string") {
      return ChangeFeedResourceType.PartitionKey;
    } else if (Object.prototype.hasOwnProperty.call(cToken, "Continuation") && Array.isArray(cToken.Continuation) && cToken.Continuation.length > 0) {
      return ChangeFeedResourceType.FeedRange;
    } else {
      throw new ErrorResponse("Invalid continuation token.");
    }
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/ChangeFeedStartFrom.js
var ChangeFeedStartFrom = class {
  /**
   * Returns an object that tells the ChangeFeedIterator to start from the beginning of time.
   * @param cfResource - PartitionKey or FeedRange for which changes are to be fetched. Leave blank for fetching changes for entire container.
   */
  static Beginning(cfResource) {
    return new ChangeFeedStartFromBeginning(cfResource);
  }
  /**
   *  Returns an object that tells the ChangeFeedIterator to start reading changes from this moment onward.
   * @param cfResource - PartitionKey or FeedRange for which changes are to be fetched. Leave blank for fetching changes for entire container.
   **/
  static Now(cfResource) {
    return new ChangeFeedStartFromNow(cfResource);
  }
  /**
   * Returns an object that tells the ChangeFeedIterator to start reading changes from some point in time onward.
   * @param startTime - Date object specfiying the time to start reading changes from.
   * @param cfResource - PartitionKey or FeedRange for which changes are to be fetched. Leave blank for fetching changes for entire container.
   */
  static Time(startTime, cfResource) {
    if (!startTime) {
      throw new ErrorResponse("startTime must be present");
    }
    if (startTime instanceof Date === true) {
      return new ChangeFeedStartFromTime(startTime, cfResource);
    } else {
      throw new ErrorResponse("startTime must be a Date object.");
    }
  }
  /**
   * Returns an object that tells the ChangeFeedIterator to start reading changes from a save point.
   * @param continuation - The continuation to resume from.
   */
  static Continuation(continuationToken) {
    if (!continuationToken) {
      throw new ErrorResponse("Argument continuation must be passed.");
    }
    if (isNullOrEmpty(continuationToken)) {
      throw new ErrorResponse("Argument continuationToken must be a non-empty string.");
    }
    return new ChangeFeedStartFromContinuation(continuationToken);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/ChangeFeed/changeFeedIteratorBuilder.js
function changeFeedIteratorBuilder(cfOptions, clientContext, container, partitionKeyRangeCache) {
  const url = container.url;
  const path = getPathFromLink(url, ResourceType.item);
  const id = getIdFromLink(url);
  let changeFeedStartFrom = cfOptions.changeFeedStartFrom;
  if (changeFeedStartFrom === void 0) {
    changeFeedStartFrom = ChangeFeedStartFrom.Now();
  }
  if (changeFeedStartFrom instanceof ChangeFeedStartFromContinuation) {
    const continuationToken = changeFeedStartFrom.getCfResourceJson();
    const resourceType = changeFeedStartFrom.getResourceType();
    const internalCfOptions = buildInternalChangeFeedOptions(cfOptions, changeFeedStartFrom.getCfResource());
    if (resourceType === ChangeFeedResourceType.PartitionKey && isPartitionKey(continuationToken.partitionKey)) {
      return new ChangeFeedForPartitionKey(clientContext, container, id, path, continuationToken.partitionKey, internalCfOptions);
    } else if (resourceType === ChangeFeedResourceType.FeedRange) {
      return new ChangeFeedForEpkRange(clientContext, container, partitionKeyRangeCache, id, path, url, internalCfOptions, void 0);
    } else {
      throw new ErrorResponse("Invalid continuation token.");
    }
  } else if (changeFeedStartFrom instanceof ChangeFeedStartFromNow || changeFeedStartFrom instanceof ChangeFeedStartFromTime || changeFeedStartFrom instanceof ChangeFeedStartFromBeginning) {
    const startTime = fetchStartTime(changeFeedStartFrom);
    const internalCfOptions = buildInternalChangeFeedOptions(cfOptions, void 0, startTime);
    const cfResource = changeFeedStartFrom.getCfResource();
    if (isPartitionKey(cfResource)) {
      return new ChangeFeedForPartitionKey(clientContext, container, id, path, cfResource, internalCfOptions);
    } else {
      let internalCfResource;
      if (cfResource === void 0) {
        internalCfResource = new QueryRange(Constants.EffectivePartitionKeyConstants.MinimumInclusiveEffectivePartitionKey, Constants.EffectivePartitionKeyConstants.MaximumExclusiveEffectivePartitionKey, true, false);
      } else if (isEpkRange(cfResource)) {
        internalCfResource = new QueryRange(cfResource.minInclusive, cfResource.maxExclusive, true, false);
      } else {
        throw new ErrorResponse("Invalid feed range.");
      }
      return new ChangeFeedForEpkRange(clientContext, container, partitionKeyRangeCache, id, path, url, internalCfOptions, internalCfResource);
    }
  } else {
    throw new ErrorResponse("Invalid change feed start location.");
  }
}

// node_modules/@azure/cosmos/dist-esm/src/client/Item/Items.js
var uuid2 = v4_default;
function isChangeFeedOptions(options) {
  return options && !(isPrimitivePartitionKeyValue(options) || Array.isArray(options));
}
var Items = class {
  /**
   * Create an instance of {@link Items} linked to the parent {@link Container}.
   * @param container - The parent container.
   * @hidden
   */
  constructor(container, clientContext) {
    this.container = container;
    this.clientContext = clientContext;
    this.partitionKeyRangeCache = new PartitionKeyRangeCache(this.clientContext);
  }
  query(query, options = {}) {
    const path = getPathFromLink(this.container.url, ResourceType.item);
    const id = getIdFromLink(this.container.url);
    const fetchFunction = async (diagnosticNode, innerOptions) => {
      const response = await this.clientContext.queryFeed({
        path,
        resourceType: ResourceType.item,
        resourceId: id,
        resultFn: (result) => result ? result.Documents : [],
        query,
        options: innerOptions,
        partitionKey: options.partitionKey,
        diagnosticNode
      });
      return response;
    };
    return new QueryIterator(this.clientContext, query, options, fetchFunction, this.container.url, ResourceType.item);
  }
  readChangeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions) {
    if (isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {
      return this.changeFeed(partitionKeyOrChangeFeedOptions);
    } else {
      return this.changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions);
    }
  }
  changeFeed(partitionKeyOrChangeFeedOptions, changeFeedOptions) {
    let partitionKey;
    if (!changeFeedOptions && isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {
      partitionKey = void 0;
      changeFeedOptions = partitionKeyOrChangeFeedOptions;
    } else if (partitionKeyOrChangeFeedOptions !== void 0 && !isChangeFeedOptions(partitionKeyOrChangeFeedOptions)) {
      partitionKey = partitionKeyOrChangeFeedOptions;
    }
    if (!changeFeedOptions) {
      changeFeedOptions = {};
    }
    const path = getPathFromLink(this.container.url, ResourceType.item);
    const id = getIdFromLink(this.container.url);
    return new ChangeFeedIterator(this.clientContext, id, path, partitionKey, changeFeedOptions);
  }
  /**
   * Returns an iterator to iterate over pages of changes. The iterator returned can be used to fetch changes for a single partition key, feed range or an entire container.
   */
  getChangeFeedIterator(changeFeedIteratorOptions) {
    const cfOptions = changeFeedIteratorOptions !== void 0 ? changeFeedIteratorOptions : {};
    validateChangeFeedIteratorOptions(cfOptions);
    const iterator = changeFeedIteratorBuilder(cfOptions, this.clientContext, this.container, this.partitionKeyRangeCache);
    return iterator;
  }
  readAll(options) {
    return this.query("SELECT * from c", options);
  }
  /**
   * Create an item.
   *
   * Any provided type, T, is not necessarily enforced by the SDK.
   * You may get more or less properties and it's up to your logic to enforce it.
   *
   * There is no set schema for JSON items. They may contain any number of custom properties.
   *
   * @param body - Represents the body of the item. Can contain any number of user defined properties.
   * @param options - Used for modifying the request (for instance, specifying the partition key).
   */
  async create(body, options = {}) {
    return withDiagnostics(async (diagnosticNode) => {
      if ((body.id === void 0 || body.id === "") && !options.disableAutomaticIdGeneration) {
        body.id = uuid2();
      }
      const partitionKeyDefinition = await readPartitionKeyDefinition(diagnosticNode, this.container);
      const partitionKey = extractPartitionKeys(body, partitionKeyDefinition);
      const err = {};
      if (!isItemResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.container.url, ResourceType.item);
      const id = getIdFromLink(this.container.url);
      const response = await this.clientContext.create({
        body,
        path,
        resourceType: ResourceType.item,
        resourceId: id,
        diagnosticNode,
        options,
        partitionKey
      });
      const ref = new Item(this.container, response.result.id, this.clientContext, partitionKey);
      return new ItemResponse(response.result, response.headers, response.code, response.substatus, ref, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  async upsert(body, options = {}) {
    return withDiagnostics(async (diagnosticNode) => {
      if ((body.id === void 0 || body.id === "") && !options.disableAutomaticIdGeneration) {
        body.id = uuid2();
      }
      const partitionKeyDefinition = await readPartitionKeyDefinition(diagnosticNode, this.container);
      const partitionKey = extractPartitionKeys(body, partitionKeyDefinition);
      const err = {};
      if (!isItemResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.container.url, ResourceType.item);
      const id = getIdFromLink(this.container.url);
      const response = await this.clientContext.upsert({
        body,
        path,
        resourceType: ResourceType.item,
        resourceId: id,
        options,
        partitionKey,
        diagnosticNode
      });
      const ref = new Item(this.container, response.result.id, this.clientContext, partitionKey);
      return new ItemResponse(response.result, response.headers, response.code, response.substatus, ref, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Execute bulk operations on items.
   *
   * Bulk takes an array of Operations which are typed based on what the operation does.
   * The choices are: Create, Upsert, Read, Replace, and Delete
   *
   * Usage example:
   * ```typescript
   * // partitionKey is optional at the top level if present in the resourceBody
   * const operations: OperationInput[] = [
   *    {
   *       operationType: "Create",
   *       resourceBody: { id: "doc1", name: "sample", key: "A" }
   *    },
   *    {
   *       operationType: "Upsert",
   *       partitionKey: 'A',
   *       resourceBody: { id: "doc2", name: "other", key: "A" }
   *    }
   * ]
   *
   * await database.container.items.bulk(operations)
   * ```
   *
   * @param operations - List of operations. Limit 100
   * @param bulkOptions - Optional options object to modify bulk behavior. Pass \{ continueOnError: true \} to continue executing operations when one fails. (Defaults to false) ** NOTE: THIS WILL DEFAULT TO TRUE IN THE 4.0 RELEASE
   * @param options - Used for modifying the request.
   */
  async bulk(operations, bulkOptions, options) {
    return withDiagnostics(async (diagnosticNode) => {
      const { resources: partitionKeyRanges } = await this.container.readPartitionKeyRanges().fetchAll();
      const partitionKeyDefinition = await readPartitionKeyDefinition(diagnosticNode, this.container);
      const batches = partitionKeyRanges.map((keyRange) => {
        return {
          min: keyRange.minInclusive,
          max: keyRange.maxExclusive,
          rangeId: keyRange.id,
          indexes: [],
          operations: []
        };
      });
      this.groupOperationsBasedOnPartitionKey(operations, partitionKeyDefinition, options, batches);
      const path = getPathFromLink(this.container.url, ResourceType.item);
      const orderedResponses = [];
      await Promise.all(batches.filter((batch) => batch.operations.length).flatMap((batch) => splitBatchBasedOnBodySize(batch)).map(async (batch) => {
        if (batch.operations.length > 100) {
          throw new Error("Cannot run bulk request with more than 100 operations per partition");
        }
        try {
          const response2 = await addDignosticChild(async (childNode) => this.clientContext.bulk({
            body: batch.operations,
            partitionKeyRangeId: batch.rangeId,
            path,
            resourceId: this.container.url,
            bulkOptions,
            options,
            diagnosticNode: childNode
          }), diagnosticNode, DiagnosticNodeType.BATCH_REQUEST);
          response2.result.forEach((operationResponse, index) => {
            orderedResponses[batch.indexes[index]] = operationResponse;
          });
        } catch (err) {
          if (err.code === 410) {
            throw new Error("Partition key error. Either the partitions have split or an operation has an unsupported partitionKey type" + err.message);
          }
          throw new Error(`Bulk request errored with: ${err.message}`);
        }
      }));
      const response = orderedResponses;
      response.diagnostics = diagnosticNode.toDiagnostic(this.clientContext.getClientConfig());
      return response;
    }, this.clientContext);
  }
  /**
   * Function to create batches based of partition key Ranges.
   * @param operations - operations to group
   * @param partitionDefinition - PartitionKey definition of container.
   * @param options - Request options for bulk request.
   * @param batches - Groups to be filled with operations.
   */
  groupOperationsBasedOnPartitionKey(operations, partitionDefinition, options, batches) {
    operations.forEach((operationInput, index) => {
      const { operation, partitionKey } = prepareOperations(operationInput, partitionDefinition, options);
      const hashed = hashPartitionKey(assertNotUndefined(partitionKey, "undefined value for PartitionKey is not expected during grouping of bulk operations."), partitionDefinition);
      const batchForKey = assertNotUndefined(batches.find((batch) => {
        return isKeyInRange(batch.min, batch.max, hashed);
      }), "No suitable Batch found.");
      batchForKey.operations.push(operation);
      batchForKey.indexes.push(index);
    });
  }
  /**
   * Execute transactional batch operations on items.
   *
   * Batch takes an array of Operations which are typed based on what the operation does. Batch is transactional and will rollback all operations if one fails.
   * The choices are: Create, Upsert, Read, Replace, and Delete
   *
   * Usage example:
   * ```typescript
   * // partitionKey is required as a second argument to batch, but defaults to the default partition key
   * const operations: OperationInput[] = [
   *    {
   *       operationType: "Create",
   *       resourceBody: { id: "doc1", name: "sample", key: "A" }
   *    },
   *    {
   *       operationType: "Upsert",
   *       partitionKey: 'A',
   *       resourceBody: { id: "doc2", name: "other", key: "A" }
   *    }
   * ]
   *
   * await database.container.items.batch(operations)
   * ```
   *
   * @param operations - List of operations. Limit 100
   * @param options - Used for modifying the request
   */
  async batch(operations, partitionKey, options) {
    return withDiagnostics(async (diagnosticNode) => {
      operations.map((operation) => decorateBatchOperation(operation, options));
      const path = getPathFromLink(this.container.url, ResourceType.item);
      if (operations.length > 100) {
        throw new Error("Cannot run batch request with more than 100 operations per partition");
      }
      try {
        const response = await this.clientContext.batch({
          body: operations,
          partitionKey,
          path,
          resourceId: this.container.url,
          options,
          diagnosticNode
        });
        return response;
      } catch (err) {
        throw new Error(`Batch request error: ${err.message}`);
      }
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/StoredProcedure/StoredProcedureResponse.js
var StoredProcedureResponse = class extends ResourceResponse {
  constructor(resource, headers, statusCode, storedProcedure, diagnostics) {
    super(resource, headers, statusCode, diagnostics);
    this.storedProcedure = storedProcedure;
  }
  /**
   * Alias for storedProcedure.
   *
   * A reference to the {@link StoredProcedure} which the {@link StoredProcedureDefinition} corresponds to.
   */
  get sproc() {
    return this.storedProcedure;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/StoredProcedure/StoredProcedure.js
var StoredProcedure = class {
  /**
   * Returns a reference URL to the resource. Used for linking in Permissions.
   */
  get url() {
    return createStoredProcedureUri(this.container.database.id, this.container.id, this.id);
  }
  /**
   * Creates a new instance of {@link StoredProcedure} linked to the parent {@link Container}.
   * @param container - The parent {@link Container}.
   * @param id - The id of the given {@link StoredProcedure}.
   * @hidden
   */
  constructor(container, id, clientContext) {
    this.container = container;
    this.id = id;
    this.clientContext = clientContext;
  }
  /**
   * Read the {@link StoredProcedureDefinition} for the given {@link StoredProcedure}.
   */
  async read(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.read({
        path,
        resourceType: ResourceType.sproc,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new StoredProcedureResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Replace the given {@link StoredProcedure} with the specified {@link StoredProcedureDefinition}.
   * @param body - The specified {@link StoredProcedureDefinition} to replace the existing definition.
   */
  async replace(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      if (body.body) {
        body.body = body.body.toString();
      }
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.replace({
        body,
        path,
        resourceType: ResourceType.sproc,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new StoredProcedureResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Delete the given {@link StoredProcedure}.
   */
  async delete(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.delete({
        path,
        resourceType: ResourceType.sproc,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new StoredProcedureResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Execute the given {@link StoredProcedure}.
   *
   * The specified type, T, is not enforced by the client.
   * Be sure to validate the response from the stored procedure matches the type, T, you provide.
   *
   * @param partitionKey - The partition key to use when executing the stored procedure
   * @param params - Array of parameters to pass as arguments to the given {@link StoredProcedure}.
   * @param options - Additional options, such as the partition key to invoke the {@link StoredProcedure} on.
   */
  async execute(partitionKey, params, options) {
    return withDiagnostics(async (diagnosticNode) => {
      if (partitionKey === void 0) {
        const partitionKeyResponse = await readPartitionKeyDefinition(diagnosticNode, this.container);
        partitionKey = undefinedPartitionKey(partitionKeyResponse);
      }
      const response = await this.clientContext.execute({
        sprocLink: this.url,
        params,
        options,
        partitionKey,
        diagnosticNode
      });
      return new ResourceResponse(response.result, response.headers, response.code, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/StoredProcedure/StoredProcedures.js
var StoredProcedures = class {
  /**
   * @param container - The parent {@link Container}.
   * @hidden
   */
  constructor(container, clientContext) {
    this.container = container;
    this.clientContext = clientContext;
  }
  query(query, options) {
    const path = getPathFromLink(this.container.url, ResourceType.sproc);
    const id = getIdFromLink(this.container.url);
    return new QueryIterator(this.clientContext, query, options, (diagNode, innerOptions) => {
      return this.clientContext.queryFeed({
        path,
        resourceType: ResourceType.sproc,
        resourceId: id,
        resultFn: (result) => result.StoredProcedures,
        query,
        options: innerOptions,
        diagnosticNode: diagNode
      });
    });
  }
  /**
   * Read all stored procedures.
   * @example Read all stored procedures to array.
   * ```typescript
   * const {body: sprocList} = await containers.storedProcedures.readAll().fetchAll();
   * ```
   */
  readAll(options) {
    return this.query(void 0, options);
  }
  /**
   * Create a StoredProcedure.
   *
   * Azure Cosmos DB allows stored procedures to be executed in the storage tier,
   * directly against an item container. The script
   * gets executed under ACID transactions on the primary storage partition of the
   * specified container. For additional details,
   * refer to the server-side JavaScript API documentation.
   */
  async create(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      if (body.body) {
        body.body = body.body.toString();
      }
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.container.url, ResourceType.sproc);
      const id = getIdFromLink(this.container.url);
      const response = await this.clientContext.create({
        body,
        path,
        resourceType: ResourceType.sproc,
        resourceId: id,
        options,
        diagnosticNode
      });
      const ref = new StoredProcedure(this.container, response.result.id, this.clientContext);
      return new StoredProcedureResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Trigger/TriggerResponse.js
var TriggerResponse = class extends ResourceResponse {
  constructor(resource, headers, statusCode, trigger, diagnostics) {
    super(resource, headers, statusCode, diagnostics);
    this.trigger = trigger;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Trigger/Trigger.js
var Trigger = class {
  /**
   * Returns a reference URL to the resource. Used for linking in Permissions.
   */
  get url() {
    return createTriggerUri(this.container.database.id, this.container.id, this.id);
  }
  /**
   * @hidden
   * @param container - The parent {@link Container}.
   * @param id - The id of the given {@link Trigger}.
   */
  constructor(container, id, clientContext) {
    this.container = container;
    this.id = id;
    this.clientContext = clientContext;
  }
  /**
   * Read the {@link TriggerDefinition} for the given {@link Trigger}.
   */
  async read(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.read({
        path,
        resourceType: ResourceType.trigger,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new TriggerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Replace the given {@link Trigger} with the specified {@link TriggerDefinition}.
   * @param body - The specified {@link TriggerDefinition} to replace the existing definition with.
   */
  async replace(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      if (body.body) {
        body.body = body.body.toString();
      }
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.replace({
        body,
        path,
        resourceType: ResourceType.trigger,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new TriggerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Delete the given {@link Trigger}.
   */
  async delete(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.delete({
        path,
        resourceType: ResourceType.trigger,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new TriggerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Trigger/Triggers.js
var Triggers = class {
  /**
   * @hidden
   * @param container - The parent {@link Container}.
   */
  constructor(container, clientContext) {
    this.container = container;
    this.clientContext = clientContext;
  }
  query(query, options) {
    const path = getPathFromLink(this.container.url, ResourceType.trigger);
    const id = getIdFromLink(this.container.url);
    return new QueryIterator(this.clientContext, query, options, (diagnosticNode, innerOptions) => {
      return this.clientContext.queryFeed({
        path,
        resourceType: ResourceType.trigger,
        resourceId: id,
        resultFn: (result) => result.Triggers,
        query,
        options: innerOptions,
        diagnosticNode
      });
    });
  }
  /**
   * Read all Triggers.
   * @example Read all trigger to array.
   * ```typescript
   * const {body: triggerList} = await container.triggers.readAll().fetchAll();
   * ```
   */
  readAll(options) {
    return this.query(void 0, options);
  }
  /**
   * Create a trigger.
   *
   * Azure Cosmos DB supports pre and post triggers defined in JavaScript to be executed
   * on creates, updates and deletes.
   *
   * For additional details, refer to the server-side JavaScript API documentation.
   */
  async create(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      if (body.body) {
        body.body = body.body.toString();
      }
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.container.url, ResourceType.trigger);
      const id = getIdFromLink(this.container.url);
      const response = await this.clientContext.create({
        body,
        path,
        resourceType: ResourceType.trigger,
        resourceId: id,
        options,
        diagnosticNode
      });
      const ref = new Trigger(this.container, response.result.id, this.clientContext);
      return new TriggerResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/UserDefinedFunction/UserDefinedFunctionResponse.js
var UserDefinedFunctionResponse = class extends ResourceResponse {
  constructor(resource, headers, statusCode, udf, diagnostics) {
    super(resource, headers, statusCode, diagnostics);
    this.userDefinedFunction = udf;
  }
  /**
   * Alias for `userDefinedFunction(id)`.
   *
   * A reference to the {@link UserDefinedFunction} corresponding to the returned {@link UserDefinedFunctionDefinition}.
   */
  get udf() {
    return this.userDefinedFunction;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/UserDefinedFunction/UserDefinedFunction.js
var UserDefinedFunction = class {
  /**
   * Returns a reference URL to the resource. Used for linking in Permissions.
   */
  get url() {
    return createUserDefinedFunctionUri(this.container.database.id, this.container.id, this.id);
  }
  /**
   * @hidden
   * @param container - The parent {@link Container}.
   * @param id - The id of the given {@link UserDefinedFunction}.
   */
  constructor(container, id, clientContext) {
    this.container = container;
    this.id = id;
    this.clientContext = clientContext;
  }
  /**
   * Read the {@link UserDefinedFunctionDefinition} for the given {@link UserDefinedFunction}.
   */
  async read(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.read({
        path,
        resourceType: ResourceType.udf,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new UserDefinedFunctionResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Replace the given {@link UserDefinedFunction} with the specified {@link UserDefinedFunctionDefinition}.
   * @param options -
   */
  async replace(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      if (body.body) {
        body.body = body.body.toString();
      }
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.replace({
        body,
        path,
        resourceType: ResourceType.udf,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new UserDefinedFunctionResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Delete the given {@link UserDefined}.
   */
  async delete(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.delete({
        path,
        resourceType: ResourceType.udf,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new UserDefinedFunctionResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/UserDefinedFunction/UserDefinedFunctions.js
var UserDefinedFunctions = class {
  /**
   * @hidden
   * @param container - The parent {@link Container}.
   */
  constructor(container, clientContext) {
    this.container = container;
    this.clientContext = clientContext;
  }
  query(query, options) {
    const path = getPathFromLink(this.container.url, ResourceType.udf);
    const id = getIdFromLink(this.container.url);
    return new QueryIterator(this.clientContext, query, options, (diagnosticNode, innerOptions) => {
      return this.clientContext.queryFeed({
        path,
        resourceType: ResourceType.udf,
        resourceId: id,
        resultFn: (result) => result.UserDefinedFunctions,
        query,
        options: innerOptions,
        diagnosticNode
      });
    });
  }
  /**
   * Read all User Defined Functions.
   * @example Read all User Defined Functions to array.
   * ```typescript
   * const {body: udfList} = await container.userDefinedFunctions.readAll().fetchAll();
   * ```
   */
  readAll(options) {
    return this.query(void 0, options);
  }
  /**
   * Create a UserDefinedFunction.
   *
   * Azure Cosmos DB supports JavaScript UDFs which can be used inside queries, stored procedures and triggers.
   *
   * For additional details, refer to the server-side JavaScript API documentation.
   *
   */
  async create(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      if (body.body) {
        body.body = body.body.toString();
      }
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.container.url, ResourceType.udf);
      const id = getIdFromLink(this.container.url);
      const response = await this.clientContext.create({
        body,
        path,
        resourceType: ResourceType.udf,
        resourceId: id,
        options,
        diagnosticNode
      });
      const ref = new UserDefinedFunction(this.container, response.result.id, this.clientContext);
      return new UserDefinedFunctionResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Script/Scripts.js
var Scripts = class {
  /**
   * @param container - The parent {@link Container}.
   * @hidden
   */
  constructor(container, clientContext) {
    this.container = container;
    this.clientContext = clientContext;
  }
  /**
   * Used to read, replace, or delete a specific, existing {@link StoredProcedure} by id.
   *
   * Use `.storedProcedures` for creating new stored procedures, or querying/reading all stored procedures.
   * @param id - The id of the {@link StoredProcedure}.
   */
  storedProcedure(id) {
    return new StoredProcedure(this.container, id, this.clientContext);
  }
  /**
   * Used to read, replace, or delete a specific, existing {@link Trigger} by id.
   *
   * Use `.triggers` for creating new triggers, or querying/reading all triggers.
   * @param id - The id of the {@link Trigger}.
   */
  trigger(id) {
    return new Trigger(this.container, id, this.clientContext);
  }
  /**
   * Used to read, replace, or delete a specific, existing {@link UserDefinedFunction} by id.
   *
   * Use `.userDefinedFunctions` for creating new user defined functions, or querying/reading all user defined functions.
   * @param id - The id of the {@link UserDefinedFunction}.
   */
  userDefinedFunction(id) {
    return new UserDefinedFunction(this.container, id, this.clientContext);
  }
  /**
   * Operations for creating new stored procedures, and reading/querying all stored procedures.
   *
   * For reading, replacing, or deleting an existing stored procedure, use `.storedProcedure(id)`.
   */
  get storedProcedures() {
    if (!this.$sprocs) {
      this.$sprocs = new StoredProcedures(this.container, this.clientContext);
    }
    return this.$sprocs;
  }
  /**
   * Operations for creating new triggers, and reading/querying all triggers.
   *
   * For reading, replacing, or deleting an existing trigger, use `.trigger(id)`.
   */
  get triggers() {
    if (!this.$triggers) {
      this.$triggers = new Triggers(this.container, this.clientContext);
    }
    return this.$triggers;
  }
  /**
   * Operations for creating new user defined functions, and reading/querying all user defined functions.
   *
   * For reading, replacing, or deleting an existing user defined function, use `.userDefinedFunction(id)`.
   */
  get userDefinedFunctions() {
    if (!this.$udfs) {
      this.$udfs = new UserDefinedFunctions(this.container, this.clientContext);
    }
    return this.$udfs;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Container/ContainerResponse.js
var ContainerResponse = class extends ResourceResponse {
  constructor(resource, headers, statusCode, container, diagnostics) {
    super(resource, headers, statusCode, diagnostics);
    this.container = container;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Offer/OfferResponse.js
var OfferResponse = class extends ResourceResponse {
  constructor(resource, headers, statusCode, diagnostics, offer) {
    super(resource, headers, statusCode, diagnostics);
    this.offer = offer;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Offer/Offer.js
var Offer = class {
  /**
   * Returns a reference URL to the resource. Used for linking in Permissions.
   */
  get url() {
    return `/${Constants.Path.OffersPathSegment}/${this.id}`;
  }
  /**
   * @hidden
   * @param client - The parent {@link CosmosClient} for the Database Account.
   * @param id - The id of the given {@link Offer}.
   */
  constructor(client, id, clientContext) {
    this.client = client;
    this.id = id;
    this.clientContext = clientContext;
  }
  /**
   * Read the {@link OfferDefinition} for the given {@link Offer}.
   */
  async read(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const response = await this.clientContext.read({
        path: this.url,
        resourceType: ResourceType.offer,
        resourceId: this.id,
        options,
        diagnosticNode
      });
      return new OfferResponse(response.result, response.headers, response.code, getEmptyCosmosDiagnostics(), this);
    }, this.clientContext);
  }
  /**
   * Replace the given {@link Offer} with the specified {@link OfferDefinition}.
   * @param body - The specified {@link OfferDefinition}
   */
  async replace(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const response = await this.clientContext.replace({
        body,
        path: this.url,
        resourceType: ResourceType.offer,
        resourceId: this.id,
        options,
        diagnosticNode
      });
      return new OfferResponse(response.result, response.headers, response.code, getEmptyCosmosDiagnostics(), this);
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Offer/Offers.js
var Offers = class {
  /**
   * @hidden
   * @param client - The parent {@link CosmosClient} for the offers.
   */
  constructor(client, clientContext) {
    this.client = client;
    this.clientContext = clientContext;
  }
  query(query, options) {
    return new QueryIterator(this.clientContext, query, options, (diagnosticNode, innerOptions) => {
      return this.clientContext.queryFeed({
        path: "/offers",
        resourceType: ResourceType.offer,
        resourceId: "",
        resultFn: (result) => result.Offers,
        query,
        options: innerOptions,
        diagnosticNode
      });
    });
  }
  /**
   * Read all offers.
   * @example Read all offers to array.
   * ```typescript
   * const {body: offerList} = await client.offers.readAll().fetchAll();
   * ```
   */
  readAll(options) {
    return this.query(void 0, options);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Container/Container.js
var Container = class {
  /**
   * Operations for creating new items, and reading/querying all items
   *
   * For reading, replacing, or deleting an existing item, use `.item(id)`.
   *
   * @example Create a new item
   * ```typescript
   * const {body: createdItem} = await container.items.create({id: "<item id>", properties: {}});
   * ```
   */
  get items() {
    if (!this.$items) {
      this.$items = new Items(this, this.clientContext);
    }
    return this.$items;
  }
  /**
   * All operations for Stored Procedures, Triggers, and User Defined Functions
   */
  get scripts() {
    if (!this.$scripts) {
      this.$scripts = new Scripts(this, this.clientContext);
    }
    return this.$scripts;
  }
  /**
   * Operations for reading and querying conflicts for the given container.
   *
   * For reading or deleting a specific conflict, use `.conflict(id)`.
   */
  get conflicts() {
    if (!this.$conflicts) {
      this.$conflicts = new Conflicts(this, this.clientContext);
    }
    return this.$conflicts;
  }
  /**
   * Returns a reference URL to the resource. Used for linking in Permissions.
   */
  get url() {
    return createDocumentCollectionUri(this.database.id, this.id);
  }
  /**
   * Returns a container instance. Note: You should get this from `database.container(id)`, rather than creating your own object.
   * @param database - The parent {@link Database}.
   * @param id - The id of the given container.
   * @hidden
   */
  constructor(database, id, clientContext) {
    this.database = database;
    this.id = id;
    this.clientContext = clientContext;
  }
  /**
   * Used to read, replace, or delete a specific, existing {@link Item} by id.
   *
   * Use `.items` for creating new items, or querying/reading all items.
   *
   * @param id - The id of the {@link Item}.
   * @param partitionKeyValue - The value of the {@link Item} partition key
   * @example Replace an item
   * `const {body: replacedItem} = await container.item("<item id>", "<partition key value>").replace({id: "<item id>", title: "Updated post", authorID: 5});`
   */
  item(id, partitionKeyValue) {
    return new Item(this, id, this.clientContext, partitionKeyValue);
  }
  /**
   * Used to read, replace, or delete a specific, existing {@link Conflict} by id.
   *
   * Use `.conflicts` for creating new conflicts, or querying/reading all conflicts.
   * @param id - The id of the {@link Conflict}.
   */
  conflict(id, partitionKey) {
    return new Conflict(this, id, this.clientContext, partitionKey);
  }
  /** Read the container's definition */
  async read(options) {
    return withDiagnostics(async (diagnosticNode) => {
      return this.readInternal(diagnosticNode, options);
    }, this.clientContext);
  }
  /**
   * @hidden
   */
  async readInternal(diagnosticNode, options) {
    const path = getPathFromLink(this.url);
    const id = getIdFromLink(this.url);
    const response = await this.clientContext.read({
      path,
      resourceType: ResourceType.container,
      resourceId: id,
      options,
      diagnosticNode
    });
    this.clientContext.partitionKeyDefinitionCache[this.url] = response.result.partitionKey;
    return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
  }
  /** Replace the container's definition */
  async replace(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.replace({
        body,
        path,
        resourceType: ResourceType.container,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /** Delete the container */
  async delete(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.delete({
        path,
        resourceType: ResourceType.container,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.
   * @deprecated This method has been renamed to readPartitionKeyDefinition.
   */
  async getPartitionKeyDefinition() {
    return withDiagnostics(async (diagnosticNode) => {
      return this.readPartitionKeyDefinition(diagnosticNode);
    }, this.clientContext);
  }
  /**
   * Gets the partition key definition first by looking into the cache otherwise by reading the collection.
   * @hidden
   */
  async readPartitionKeyDefinition(diagnosticNode) {
    if (this.url in this.clientContext.partitionKeyDefinitionCache) {
      diagnosticNode.addData({ readFromCache: true });
      return new ResourceResponse(this.clientContext.partitionKeyDefinitionCache[this.url], {}, 0, getEmptyCosmosDiagnostics());
    }
    const { headers, statusCode, diagnostics } = await withMetadataDiagnostics(async (node) => {
      return this.readInternal(node);
    }, diagnosticNode, MetadataLookUpType.ContainerLookUp);
    return new ResourceResponse(this.clientContext.partitionKeyDefinitionCache[this.url], headers, statusCode, diagnostics);
  }
  /**
   * Gets offer on container. If none exists, returns an OfferResponse with undefined.
   */
  async readOffer(options = {}) {
    return withDiagnostics(async (diagnosticNode) => {
      const { resource: container } = await this.read();
      const path = "/offers";
      const url = container._self;
      const response = await this.clientContext.queryFeed({
        path,
        resourceId: "",
        resourceType: ResourceType.offer,
        query: `SELECT * from root where root.resource = "${url}"`,
        resultFn: (result) => result.Offers,
        options,
        diagnosticNode
      });
      const offer = response.result[0] ? new Offer(this.database.client, response.result[0].id, this.clientContext) : void 0;
      return new OfferResponse(response.result[0], response.headers, response.code, getEmptyCosmosDiagnostics(), offer);
    }, this.clientContext);
  }
  async getQueryPlan(query) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      return this.clientContext.getQueryPlan(path + "/docs", ResourceType.item, getIdFromLink(this.url), query, {}, diagnosticNode);
    }, this.clientContext);
  }
  readPartitionKeyRanges(feedOptions) {
    feedOptions = feedOptions || {};
    return this.clientContext.queryPartitionKeyRanges(this.url, void 0, feedOptions);
  }
  /**
   *
   * @returns all the feed ranges for which changefeed could be fetched.
   */
  async getFeedRanges() {
    return withDiagnostics(async (diagnosticNode) => {
      const { resources } = await this.readPartitionKeyRanges().fetchAllInternal(diagnosticNode);
      const feedRanges = [];
      for (const resource of resources) {
        const feedRange = new FeedRangeInternal(resource.minInclusive, resource.maxExclusive);
        Object.freeze(feedRange);
        feedRanges.push(feedRange);
      }
      return feedRanges;
    }, this.clientContext);
  }
  /**
   * Delete all documents belong to the container for the provided partition key value
   * @param partitionKey - The partition key value of the items to be deleted
   */
  async deleteAllItemsForPartitionKey(partitionKey, options) {
    return withDiagnostics(async (diagnosticNode) => {
      let path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      path = path + "/operations/partitionkeydelete";
      const response = await this.clientContext.delete({
        path,
        resourceType: ResourceType.container,
        resourceId: id,
        options,
        partitionKey,
        method: HTTPMethod.post,
        diagnosticNode
      });
      return new ContainerResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/utils/offers.js
function validateOffer(body) {
  if (body.throughput) {
    if (body.maxThroughput) {
      console.log("should be erroring");
      throw new Error("Cannot specify `throughput` with `maxThroughput`");
    }
    if (body.autoUpgradePolicy) {
      throw new Error("Cannot specify autoUpgradePolicy with throughput. Use `maxThroughput` instead");
    }
  }
}

// node_modules/@azure/cosmos/dist-esm/src/client/Container/Containers.js
var Containers = class {
  constructor(database, clientContext) {
    this.database = database;
    this.clientContext = clientContext;
  }
  query(query, options) {
    const path = getPathFromLink(this.database.url, ResourceType.container);
    const id = getIdFromLink(this.database.url);
    return new QueryIterator(this.clientContext, query, options, (diagNode, innerOptions) => {
      return this.clientContext.queryFeed({
        path,
        resourceType: ResourceType.container,
        resourceId: id,
        resultFn: (result) => result.DocumentCollections,
        query,
        options: innerOptions,
        diagnosticNode: diagNode
      });
    });
  }
  /**
   * Creates a container.
   *
   * A container is a named logical container for items.
   *
   * A database may contain zero or more named containers and each container consists of
   * zero or more JSON items.
   *
   * Being schema-free, the items in a container do not need to share the same structure or fields.
   *
   *
   * Since containers are application resources, they can be authorized using either the
   * master key or resource keys.
   *
   * @param body - Represents the body of the container.
   * @param options - Use to set options like response page size, continuation tokens, etc.
   */
  async create(body, options = {}) {
    return withDiagnostics(async (diagnosticNode) => {
      return this.createInternal(diagnosticNode, body, options);
    }, this.clientContext);
  }
  /**
   * @hidden
   */
  async createInternal(diagnosticNode, body, options = {}) {
    const err = {};
    if (!isResourceValid(body, err)) {
      throw err;
    }
    const path = getPathFromLink(this.database.url, ResourceType.container);
    const id = getIdFromLink(this.database.url);
    validateOffer(body);
    if (body.maxThroughput) {
      const autoscaleParams = {
        maxThroughput: body.maxThroughput
      };
      if (body.autoUpgradePolicy) {
        autoscaleParams.autoUpgradePolicy = body.autoUpgradePolicy;
      }
      const autoscaleHeader = JSON.stringify(autoscaleParams);
      options.initialHeaders = Object.assign({}, options.initialHeaders, {
        [Constants.HttpHeaders.AutoscaleSettings]: autoscaleHeader
      });
      delete body.maxThroughput;
      delete body.autoUpgradePolicy;
    }
    if (body.throughput) {
      options.initialHeaders = Object.assign({}, options.initialHeaders, {
        [Constants.HttpHeaders.OfferThroughput]: body.throughput
      });
      delete body.throughput;
    }
    if (typeof body.partitionKey === "string") {
      if (!body.partitionKey.startsWith("/")) {
        throw new Error("Partition key must start with '/'");
      }
      body.partitionKey = {
        paths: [body.partitionKey]
      };
    }
    if (!body.partitionKey || !body.partitionKey.paths) {
      body.partitionKey = {
        paths: [DEFAULT_PARTITION_KEY_PATH]
      };
    }
    const response = await this.clientContext.create({
      body,
      path,
      resourceType: ResourceType.container,
      resourceId: id,
      diagnosticNode,
      options
    });
    const ref = new Container(this.database, response.result.id, this.clientContext);
    return new ContainerResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());
  }
  /**
   * Checks if a Container exists, and, if it doesn't, creates it.
   * This will make a read operation based on the id in the `body`, then if it is not found, a create operation.
   * You should confirm that the output matches the body you passed in for non-default properties (i.e. indexing policy/etc.)
   *
   * A container is a named logical container for items.
   *
   * A database may contain zero or more named containers and each container consists of
   * zero or more JSON items.
   *
   * Being schema-free, the items in a container do not need to share the same structure or fields.
   *
   *
   * Since containers are application resources, they can be authorized using either the
   * master key or resource keys.
   *
   * @param body - Represents the body of the container.
   * @param options - Use to set options like response page size, continuation tokens, etc.
   */
  async createIfNotExists(body, options) {
    if (!body || body.id === null || body.id === void 0) {
      throw new Error("body parameter must be an object with an id property");
    }
    return withDiagnostics(async (diagnosticNode) => {
      try {
        const readResponse = await this.database.container(body.id).readInternal(diagnosticNode, options);
        return readResponse;
      } catch (err) {
        if (err.code === StatusCodes.NotFound) {
          const createResponse = await this.createInternal(diagnosticNode, body, options);
          mergeHeaders(createResponse.headers, err.headers);
          return createResponse;
        } else {
          throw err;
        }
      }
    }, this.clientContext);
  }
  /**
   * Read all containers.
   * @param options - Use to set options like response page size, continuation tokens, etc.
   * @returns {@link QueryIterator} Allows you to return all containers in an array or iterate over them one at a time.
   * @example Read all containers to array.
   * ```typescript
   * const {body: containerList} = await client.database("<db id>").containers.readAll().fetchAll();
   * ```
   */
  readAll(options) {
    return this.query(void 0, options);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Permission/PermissionResponse.js
var PermissionResponse = class extends ResourceResponse {
  constructor(resource, headers, statusCode, permission, diagnostics) {
    super(resource, headers, statusCode, diagnostics);
    this.permission = permission;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Permission/Permission.js
var Permission = class {
  /**
   * Returns a reference URL to the resource. Used for linking in Permissions.
   */
  get url() {
    return createPermissionUri(this.user.database.id, this.user.id, this.id);
  }
  /**
   * @hidden
   * @param user - The parent {@link User}.
   * @param id - The id of the given {@link Permission}.
   */
  constructor(user, id, clientContext) {
    this.user = user;
    this.id = id;
    this.clientContext = clientContext;
  }
  /**
   * Read the {@link PermissionDefinition} of the given {@link Permission}.
   */
  async read(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.read({
        path,
        resourceType: ResourceType.permission,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new PermissionResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Replace the given {@link Permission} with the specified {@link PermissionDefinition}.
   * @param body - The specified {@link PermissionDefinition}.
   */
  async replace(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.replace({
        body,
        path,
        resourceType: ResourceType.permission,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new PermissionResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Delete the given {@link Permission}.
   */
  async delete(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.delete({
        path,
        resourceType: ResourceType.permission,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new PermissionResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Permission/Permissions.js
var Permissions = class {
  /**
   * @hidden
   * @param user - The parent {@link User}.
   */
  constructor(user, clientContext) {
    this.user = user;
    this.clientContext = clientContext;
  }
  query(query, options) {
    const path = getPathFromLink(this.user.url, ResourceType.permission);
    const id = getIdFromLink(this.user.url);
    return new QueryIterator(this.clientContext, query, options, (diagnosticNode, innerOptions) => {
      return this.clientContext.queryFeed({
        path,
        resourceType: ResourceType.permission,
        resourceId: id,
        resultFn: (result) => result.Permissions,
        query,
        options: innerOptions,
        diagnosticNode
      });
    });
  }
  /**
   * Read all permissions.
   * @example Read all permissions to array.
   * ```typescript
   * const {body: permissionList} = await user.permissions.readAll().fetchAll();
   * ```
   */
  readAll(options) {
    return this.query(void 0, options);
  }
  /**
   * Create a permission.
   *
   * A permission represents a per-User Permission to access a specific resource
   * e.g. Item or Container.
   * @param body - Represents the body of the permission.
   */
  async create(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.user.url, ResourceType.permission);
      const id = getIdFromLink(this.user.url);
      const response = await this.clientContext.create({
        body,
        path,
        resourceType: ResourceType.permission,
        resourceId: id,
        diagnosticNode,
        options
      });
      const ref = new Permission(this.user, response.result.id, this.clientContext);
      return new PermissionResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Upsert a permission.
   *
   * A permission represents a per-User Permission to access a
   * specific resource e.g. Item or Container.
   */
  async upsert(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.user.url, ResourceType.permission);
      const id = getIdFromLink(this.user.url);
      const response = await this.clientContext.upsert({
        body,
        path,
        resourceType: ResourceType.permission,
        resourceId: id,
        options,
        diagnosticNode
      });
      const ref = new Permission(this.user, response.result.id, this.clientContext);
      return new PermissionResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/User/UserResponse.js
var UserResponse = class extends ResourceResponse {
  constructor(resource, headers, statusCode, user, diagnostics) {
    super(resource, headers, statusCode, diagnostics);
    this.user = user;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/User/User.js
var User = class {
  /**
   * Returns a reference URL to the resource. Used for linking in Permissions.
   */
  get url() {
    return createUserUri(this.database.id, this.id);
  }
  /**
   * @hidden
   * @param database - The parent {@link Database}.
   */
  constructor(database, id, clientContext) {
    this.database = database;
    this.id = id;
    this.clientContext = clientContext;
    this.permissions = new Permissions(this, this.clientContext);
  }
  /**
   * Operations to read, replace, or delete a specific Permission by id.
   *
   * See `client.permissions` for creating, upserting, querying, or reading all operations.
   */
  permission(id) {
    return new Permission(this, id, this.clientContext);
  }
  /**
   * Read the {@link UserDefinition} for the given {@link User}.
   */
  async read(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.read({
        path,
        resourceType: ResourceType.user,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new UserResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Replace the given {@link User}'s definition with the specified {@link UserDefinition}.
   * @param body - The specified {@link UserDefinition} to replace the definition.
   */
  async replace(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.replace({
        body,
        path,
        resourceType: ResourceType.user,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new UserResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Delete the given {@link User}.
   */
  async delete(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.delete({
        path,
        resourceType: ResourceType.user,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new UserResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/User/Users.js
var Users = class {
  /**
   * @hidden
   * @param database - The parent {@link Database}.
   */
  constructor(database, clientContext) {
    this.database = database;
    this.clientContext = clientContext;
  }
  query(query, options) {
    const path = getPathFromLink(this.database.url, ResourceType.user);
    const id = getIdFromLink(this.database.url);
    return new QueryIterator(this.clientContext, query, options, (diagnosticNode, innerOptions) => {
      return this.clientContext.queryFeed({
        path,
        resourceType: ResourceType.user,
        resourceId: id,
        resultFn: (result) => result.Users,
        query,
        options: innerOptions,
        diagnosticNode
      });
    });
  }
  /**
   * Read all users.-
   * @example Read all users to array.
   * ```typescript
   * const {body: usersList} = await database.users.readAll().fetchAll();
   * ```
   */
  readAll(options) {
    return this.query(void 0, options);
  }
  /**
   * Create a database user with the specified {@link UserDefinition}.
   * @param body - The specified {@link UserDefinition}.
   */
  async create(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.database.url, ResourceType.user);
      const id = getIdFromLink(this.database.url);
      const response = await this.clientContext.create({
        body,
        path,
        resourceType: ResourceType.user,
        resourceId: id,
        options,
        diagnosticNode
      });
      const ref = new User(this.database, response.result.id, this.clientContext);
      return new UserResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Upsert a database user with a specified {@link UserDefinition}.
   * @param body - The specified {@link UserDefinition}.
   */
  async upsert(body, options) {
    return withDiagnostics(async (diagnosticNode) => {
      const err = {};
      if (!isResourceValid(body, err)) {
        throw err;
      }
      const path = getPathFromLink(this.database.url, ResourceType.user);
      const id = getIdFromLink(this.database.url);
      const response = await this.clientContext.upsert({
        body,
        path,
        resourceType: ResourceType.user,
        resourceId: id,
        options,
        diagnosticNode
      });
      const ref = new User(this.database, response.result.id, this.clientContext);
      return new UserResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Database/DatabaseResponse.js
var DatabaseResponse = class extends ResourceResponse {
  constructor(resource, headers, statusCode, database, diagnostics) {
    super(resource, headers, statusCode, diagnostics);
    this.database = database;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Database/Database.js
var Database = class {
  /**
   * Returns a reference URL to the resource. Used for linking in Permissions.
   */
  get url() {
    return createDatabaseUri(this.id);
  }
  /** Returns a new {@link Database} instance.
   *
   * Note: the intention is to get this object from {@link CosmosClient} via `client.database(id)`, not to instantiate it yourself.
   */
  constructor(client, id, clientContext) {
    this.client = client;
    this.id = id;
    this.clientContext = clientContext;
    this.containers = new Containers(this, this.clientContext);
    this.users = new Users(this, this.clientContext);
  }
  /**
   * Used to read, replace, or delete a specific, existing {@link Database} by id.
   *
   * Use `.containers` creating new containers, or querying/reading all containers.
   *
   * @example Delete a container
   * ```typescript
   * await client.database("<db id>").container("<container id>").delete();
   * ```
   */
  container(id) {
    return new Container(this, id, this.clientContext);
  }
  /**
   * Used to read, replace, or delete a specific, existing {@link User} by id.
   *
   * Use `.users` for creating new users, or querying/reading all users.
   */
  user(id) {
    return new User(this, id, this.clientContext);
  }
  /** Read the definition of the given Database. */
  async read(options) {
    return withDiagnostics(async (diagnosticNode) => {
      return this.readInternal(diagnosticNode, options);
    }, this.clientContext);
  }
  /**
   * @hidden
   */
  async readInternal(diagnosticNode, options) {
    const path = getPathFromLink(this.url);
    const id = getIdFromLink(this.url);
    const response = await this.clientContext.read({
      path,
      resourceType: ResourceType.database,
      resourceId: id,
      options,
      diagnosticNode
    });
    return new DatabaseResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
  }
  /** Delete the given Database. */
  async delete(options) {
    return withDiagnostics(async (diagnosticNode) => {
      const path = getPathFromLink(this.url);
      const id = getIdFromLink(this.url);
      const response = await this.clientContext.delete({
        path,
        resourceType: ResourceType.database,
        resourceId: id,
        options,
        diagnosticNode
      });
      return new DatabaseResponse(response.result, response.headers, response.code, this, getEmptyCosmosDiagnostics());
    }, this.clientContext);
  }
  /**
   * Gets offer on database. If none exists, returns an OfferResponse with undefined.
   */
  async readOffer(options = {}) {
    return withDiagnostics(async (diagnosticNode) => {
      const { resource: record } = await withMetadataDiagnostics(async (node) => {
        return this.readInternal(node);
      }, diagnosticNode, MetadataLookUpType.DatabaseLookUp);
      const path = "/offers";
      const url = record._self;
      const response = await this.clientContext.queryFeed({
        path,
        resourceId: "",
        resourceType: ResourceType.offer,
        query: `SELECT * from root where root.resource = "${url}"`,
        resultFn: (result) => result.Offers,
        options,
        diagnosticNode
      });
      const offer = response.result[0] ? new Offer(this.client, response.result[0].id, this.clientContext) : void 0;
      return new OfferResponse(response.result[0], response.headers, response.code, getEmptyCosmosDiagnostics(), offer);
    }, this.clientContext);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/Database/Databases.js
var Databases = class {
  /**
   * @hidden
   * @param client - The parent {@link CosmosClient} for the Database.
   */
  constructor(client, clientContext) {
    this.client = client;
    this.clientContext = clientContext;
  }
  query(query, options) {
    const cb = (diagNode, innerOptions) => {
      return this.clientContext.queryFeed({
        path: "/dbs",
        resourceType: ResourceType.database,
        resourceId: "",
        resultFn: (result) => result.Databases,
        query,
        options: innerOptions,
        diagnosticNode: diagNode
      });
    };
    return new QueryIterator(this.clientContext, query, options, cb);
  }
  /**
   * Send a request for creating a database.
   *
   * A database manages users, permissions and a set of containers.
   * Each Azure Cosmos DB Database Account is able to support multiple independent named databases,
   * with the database being the logical container for data.
   *
   * Each Database consists of one or more containers, each of which in turn contain one or more
   * documents. Since databases are an administrative resource, the Service Master Key will be
   * required in order to access and successfully complete any action using the User APIs.
   *
   * @param body - The {@link DatabaseDefinition} that represents the {@link Database} to be created.
   * @param options - Use to set options like response page size, continuation tokens, etc.
   */
  async create(body, options = {}) {
    return withDiagnostics(async (diagnosticNode) => {
      return this.createInternal(diagnosticNode, body, options);
    }, this.clientContext);
  }
  /**
   * @hidden
   */
  async createInternal(diagnosticNode, body, options = {}) {
    const err = {};
    if (!isResourceValid(body, err)) {
      throw err;
    }
    validateOffer(body);
    if (body.maxThroughput) {
      const autoscaleParams = {
        maxThroughput: body.maxThroughput
      };
      if (body.autoUpgradePolicy) {
        autoscaleParams.autoUpgradePolicy = body.autoUpgradePolicy;
      }
      const autoscaleHeaders = JSON.stringify(autoscaleParams);
      options.initialHeaders = Object.assign({}, options.initialHeaders, {
        [Constants.HttpHeaders.AutoscaleSettings]: autoscaleHeaders
      });
      delete body.maxThroughput;
      delete body.autoUpgradePolicy;
    }
    if (body.throughput) {
      options.initialHeaders = Object.assign({}, options.initialHeaders, {
        [Constants.HttpHeaders.OfferThroughput]: body.throughput
      });
      delete body.throughput;
    }
    const path = "/dbs";
    const response = await this.clientContext.create({
      body,
      path,
      resourceType: ResourceType.database,
      resourceId: void 0,
      diagnosticNode,
      options
    });
    const ref = new Database(this.client, body.id, this.clientContext);
    return new DatabaseResponse(response.result, response.headers, response.code, ref, getEmptyCosmosDiagnostics());
  }
  /**
   * Check if a database exists, and if it doesn't, create it.
   * This will make a read operation based on the id in the `body`, then if it is not found, a create operation.
   *
   * A database manages users, permissions and a set of containers.
   * Each Azure Cosmos DB Database Account is able to support multiple independent named databases,
   * with the database being the logical container for data.
   *
   * Each Database consists of one or more containers, each of which in turn contain one or more
   * documents. Since databases are an an administrative resource, the Service Master Key will be
   * required in order to access and successfully complete any action using the User APIs.
   *
   * @param body - The {@link DatabaseDefinition} that represents the {@link Database} to be created.
   * @param options - Additional options for the request
   */
  async createIfNotExists(body, options) {
    if (!body || body.id === null || body.id === void 0) {
      throw new Error("body parameter must be an object with an id property");
    }
    return withDiagnostics(async (diagnosticNode) => {
      try {
        const readResponse = await this.client.database(body.id).readInternal(diagnosticNode, options);
        return readResponse;
      } catch (err) {
        if (err.code === StatusCodes.NotFound) {
          const createResponse = await this.createInternal(diagnosticNode, body, options);
          mergeHeaders(createResponse.headers, err.headers);
          return createResponse;
        } else {
          throw err;
        }
      }
    }, this.clientContext);
  }
  // TODO: DatabaseResponse for QueryIterator?
  /**
   * Reads all databases.
   * @param options - Use to set options like response page size, continuation tokens, etc.
   * @returns {@link QueryIterator} Allows you to return all databases in an array or iterate over them one at a time.
   * @example Read all databases to array.
   * ```typescript
   * const {body: databaseList} = await client.databases.readAll().fetchAll();
   * ```
   */
  readAll(options) {
    return this.query(void 0, options);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/plugins/Plugin.js
var PluginOn;
(function(PluginOn2) {
  PluginOn2["request"] = "request";
  PluginOn2["operation"] = "operation";
})(PluginOn || (PluginOn = {}));
async function executePlugins(diagnosticNode, requestContext, next, on) {
  if (!requestContext.plugins) {
    return next(requestContext, diagnosticNode, void 0);
  }
  let level = 0;
  const _ = (inner) => {
    if (++level >= inner.plugins.length) {
      return next(requestContext, diagnosticNode, void 0);
    } else if (inner.plugins[level].on !== on) {
      return _(requestContext);
    } else {
      return inner.plugins[level].plugin(inner, diagnosticNode, _);
    }
  };
  if (requestContext.plugins[level].on !== on) {
    return _(requestContext);
  } else {
    return requestContext.plugins[level].plugin(requestContext, diagnosticNode, _);
  }
}

// node_modules/@azure/cosmos/dist-esm/src/request/RequestHandler.js
var import_node_abort_controller = __toESM(require_browser());

// node_modules/@azure/cosmos/dist-esm/src/retry/defaultRetryPolicy.js
var WindowsInterruptedFunctionCall = 10004;
var WindowsFileHandleNotValid = 10009;
var WindowsPermissionDenied = 10013;
var WindowsBadAddress = 10014;
var WindowsInvalidArgumnet = 10022;
var WindowsResourceTemporarilyUnavailable = 10035;
var WindowsOperationNowInProgress = 10036;
var WindowsAddressAlreadyInUse = 10048;
var WindowsConnectionResetByPeer = 10054;
var WindowsCannotSendAfterSocketShutdown = 10058;
var WindowsConnectionTimedOut = 10060;
var WindowsConnectionRefused = 10061;
var WindowsNameTooLong = 10063;
var WindowsHostIsDown = 10064;
var WindowsNoRouteTohost = 10065;
var LinuxConnectionReset = "ECONNRESET";
var BrokenPipe = "EPIPE";
var CONNECTION_ERROR_CODES = [
  WindowsInterruptedFunctionCall,
  WindowsFileHandleNotValid,
  WindowsPermissionDenied,
  WindowsBadAddress,
  WindowsInvalidArgumnet,
  WindowsResourceTemporarilyUnavailable,
  WindowsOperationNowInProgress,
  WindowsAddressAlreadyInUse,
  WindowsConnectionResetByPeer,
  WindowsCannotSendAfterSocketShutdown,
  WindowsConnectionTimedOut,
  WindowsConnectionRefused,
  WindowsNameTooLong,
  WindowsHostIsDown,
  WindowsNoRouteTohost,
  LinuxConnectionReset,
  TimeoutErrorCode,
  BrokenPipe
];
function needsRetry(operationType, code) {
  if ((operationType === OperationType.Read || operationType === OperationType.Query) && CONNECTION_ERROR_CODES.indexOf(code) !== -1) {
    return true;
  } else {
    return false;
  }
}
var DefaultRetryPolicy = class {
  constructor(operationType) {
    this.operationType = operationType;
    this.maxTries = 10;
    this.currentRetryAttemptCount = 0;
    this.retryAfterInMs = 1e3;
  }
  /**
   * Determines whether the request should be retried or not.
   * @param err - Error returned by the request.
   */
  async shouldRetry(err, diagnosticNode) {
    if (err) {
      if (this.currentRetryAttemptCount < this.maxTries && needsRetry(this.operationType, err.code)) {
        diagnosticNode.addData({ successfulRetryPolicy: "default" });
        this.currentRetryAttemptCount++;
        return true;
      }
    }
    return false;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/retry/endpointDiscoveryRetryPolicy.js
var EndpointDiscoveryRetryPolicy = class _EndpointDiscoveryRetryPolicy {
  /**
   * @param globalEndpointManager - The GlobalEndpointManager instance.
   */
  constructor(globalEndpointManager, operationType) {
    this.globalEndpointManager = globalEndpointManager;
    this.operationType = operationType;
    this.maxTries = _EndpointDiscoveryRetryPolicy.maxTries;
    this.currentRetryAttemptCount = 0;
    this.retryAfterInMs = _EndpointDiscoveryRetryPolicy.retryAfterInMs;
  }
  /**
   * Determines whether the request should be retried or not.
   * @param err - Error returned by the request.
   */
  async shouldRetry(err, diagnosticNode, retryContext, locationEndpoint) {
    if (!err) {
      return false;
    }
    if (!retryContext || !locationEndpoint) {
      return false;
    }
    if (!this.globalEndpointManager.enableEndpointDiscovery) {
      return false;
    }
    if (this.currentRetryAttemptCount >= this.maxTries) {
      return false;
    }
    this.currentRetryAttemptCount++;
    if (isReadRequest(this.operationType)) {
      await this.globalEndpointManager.markCurrentLocationUnavailableForRead(diagnosticNode, locationEndpoint);
    } else {
      await this.globalEndpointManager.markCurrentLocationUnavailableForWrite(diagnosticNode, locationEndpoint);
    }
    retryContext.retryCount = this.currentRetryAttemptCount;
    retryContext.clearSessionTokenNotAvailable = false;
    retryContext.retryRequestOnPreferredLocations = false;
    diagnosticNode.addData({ successfulRetryPolicy: "endpointDiscovery" });
    return true;
  }
};
EndpointDiscoveryRetryPolicy.maxTries = 120;
EndpointDiscoveryRetryPolicy.retryAfterInMs = 1e3;

// node_modules/@azure/cosmos/dist-esm/src/retry/resourceThrottleRetryPolicy.js
var ResourceThrottleRetryPolicy = class {
  /**
   * @param maxTries - Max number of retries to be performed for a request.
   * @param fixedRetryIntervalInMs - Fixed retry interval in milliseconds to wait between each
   * retry ignoring the retryAfter returned as part of the response.
   * @param timeoutInSeconds - Max wait time in seconds to wait for a request while the
   * retries are happening.
   */
  constructor(maxTries = 9, fixedRetryIntervalInMs = 0, timeoutInSeconds = 30) {
    this.maxTries = maxTries;
    this.fixedRetryIntervalInMs = fixedRetryIntervalInMs;
    this.currentRetryAttemptCount = 0;
    this.cummulativeWaitTimeinMs = 0;
    this.retryAfterInMs = 0;
    this.timeoutInMs = timeoutInSeconds * 1e3;
    this.currentRetryAttemptCount = 0;
    this.cummulativeWaitTimeinMs = 0;
  }
  /**
   * Determines whether the request should be retried or not.
   * @param err - Error returned by the request.
   */
  async shouldRetry(err, diagnosticNode) {
    if (err) {
      if (this.currentRetryAttemptCount < this.maxTries) {
        this.currentRetryAttemptCount++;
        this.retryAfterInMs = 0;
        if (this.fixedRetryIntervalInMs) {
          this.retryAfterInMs = this.fixedRetryIntervalInMs;
        } else if (err.retryAfterInMs) {
          this.retryAfterInMs = err.retryAfterInMs;
        }
        if (this.cummulativeWaitTimeinMs < this.timeoutInMs) {
          this.cummulativeWaitTimeinMs += this.retryAfterInMs;
          diagnosticNode.addData({ successfulRetryPolicy: "resourceThrottle" });
          return true;
        }
      }
    }
    return false;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/retry/sessionRetryPolicy.js
var SessionRetryPolicy = class {
  /**
   * @param globalEndpointManager - The GlobalEndpointManager instance.
   */
  constructor(globalEndpointManager, resourceType, operationType, connectionPolicy) {
    this.globalEndpointManager = globalEndpointManager;
    this.resourceType = resourceType;
    this.operationType = operationType;
    this.connectionPolicy = connectionPolicy;
    this.currentRetryAttemptCount = 0;
    this.retryAfterInMs = 0;
  }
  /**
   * Determines whether the request should be retried or not.
   * @param err - Error returned by the request.
   * @param callback - The callback function which takes bool argument which specifies whether the request
   * will be retried or not.
   */
  async shouldRetry(err, diagnosticNode, retryContext) {
    if (!err) {
      return false;
    }
    if (!retryContext) {
      return false;
    }
    if (!this.connectionPolicy.enableEndpointDiscovery) {
      return false;
    }
    if (this.globalEndpointManager.canUseMultipleWriteLocations(this.resourceType, this.operationType)) {
      const endpoints = isReadRequest(this.operationType) ? await this.globalEndpointManager.getReadEndpoints() : await this.globalEndpointManager.getWriteEndpoints();
      if (this.currentRetryAttemptCount > endpoints.length) {
        return false;
      } else {
        this.currentRetryAttemptCount++;
        retryContext.retryCount++;
        retryContext.retryRequestOnPreferredLocations = this.currentRetryAttemptCount > 1;
        retryContext.clearSessionTokenNotAvailable = this.currentRetryAttemptCount === endpoints.length;
        diagnosticNode.addData({ successfulRetryPolicy: "session" });
        return true;
      }
    } else {
      if (this.currentRetryAttemptCount > 1) {
        return false;
      } else {
        this.currentRetryAttemptCount++;
        retryContext.retryCount++;
        retryContext.retryRequestOnPreferredLocations = false;
        retryContext.clearSessionTokenNotAvailable = true;
        diagnosticNode.addData({ successfulRetryPolicy: "session" });
        return true;
      }
    }
  }
};

// node_modules/@azure/cosmos/dist-esm/src/retry/timeoutFailoverRetryPolicy.js
var TimeoutFailoverRetryPolicy = class {
  constructor(globalEndpointManager, headers, methodType, resourceType, operationType, enableEndPointDiscovery) {
    this.globalEndpointManager = globalEndpointManager;
    this.headers = headers;
    this.methodType = methodType;
    this.resourceType = resourceType;
    this.operationType = operationType;
    this.enableEndPointDiscovery = enableEndPointDiscovery;
    this.maxRetryAttemptCount = 120;
    this.maxServiceUnavailableRetryCount = 1;
    this.retryAfterInMs = 0;
    this.failoverRetryCount = 0;
  }
  /**
   * Checks if a timeout request is valid for the timeout failover retry policy.
   * A valid request should be a data plane, metadata, or query plan request.
   * @returns
   */
  isValidRequestForTimeoutError() {
    const isQuery = Constants.HttpHeaders.IsQuery in this.headers;
    const isQueryPlan = Constants.HttpHeaders.IsQueryPlan in this.headers;
    if (this.methodType === HTTPMethod.get || isQuery || isQueryPlan) {
      return true;
    }
    return false;
  }
  async shouldRetry(err, diagnosticNode, retryContext, locationEndpoint) {
    if (!err) {
      return false;
    }
    if (!retryContext || !locationEndpoint) {
      return false;
    }
    if (err.code === TimeoutErrorCode && !this.isValidRequestForTimeoutError()) {
      return false;
    }
    if (!this.enableEndPointDiscovery) {
      return false;
    }
    if (err.code === StatusCodes.ServiceUnavailable && this.failoverRetryCount >= this.maxServiceUnavailableRetryCount) {
      return false;
    }
    if (this.failoverRetryCount >= this.maxRetryAttemptCount) {
      return false;
    }
    const canUseMultipleWriteLocations = this.globalEndpointManager.canUseMultipleWriteLocations(this.resourceType, this.operationType);
    const readRequest = isReadRequest(this.operationType);
    if (!canUseMultipleWriteLocations && !readRequest) {
      return false;
    }
    this.failoverRetryCount++;
    retryContext.retryLocationServerIndex = await this.findEndpointIndex(this.failoverRetryCount);
    diagnosticNode.addData({ successfulRetryPolicy: "timeout-failover" });
    return true;
  }
  /**
   * Determines index of endpoint to be used for retry based upon failoverRetryCount and avalable locations
   * @param failoverRetryCount - count of failovers
   * @returns
   */
  async findEndpointIndex(failoverRetryCount) {
    const preferredLocationsCount = this.globalEndpointManager.preferredLocationsCount;
    const readRequest = isReadRequest(this.operationType);
    let endpointIndex = 0;
    if (preferredLocationsCount !== 0) {
      endpointIndex = failoverRetryCount % preferredLocationsCount;
    } else {
      if (readRequest) {
        const getReadEndpoints = await this.globalEndpointManager.getReadEndpoints();
        if (getReadEndpoints && getReadEndpoints.length > 0) {
          endpointIndex = failoverRetryCount % getReadEndpoints.length;
        }
      } else {
        const getWriteEndpoints = await this.globalEndpointManager.getWriteEndpoints();
        if (getWriteEndpoints && getWriteEndpoints.length > 0) {
          endpointIndex = failoverRetryCount % getWriteEndpoints.length;
        }
      }
    }
    return endpointIndex;
  }
};

// node_modules/@azure/cosmos/dist-esm/src/retry/retryUtility.js
async function execute({ diagnosticNode, retryContext = { retryCount: 0 }, retryPolicies, requestContext, executeRequest: executeRequest2 }) {
  return addDignosticChild(async (localDiagnosticNode) => {
    localDiagnosticNode.addData({ requestAttempNumber: retryContext.retryCount });
    if (!retryPolicies) {
      retryPolicies = {
        endpointDiscoveryRetryPolicy: new EndpointDiscoveryRetryPolicy(requestContext.globalEndpointManager, requestContext.operationType),
        resourceThrottleRetryPolicy: new ResourceThrottleRetryPolicy(requestContext.connectionPolicy.retryOptions.maxRetryAttemptCount, requestContext.connectionPolicy.retryOptions.fixedRetryIntervalInMilliseconds, requestContext.connectionPolicy.retryOptions.maxWaitTimeInSeconds),
        sessionReadRetryPolicy: new SessionRetryPolicy(requestContext.globalEndpointManager, requestContext.resourceType, requestContext.operationType, requestContext.connectionPolicy),
        defaultRetryPolicy: new DefaultRetryPolicy(requestContext.operationType),
        timeoutFailoverRetryPolicy: new TimeoutFailoverRetryPolicy(requestContext.globalEndpointManager, requestContext.headers, requestContext.method, requestContext.resourceType, requestContext.operationType, requestContext.connectionPolicy.enableEndpointDiscovery)
      };
    }
    if (retryContext && retryContext.clearSessionTokenNotAvailable) {
      requestContext.client.clearSessionToken(requestContext.path);
      delete requestContext.headers["x-ms-session-token"];
    }
    if (retryContext && retryContext.retryLocationServerIndex) {
      requestContext.endpoint = await requestContext.globalEndpointManager.resolveServiceEndpoint(localDiagnosticNode, requestContext.resourceType, requestContext.operationType, retryContext.retryLocationServerIndex);
    } else {
      requestContext.endpoint = await requestContext.globalEndpointManager.resolveServiceEndpoint(localDiagnosticNode, requestContext.resourceType, requestContext.operationType);
    }
    const startTimeUTCInMs = getCurrentTimestampInMs();
    try {
      const response = await executeRequest2(localDiagnosticNode, requestContext);
      response.headers[Constants.ThrottleRetryCount] = retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;
      response.headers[Constants.ThrottleRetryWaitTimeInMs] = retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;
      return response;
    } catch (err) {
      let retryPolicy = null;
      const headers = err.headers || {};
      if (err.code === StatusCodes.ENOTFOUND || err.code === "REQUEST_SEND_ERROR" || err.code === StatusCodes.Forbidden && (err.substatus === SubStatusCodes.DatabaseAccountNotFound || err.substatus === SubStatusCodes.WriteForbidden)) {
        retryPolicy = retryPolicies.endpointDiscoveryRetryPolicy;
      } else if (err.code === StatusCodes.TooManyRequests) {
        retryPolicy = retryPolicies.resourceThrottleRetryPolicy;
      } else if (err.code === StatusCodes.NotFound && err.substatus === SubStatusCodes.ReadSessionNotAvailable) {
        retryPolicy = retryPolicies.sessionReadRetryPolicy;
      } else if (err.code === StatusCodes.ServiceUnavailable || err.code === TimeoutErrorCode) {
        retryPolicy = retryPolicies.timeoutFailoverRetryPolicy;
      } else {
        retryPolicy = retryPolicies.defaultRetryPolicy;
      }
      const results = await retryPolicy.shouldRetry(err, localDiagnosticNode, retryContext, requestContext.endpoint);
      if (!results) {
        headers[Constants.ThrottleRetryCount] = retryPolicies.resourceThrottleRetryPolicy.currentRetryAttemptCount;
        headers[Constants.ThrottleRetryWaitTimeInMs] = retryPolicies.resourceThrottleRetryPolicy.cummulativeWaitTimeinMs;
        err.headers = Object.assign(Object.assign({}, err.headers), headers);
        throw err;
      } else {
        requestContext.retryCount++;
        const newUrl = results[1];
        if (newUrl !== void 0) {
          requestContext.endpoint = newUrl;
        }
        localDiagnosticNode.recordFailedNetworkCall(startTimeUTCInMs, requestContext, retryContext.retryCount, err.code, err.subsstatusCode, headers);
        await sleep(retryPolicy.retryAfterInMs);
        return execute({
          diagnosticNode,
          executeRequest: executeRequest2,
          requestContext,
          retryContext,
          retryPolicies
        });
      }
    }
  }, diagnosticNode, DiagnosticNodeType.HTTP_REQUEST);
}

// node_modules/@azure/cosmos/dist-esm/src/request/defaultAgent.browser.js
var defaultHttpAgent;
var defaultHttpsAgent;

// node_modules/@azure/cosmos/dist-esm/src/utils/cachedClient.js
var cachedHttpClient;
function getCachedDefaultHttpClient() {
  if (!cachedHttpClient) {
    cachedHttpClient = createDefaultHttpClient();
  }
  return cachedHttpClient;
}

// node_modules/@azure/cosmos/dist-esm/src/request/RequestHandler.js
var logger4 = createClientLogger("RequestHandler");
async function executeRequest(diagnosticNode, requestContext) {
  return executePlugins(diagnosticNode, requestContext, httpRequest, PluginOn.request);
}
async function httpRequest(requestContext, diagnosticNode) {
  const controller = new import_node_abort_controller.AbortController();
  const signal = controller.signal;
  const userSignal = requestContext.options && requestContext.options.abortSignal;
  if (userSignal) {
    if (userSignal.aborted) {
      controller.abort();
    } else {
      userSignal.addEventListener("abort", () => {
        controller.abort();
      });
    }
  }
  const timeout = setTimeout(() => {
    controller.abort();
  }, requestContext.connectionPolicy.requestTimeout);
  let response;
  if (requestContext.body) {
    requestContext.body = bodyFromData(requestContext.body);
  }
  const httpsClient = getCachedDefaultHttpClient();
  const url = prepareURL(requestContext.endpoint, requestContext.path);
  const reqHeaders = createHttpHeaders(requestContext.headers);
  const pipelineRequest = createPipelineRequest({
    url,
    headers: reqHeaders,
    method: requestContext.method,
    abortSignal: signal,
    body: requestContext.body
  });
  if (requestContext.requestAgent) {
    pipelineRequest.agent = requestContext.requestAgent;
  } else {
    const parsedUrl = new URL(url);
    pipelineRequest.agent = parsedUrl.protocol === "http" ? defaultHttpAgent : defaultHttpsAgent;
  }
  const startTimeUTCInMs = getCurrentTimestampInMs();
  try {
    if (requestContext.pipeline) {
      response = await requestContext.pipeline.sendRequest(httpsClient, pipelineRequest);
    } else {
      response = await httpsClient.sendRequest(pipelineRequest);
    }
  } catch (error) {
    if (error.name === "AbortError") {
      if (userSignal && userSignal.aborted === true) {
        clearTimeout(timeout);
        throw error;
      }
      throw new TimeoutError(`Timeout Error! Request took more than ${requestContext.connectionPolicy.requestTimeout} ms`);
    }
    throw error;
  }
  clearTimeout(timeout);
  const result = response.status === 204 || response.status === 304 || response.bodyAsText === "" ? null : JSON.parse(response.bodyAsText);
  const responseHeaders = response.headers.toJSON();
  const substatus = responseHeaders[Constants.HttpHeaders.SubStatus] ? parseInt(responseHeaders[Constants.HttpHeaders.SubStatus], 10) : void 0;
  diagnosticNode.recordSuccessfulNetworkCall(startTimeUTCInMs, requestContext, response, substatus, url);
  if (response.status >= 400) {
    const errorResponse = new ErrorResponse(result.message);
    logger4.warning(response.status + " " + requestContext.endpoint + " " + requestContext.path + " " + result.message);
    errorResponse.code = response.status;
    errorResponse.body = result;
    errorResponse.headers = responseHeaders;
    if (Constants.HttpHeaders.ActivityId in responseHeaders) {
      errorResponse.activityId = responseHeaders[Constants.HttpHeaders.ActivityId];
    }
    if (Constants.HttpHeaders.SubStatus in responseHeaders) {
      errorResponse.substatus = substatus;
    }
    if (Constants.HttpHeaders.RetryAfterInMs in responseHeaders) {
      errorResponse.retryAfterInMs = parseInt(responseHeaders[Constants.HttpHeaders.RetryAfterInMs], 10);
      Object.defineProperty(errorResponse, "retryAfterInMilliseconds", {
        get: () => {
          return errorResponse.retryAfterInMs;
        }
      });
    }
    throw errorResponse;
  }
  return {
    headers: responseHeaders,
    result,
    code: response.status,
    substatus
  };
}
async function request(requestContext, diagnosticNode) {
  if (requestContext.body) {
    requestContext.body = bodyFromData(requestContext.body);
    if (!requestContext.body) {
      throw new Error("parameter data must be a javascript object, string, or Buffer");
    }
  }
  return addDignosticChild(async (childNode) => {
    return execute({
      diagnosticNode: childNode,
      requestContext,
      executeRequest
    });
  }, diagnosticNode, DiagnosticNodeType.REQUEST_ATTEMPTS);
}
var RequestHandler = {
  request
};

// node_modules/@azure/cosmos/dist-esm/src/session/VectorSessionToken.js
var VectorSessionToken = class _VectorSessionToken {
  constructor(version, globalLsn, localLsnByregion, sessionToken) {
    this.version = version;
    this.globalLsn = globalLsn;
    this.localLsnByregion = localLsnByregion;
    this.sessionToken = sessionToken;
    if (!this.sessionToken) {
      const regionAndLocalLsn = [];
      for (const [key, value] of this.localLsnByregion.entries()) {
        regionAndLocalLsn.push(`${key}${_VectorSessionToken.REGION_PROGRESS_SEPARATOR}${value}`);
      }
      const regionProgress = regionAndLocalLsn.join(_VectorSessionToken.SEGMENT_SEPARATOR);
      if (regionProgress === "") {
        this.sessionToken = `${this.version}${_VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}`;
      } else {
        this.sessionToken = `${this.version}${_VectorSessionToken.SEGMENT_SEPARATOR}${this.globalLsn}${_VectorSessionToken.SEGMENT_SEPARATOR}${regionProgress}`;
      }
    }
  }
  static create(sessionToken) {
    const [versionStr, globalLsnStr, ...regionSegments] = sessionToken.split(_VectorSessionToken.SEGMENT_SEPARATOR);
    const version = parseInt(versionStr, 10);
    const globalLsn = parseFloat(globalLsnStr);
    if (typeof version !== "number" || typeof globalLsn !== "number") {
      return null;
    }
    const lsnByRegion = /* @__PURE__ */ new Map();
    for (const regionSegment of regionSegments) {
      const [regionIdStr, localLsnStr] = regionSegment.split(_VectorSessionToken.REGION_PROGRESS_SEPARATOR);
      if (!regionIdStr || !localLsnStr) {
        return null;
      }
      const regionId = parseInt(regionIdStr, 10);
      let localLsn;
      try {
        localLsn = localLsnStr;
      } catch (err) {
        return null;
      }
      if (typeof regionId !== "number") {
        return null;
      }
      lsnByRegion.set(regionId, localLsn);
    }
    return new _VectorSessionToken(version, globalLsn, lsnByRegion, sessionToken);
  }
  equals(other) {
    return !other ? false : this.version === other.version && this.globalLsn === other.globalLsn && this.areRegionProgressEqual(other.localLsnByregion);
  }
  merge(other) {
    if (other == null) {
      throw new Error("other (Vector Session Token) must not be null");
    }
    if (this.version === other.version && this.localLsnByregion.size !== other.localLsnByregion.size) {
      throw new Error(`Compared session tokens ${this.sessionToken} and ${other.sessionToken} have unexpected regions`);
    }
    const [higherVersionSessionToken, lowerVersionSessionToken] = this.version < other.version ? [other, this] : [this, other];
    const highestLocalLsnByRegion = /* @__PURE__ */ new Map();
    for (const [regionId, highLocalLsn] of higherVersionSessionToken.localLsnByregion.entries()) {
      const lowLocalLsn = lowerVersionSessionToken.localLsnByregion.get(regionId);
      if (lowLocalLsn) {
        highestLocalLsnByRegion.set(regionId, max(highLocalLsn, lowLocalLsn));
      } else if (this.version === other.version) {
        throw new Error(`Compared session tokens have unexpected regions. Session 1: ${this.sessionToken} - Session 2: ${this.sessionToken}`);
      } else {
        highestLocalLsnByRegion.set(regionId, highLocalLsn);
      }
    }
    return new _VectorSessionToken(Math.max(this.version, other.version), Math.max(this.globalLsn, other.globalLsn), highestLocalLsnByRegion);
  }
  toString() {
    return this.sessionToken;
  }
  areRegionProgressEqual(other) {
    if (this.localLsnByregion.size !== other.size) {
      return false;
    }
    for (const [regionId, localLsn] of this.localLsnByregion.entries()) {
      const otherLocalLsn = other.get(regionId);
      if (localLsn !== otherLocalLsn) {
        return false;
      }
    }
    return true;
  }
};
VectorSessionToken.SEGMENT_SEPARATOR = "#";
VectorSessionToken.REGION_PROGRESS_SEPARATOR = "=";
function max(int1, int2) {
  if (int1.length === int2.length) {
    return int1 > int2 ? int1 : int2;
  } else if (int1.length > int2.length) {
    return int1;
  } else {
    return int2;
  }
}

// node_modules/@azure/cosmos/dist-esm/src/session/sessionContainer.js
var SessionContainer = class _SessionContainer {
  constructor(collectionNameToCollectionResourceId = /* @__PURE__ */ new Map(), collectionResourceIdToSessionTokens = /* @__PURE__ */ new Map()) {
    this.collectionNameToCollectionResourceId = collectionNameToCollectionResourceId;
    this.collectionResourceIdToSessionTokens = collectionResourceIdToSessionTokens;
  }
  get(request2) {
    if (!request2) {
      throw new Error("request cannot be null");
    }
    const collectionName = getContainerLink(trimSlashes(request2.resourceAddress));
    const rangeIdToTokenMap = this.getPartitionKeyRangeIdToTokenMap(collectionName);
    return _SessionContainer.getCombinedSessionTokenString(rangeIdToTokenMap);
  }
  remove(request2) {
    let collectionResourceId;
    const resourceAddress = trimSlashes(request2.resourceAddress);
    const collectionName = getContainerLink(resourceAddress);
    if (collectionName) {
      collectionResourceId = this.collectionNameToCollectionResourceId.get(collectionName);
      this.collectionNameToCollectionResourceId.delete(collectionName);
    }
    if (collectionResourceId !== void 0) {
      this.collectionResourceIdToSessionTokens.delete(collectionResourceId);
    }
  }
  set(request2, resHeaders) {
    if (!resHeaders || _SessionContainer.isReadingFromMaster(request2.resourceType, request2.operationType)) {
      return;
    }
    const sessionTokenString = resHeaders[Constants.HttpHeaders.SessionToken];
    if (!sessionTokenString) {
      return;
    }
    const containerName = this.getContainerName(request2, resHeaders);
    const ownerId = !request2.isNameBased ? request2.resourceId : resHeaders[Constants.HttpHeaders.OwnerId] || request2.resourceId;
    if (!ownerId) {
      return;
    }
    if (containerName && this.validateOwnerID(ownerId)) {
      if (!this.collectionResourceIdToSessionTokens.has(ownerId)) {
        this.collectionResourceIdToSessionTokens.set(ownerId, /* @__PURE__ */ new Map());
      }
      if (!this.collectionNameToCollectionResourceId.has(containerName)) {
        this.collectionNameToCollectionResourceId.set(containerName, ownerId);
      }
      const containerSessionContainer = this.collectionResourceIdToSessionTokens.get(ownerId);
      _SessionContainer.compareAndSetToken(sessionTokenString, containerSessionContainer);
    }
  }
  validateOwnerID(ownerId) {
    return atob_browser_default(ownerId.replace(/-/g, "/")).length === 8;
  }
  getPartitionKeyRangeIdToTokenMap(collectionName) {
    let rangeIdToTokenMap = null;
    if (collectionName && this.collectionNameToCollectionResourceId.has(collectionName)) {
      rangeIdToTokenMap = this.collectionResourceIdToSessionTokens.get(this.collectionNameToCollectionResourceId.get(collectionName));
    }
    return rangeIdToTokenMap;
  }
  static getCombinedSessionTokenString(tokens) {
    if (!tokens || tokens.size === 0) {
      return _SessionContainer.EMPTY_SESSION_TOKEN;
    }
    let result = "";
    for (const [range, token] of tokens.entries()) {
      result += range + _SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER + token.toString() + _SessionContainer.SESSION_TOKEN_SEPARATOR;
    }
    return result.slice(0, -1);
  }
  static compareAndSetToken(newTokenString, containerSessionTokens) {
    if (!newTokenString) {
      return;
    }
    const partitionsParts = newTokenString.split(_SessionContainer.SESSION_TOKEN_SEPARATOR);
    for (const partitionPart of partitionsParts) {
      const newTokenParts = partitionPart.split(_SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER);
      if (newTokenParts.length !== 2) {
        return;
      }
      const range = newTokenParts[0];
      const newToken = VectorSessionToken.create(newTokenParts[1]);
      const tokenForRange = !containerSessionTokens.get(range) ? newToken : containerSessionTokens.get(range).merge(newToken);
      containerSessionTokens.set(range, tokenForRange);
    }
  }
  // TODO: have a assert if the type doesn't mastch known types
  static isReadingFromMaster(resourceType, operationType) {
    if (resourceType === Constants.Path.OffersPathSegment || resourceType === Constants.Path.DatabasesPathSegment || resourceType === Constants.Path.UsersPathSegment || resourceType === Constants.Path.PermissionsPathSegment || resourceType === Constants.Path.TopologyPathSegment || resourceType === Constants.Path.DatabaseAccountPathSegment || resourceType === Constants.Path.PartitionKeyRangesPathSegment || resourceType === Constants.Path.CollectionsPathSegment && operationType === OperationType.Query) {
      return true;
    }
    return false;
  }
  getContainerName(request2, headers) {
    let ownerFullName = headers[Constants.HttpHeaders.OwnerFullName];
    if (!ownerFullName) {
      ownerFullName = trimSlashes(request2.resourceAddress);
    }
    return getContainerLink(ownerFullName);
  }
};
SessionContainer.EMPTY_SESSION_TOKEN = "";
SessionContainer.SESSION_TOKEN_SEPARATOR = ",";
SessionContainer.SESSION_TOKEN_PARTITION_SPLITTER = ":";

// node_modules/@azure/cosmos/dist-esm/src/utils/checkURL.js
function checkURL(testString) {
  return new URL(testString);
}
function sanitizeEndpoint(url) {
  return new URL(url).href.replace(/\/$/, "");
}

// node_modules/@azure/cosmos/dist-esm/src/diagnostics/DiagnosticWriter.js
var LogDiagnosticWriter = class {
  constructor() {
    this.logger = createClientLogger("CosmosDBDiagnostics");
  }
  async write(diagnosticsData) {
    this.logger.verbose(diagnosticsData);
  }
};
var NoOpDiagnosticWriter = class {
  async write(_diagnosticsData) {
  }
};

// node_modules/@azure/cosmos/dist-esm/src/diagnostics/DiagnosticFormatter.js
var DefaultDiagnosticFormatter = class {
  format(cosmosDiagnostic) {
    return JSON.stringify(cosmosDiagnostic);
  }
};

// node_modules/@azure/cosmos/dist-esm/src/ClientContext.js
var uuid3 = v4_default;
var logger5 = createClientLogger("ClientContext");
var QueryJsonContentType = "application/query+json";
var HttpHeaders = Constants.HttpHeaders;
var ClientContext = class {
  constructor(cosmosClientOptions, globalEndpointManager, clientConfig, diagnosticLevel) {
    this.cosmosClientOptions = cosmosClientOptions;
    this.globalEndpointManager = globalEndpointManager;
    this.clientConfig = clientConfig;
    this.diagnosticLevel = diagnosticLevel;
    this.connectionPolicy = cosmosClientOptions.connectionPolicy;
    this.sessionContainer = new SessionContainer();
    this.partitionKeyDefinitionCache = {};
    this.pipeline = null;
    if (cosmosClientOptions.aadCredentials) {
      this.pipeline = createEmptyPipeline();
      const hrefEndpoint = sanitizeEndpoint(cosmosClientOptions.endpoint);
      const scope = `${hrefEndpoint}/.default`;
      this.pipeline.addPolicy(bearerTokenAuthenticationPolicy({
        credential: cosmosClientOptions.aadCredentials,
        scopes: scope,
        challengeCallbacks: {
          async authorizeRequest({ request: request2, getAccessToken }) {
            const tokenResponse = await getAccessToken([scope], {});
            const AUTH_PREFIX = `type=aad&ver=1.0&sig=`;
            const authorizationToken = `${AUTH_PREFIX}${tokenResponse.token}`;
            request2.headers.set("Authorization", authorizationToken);
          }
        }
      }));
    }
    this.initializeDiagnosticSettings(diagnosticLevel);
  }
  /** @hidden */
  async read({ path, resourceType, resourceId, options = {}, partitionKey, diagnosticNode }) {
    try {
      const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {
        method: HTTPMethod.get,
        path,
        operationType: OperationType.Read,
        resourceId,
        options,
        resourceType,
        partitionKey
      });
      diagnosticNode.addData({
        operationType: OperationType.Read,
        resourceType
      });
      request2.headers = await this.buildHeaders(request2);
      this.applySessionToken(request2);
      request2.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request2.resourceType, request2.operationType);
      const response = await executePlugins(diagnosticNode, request2, RequestHandler.request, PluginOn.operation);
      this.captureSessionToken(void 0, path, OperationType.Read, response.headers);
      return response;
    } catch (err) {
      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);
      throw err;
    }
  }
  async queryFeed({ path, resourceType, resourceId, resultFn, query, options, diagnosticNode, partitionKeyRangeId, partitionKey, startEpk, endEpk }) {
    const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {
      method: HTTPMethod.get,
      path,
      operationType: OperationType.Query,
      partitionKeyRangeId,
      resourceId,
      resourceType,
      options,
      body: query,
      partitionKey
    });
    diagnosticNode.addData({
      operationType: OperationType.Query,
      resourceType
    });
    const requestId = uuid3();
    if (query !== void 0) {
      request2.method = HTTPMethod.post;
    }
    request2.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request2.resourceType, request2.operationType);
    request2.headers = await this.buildHeaders(request2);
    if (startEpk !== void 0 && endEpk !== void 0) {
      request2.headers[HttpHeaders.StartEpk] = startEpk;
      request2.headers[HttpHeaders.EndEpk] = endEpk;
      request2.headers[HttpHeaders.ReadFeedKeyType] = "EffectivePartitionKeyRange";
    }
    if (query !== void 0) {
      request2.headers[HttpHeaders.IsQuery] = "true";
      request2.headers[HttpHeaders.ContentType] = QueryJsonContentType;
      if (typeof query === "string") {
        request2.body = { query };
      }
    }
    this.applySessionToken(request2);
    logger5.info("query " + requestId + " started" + (request2.partitionKeyRangeId ? " pkrid: " + request2.partitionKeyRangeId : ""));
    logger5.verbose(request2);
    const start = Date.now();
    const response = await RequestHandler.request(request2, diagnosticNode);
    logger5.info("query " + requestId + " finished - " + (Date.now() - start) + "ms");
    this.captureSessionToken(void 0, path, OperationType.Query, response.headers);
    return this.processQueryFeedResponse(response, !!query, resultFn);
  }
  async getQueryPlan(path, resourceType, resourceId, query, options = {}, diagnosticNode) {
    const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {
      method: HTTPMethod.post,
      path,
      operationType: OperationType.Read,
      resourceId,
      resourceType,
      options,
      body: query
    });
    diagnosticNode.addData({
      operationType: OperationType.Read,
      resourceType
    });
    request2.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request2.resourceType, request2.operationType);
    request2.headers = await this.buildHeaders(request2);
    request2.headers[HttpHeaders.IsQueryPlan] = "True";
    request2.headers[HttpHeaders.QueryVersion] = "1.4";
    request2.headers[HttpHeaders.SupportedQueryFeatures] = "NonValueAggregate, Aggregate, Distinct, MultipleOrderBy, OffsetAndLimit, OrderBy, Top, CompositeAggregate, GroupBy, MultipleAggregates";
    request2.headers[HttpHeaders.ContentType] = QueryJsonContentType;
    if (typeof query === "string") {
      request2.body = { query };
    }
    this.applySessionToken(request2);
    const response = await RequestHandler.request(request2, diagnosticNode);
    this.captureSessionToken(void 0, path, OperationType.Query, response.headers);
    return response;
  }
  queryPartitionKeyRanges(collectionLink, query, options) {
    const path = getPathFromLink(collectionLink, ResourceType.pkranges);
    const id = getIdFromLink(collectionLink);
    const cb = async (diagNode, innerOptions) => {
      const response = await this.queryFeed({
        path,
        resourceType: ResourceType.pkranges,
        resourceId: id,
        resultFn: (result) => result.PartitionKeyRanges,
        query,
        options: innerOptions,
        diagnosticNode: diagNode
      });
      return response;
    };
    return new QueryIterator(this, query, options, cb);
  }
  async delete({ path, resourceType, resourceId, options = {}, partitionKey, method = HTTPMethod.delete, diagnosticNode }) {
    try {
      const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {
        method,
        operationType: OperationType.Delete,
        path,
        resourceType,
        options,
        resourceId,
        partitionKey
      });
      diagnosticNode.addData({
        operationType: OperationType.Delete,
        resourceType
      });
      request2.headers = await this.buildHeaders(request2);
      this.applySessionToken(request2);
      request2.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request2.resourceType, request2.operationType);
      const response = await executePlugins(diagnosticNode, request2, RequestHandler.request, PluginOn.operation);
      if (parseLink(path).type !== "colls") {
        this.captureSessionToken(void 0, path, OperationType.Delete, response.headers);
      } else {
        this.clearSessionToken(path);
      }
      return response;
    } catch (err) {
      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);
      throw err;
    }
  }
  async patch({ body, path, resourceType, resourceId, options = {}, partitionKey, diagnosticNode }) {
    try {
      const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {
        method: HTTPMethod.patch,
        operationType: OperationType.Patch,
        path,
        resourceType,
        body,
        resourceId,
        options,
        partitionKey
      });
      diagnosticNode.addData({
        operationType: OperationType.Patch,
        resourceType
      });
      request2.headers = await this.buildHeaders(request2);
      this.applySessionToken(request2);
      request2.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request2.resourceType, request2.operationType);
      const response = await executePlugins(diagnosticNode, request2, RequestHandler.request, PluginOn.operation);
      this.captureSessionToken(void 0, path, OperationType.Patch, response.headers);
      return response;
    } catch (err) {
      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);
      throw err;
    }
  }
  async create({ body, path, resourceType, resourceId, diagnosticNode, options = {}, partitionKey }) {
    try {
      const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {
        method: HTTPMethod.post,
        operationType: OperationType.Create,
        path,
        resourceType,
        resourceId,
        body,
        options,
        partitionKey
      });
      diagnosticNode.addData({
        operationType: OperationType.Create,
        resourceType
      });
      request2.headers = await this.buildHeaders(request2);
      this.applySessionToken(request2);
      request2.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request2.resourceType, request2.operationType);
      const response = await executePlugins(diagnosticNode, request2, RequestHandler.request, PluginOn.operation);
      this.captureSessionToken(void 0, path, OperationType.Create, response.headers);
      return response;
    } catch (err) {
      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);
      throw err;
    }
  }
  processQueryFeedResponse(res, isQuery, resultFn) {
    if (isQuery) {
      return {
        result: resultFn(res.result),
        headers: res.headers,
        code: res.code
      };
    } else {
      const newResult = resultFn(res.result).map((body) => body);
      return {
        result: newResult,
        headers: res.headers,
        code: res.code
      };
    }
  }
  applySessionToken(requestContext) {
    const request2 = this.getSessionParams(requestContext.path);
    if (requestContext.headers && requestContext.headers[HttpHeaders.SessionToken]) {
      return;
    }
    const sessionConsistency = requestContext.headers[HttpHeaders.ConsistencyLevel];
    if (!sessionConsistency) {
      return;
    }
    if (sessionConsistency !== ConsistencyLevel.Session) {
      return;
    }
    if (request2.resourceAddress) {
      const sessionToken = this.sessionContainer.get(request2);
      if (sessionToken) {
        requestContext.headers[HttpHeaders.SessionToken] = sessionToken;
      }
    }
  }
  async replace({ body, path, resourceType, resourceId, options = {}, partitionKey, diagnosticNode }) {
    try {
      const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {
        method: HTTPMethod.put,
        operationType: OperationType.Replace,
        path,
        resourceType,
        body,
        resourceId,
        options,
        partitionKey
      });
      diagnosticNode.addData({
        operationType: OperationType.Replace,
        resourceType
      });
      request2.headers = await this.buildHeaders(request2);
      this.applySessionToken(request2);
      request2.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request2.resourceType, request2.operationType);
      const response = await executePlugins(diagnosticNode, request2, RequestHandler.request, PluginOn.operation);
      this.captureSessionToken(void 0, path, OperationType.Replace, response.headers);
      return response;
    } catch (err) {
      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);
      throw err;
    }
  }
  async upsert({ body, path, resourceType, resourceId, options = {}, partitionKey, diagnosticNode }) {
    try {
      const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {
        method: HTTPMethod.post,
        operationType: OperationType.Upsert,
        path,
        resourceType,
        body,
        resourceId,
        options,
        partitionKey
      });
      diagnosticNode.addData({
        operationType: OperationType.Upsert,
        resourceType
      });
      request2.headers = await this.buildHeaders(request2);
      request2.headers[HttpHeaders.IsUpsert] = true;
      this.applySessionToken(request2);
      request2.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request2.resourceType, request2.operationType);
      const response = await executePlugins(diagnosticNode, request2, RequestHandler.request, PluginOn.operation);
      this.captureSessionToken(void 0, path, OperationType.Upsert, response.headers);
      return response;
    } catch (err) {
      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);
      throw err;
    }
  }
  async execute({ sprocLink, params, options = {}, partitionKey, diagnosticNode }) {
    if (params !== null && params !== void 0 && !Array.isArray(params)) {
      params = [params];
    }
    const path = getPathFromLink(sprocLink);
    const id = getIdFromLink(sprocLink);
    const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), { method: HTTPMethod.post, operationType: OperationType.Execute, path, resourceType: ResourceType.sproc, options, resourceId: id, body: params, partitionKey });
    diagnosticNode.addData({
      operationType: OperationType.Execute,
      resourceType: ResourceType.sproc
    });
    request2.headers = await this.buildHeaders(request2);
    request2.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request2.resourceType, request2.operationType);
    const response = await executePlugins(diagnosticNode, request2, RequestHandler.request, PluginOn.operation);
    return response;
  }
  /**
   * Gets the Database account information.
   * @param options - `urlConnection` in the options is the endpoint url whose database account needs to be retrieved.
   * If not present, current client's url will be used.
   */
  async getDatabaseAccount(diagnosticNode, options = {}) {
    const endpoint = options.urlConnection || this.cosmosClientOptions.endpoint;
    const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), { endpoint, method: HTTPMethod.get, operationType: OperationType.Read, path: "", resourceType: ResourceType.none, options });
    diagnosticNode.addData({
      operationType: OperationType.Read,
      resourceType: ResourceType.none
    });
    request2.headers = await this.buildHeaders(request2);
    const { result, headers, code, substatus, diagnostics } = await executePlugins(diagnosticNode, request2, RequestHandler.request, PluginOn.operation);
    const databaseAccount = new DatabaseAccount(result, headers);
    return {
      result: databaseAccount,
      headers,
      diagnostics,
      code,
      substatus
    };
  }
  getWriteEndpoint(diagnosticNode) {
    return this.globalEndpointManager.getWriteEndpoint(diagnosticNode);
  }
  getReadEndpoint(diagnosticNode) {
    return this.globalEndpointManager.getReadEndpoint(diagnosticNode);
  }
  getWriteEndpoints() {
    return this.globalEndpointManager.getWriteEndpoints();
  }
  getReadEndpoints() {
    return this.globalEndpointManager.getReadEndpoints();
  }
  async batch({ body, path, partitionKey, resourceId, options = {}, diagnosticNode }) {
    try {
      const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {
        method: HTTPMethod.post,
        operationType: OperationType.Batch,
        path,
        body,
        resourceType: ResourceType.item,
        resourceId,
        options,
        partitionKey
      });
      diagnosticNode.addData({
        operationType: OperationType.Batch,
        resourceType: ResourceType.item
      });
      request2.headers = await this.buildHeaders(request2);
      request2.headers[HttpHeaders.IsBatchRequest] = true;
      request2.headers[HttpHeaders.IsBatchAtomic] = true;
      this.applySessionToken(request2);
      request2.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request2.resourceType, request2.operationType);
      const response = await executePlugins(diagnosticNode, request2, RequestHandler.request, PluginOn.operation);
      this.captureSessionToken(void 0, path, OperationType.Batch, response.headers);
      response.diagnostics = diagnosticNode.toDiagnostic(this.getClientConfig());
      return response;
    } catch (err) {
      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);
      throw err;
    }
  }
  async bulk({ body, path, partitionKeyRangeId, resourceId, bulkOptions = {}, options = {}, diagnosticNode }) {
    try {
      const request2 = Object.assign(Object.assign({}, this.getContextDerivedPropsForRequestCreation()), {
        method: HTTPMethod.post,
        operationType: OperationType.Batch,
        path,
        body,
        resourceType: ResourceType.item,
        resourceId,
        options
      });
      diagnosticNode.addData({
        operationType: OperationType.Batch,
        resourceType: ResourceType.item
      });
      request2.headers = await this.buildHeaders(request2);
      request2.headers[HttpHeaders.IsBatchRequest] = true;
      request2.headers[HttpHeaders.PartitionKeyRangeID] = partitionKeyRangeId;
      request2.headers[HttpHeaders.IsBatchAtomic] = false;
      request2.headers[HttpHeaders.BatchContinueOnError] = bulkOptions.continueOnError || false;
      this.applySessionToken(request2);
      request2.endpoint = await this.globalEndpointManager.resolveServiceEndpoint(diagnosticNode, request2.resourceType, request2.operationType);
      const response = await executePlugins(diagnosticNode, request2, RequestHandler.request, PluginOn.operation);
      this.captureSessionToken(void 0, path, OperationType.Batch, response.headers);
      return response;
    } catch (err) {
      this.captureSessionToken(err, path, OperationType.Upsert, err.headers);
      throw err;
    }
  }
  captureSessionToken(err, path, operationType, resHeaders) {
    const request2 = this.getSessionParams(path);
    request2.operationType = operationType;
    if (!err || !this.isMasterResource(request2.resourceType) && (err.code === StatusCodes.PreconditionFailed || err.code === StatusCodes.Conflict || err.code === StatusCodes.NotFound && err.substatus !== SubStatusCodes.ReadSessionNotAvailable)) {
      this.sessionContainer.set(request2, resHeaders);
    }
  }
  clearSessionToken(path) {
    const request2 = this.getSessionParams(path);
    this.sessionContainer.remove(request2);
  }
  recordDiagnostics(diagnostic) {
    const formatted = this.diagnosticFormatter.format(diagnostic);
    this.diagnosticWriter.write(formatted);
  }
  initializeDiagnosticSettings(diagnosticLevel) {
    this.diagnosticFormatter = new DefaultDiagnosticFormatter();
    switch (diagnosticLevel) {
      case CosmosDbDiagnosticLevel.info:
        this.diagnosticWriter = new NoOpDiagnosticWriter();
        break;
      default:
        this.diagnosticWriter = new LogDiagnosticWriter();
    }
  }
  // TODO: move
  getSessionParams(resourceLink) {
    const resourceId = null;
    let resourceAddress = null;
    const parserOutput = parseLink(resourceLink);
    resourceAddress = parserOutput.objectBody.self;
    const resourceType = parserOutput.type;
    return {
      resourceId,
      resourceAddress,
      resourceType,
      isNameBased: true
    };
  }
  isMasterResource(resourceType) {
    if (resourceType === Constants.Path.OffersPathSegment || resourceType === Constants.Path.DatabasesPathSegment || resourceType === Constants.Path.UsersPathSegment || resourceType === Constants.Path.PermissionsPathSegment || resourceType === Constants.Path.TopologyPathSegment || resourceType === Constants.Path.DatabaseAccountPathSegment || resourceType === Constants.Path.PartitionKeyRangesPathSegment || resourceType === Constants.Path.CollectionsPathSegment) {
      return true;
    }
    return false;
  }
  buildHeaders(requestContext) {
    return getHeaders({
      clientOptions: this.cosmosClientOptions,
      defaultHeaders: Object.assign(Object.assign({}, this.cosmosClientOptions.defaultHeaders), requestContext.options.initialHeaders),
      verb: requestContext.method,
      path: requestContext.path,
      resourceId: requestContext.resourceId,
      resourceType: requestContext.resourceType,
      options: requestContext.options,
      partitionKeyRangeId: requestContext.partitionKeyRangeId,
      useMultipleWriteLocations: this.connectionPolicy.useMultipleWriteLocations,
      partitionKey: requestContext.partitionKey !== void 0 ? convertToInternalPartitionKey(requestContext.partitionKey) : void 0
      // TODO: Move this check from here to PartitionKey
    });
  }
  /**
   * Returns collection of properties which are derived from the context for Request Creation.
   * These properties have client wide scope, as opposed to request specific scope.
   * @returns
   */
  getContextDerivedPropsForRequestCreation() {
    return {
      globalEndpointManager: this.globalEndpointManager,
      requestAgent: this.cosmosClientOptions.agent,
      connectionPolicy: this.connectionPolicy,
      client: this,
      plugins: this.cosmosClientOptions.plugins,
      pipeline: this.pipeline
    };
  }
  getClientConfig() {
    return this.clientConfig;
  }
};

// node_modules/universal-user-agent/dist-web/index.js
function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }
  if (typeof process === "object" && process.version !== void 0) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }
  return "<environment undetectable>";
}

// node_modules/@azure/cosmos/dist-esm/src/common/platform.js
function getUserAgent2(suffix) {
  const ua = `${getUserAgent()} ${Constants.SDKName}/${Constants.SDKVersion}`;
  if (suffix) {
    return ua + " " + suffix;
  }
  return ua;
}

// node_modules/@azure/cosmos/dist-esm/src/utils/strings.js
function isNonEmptyString(variable) {
  return typeof variable === "string" && variable.trim().length > 0;
}

// node_modules/@azure/cosmos/dist-esm/src/diagnostics/index.js
var DefaultDiagnosticLevelValue = CosmosDbDiagnosticLevel.info;
var diagnosticLevelFromEnv = typeof process !== "undefined" && process.env && process.env[Constants.CosmosDbDiagnosticLevelEnvVarName] || void 0;
var acceptableDiagnosticLevelValues = Object.values(CosmosDbDiagnosticLevel).map((x) => x.toString());
var cosmosDiagnosticLevel;
if (isNonEmptyString(diagnosticLevelFromEnv)) {
  if (isCosmosDiagnosticLevel(diagnosticLevelFromEnv)) {
    setDiagnosticLevel(diagnosticLevelFromEnv);
  } else {
    console.error(`${Constants.CosmosDbDiagnosticLevelEnvVarName} set to unknown diagnostic level '${diagnosticLevelFromEnv}'; Setting Cosmos Db diagnostic level to info. Acceptable values: ${acceptableDiagnosticLevelValues.join(", ")}.`);
  }
}
function setDiagnosticLevel(level) {
  if (level && !isCosmosDiagnosticLevel(level)) {
    throw new Error(`Unknown diagnostic level '${level}'. Acceptable values: ${acceptableDiagnosticLevelValues.join(",")}`);
  }
  cosmosDiagnosticLevel = level;
}
function getDiagnosticLevelFromEnvironment() {
  return cosmosDiagnosticLevel;
}
function isCosmosDiagnosticLevel(diagnosticLevel) {
  return acceptableDiagnosticLevelValues.includes(diagnosticLevel);
}
function determineDiagnosticLevel(diagnosticLevelFromClientConfig, diagnosticLevelFromEnvironment) {
  const diagnosticLevelFromEnvOrClient = diagnosticLevelFromEnvironment !== null && diagnosticLevelFromEnvironment !== void 0 ? diagnosticLevelFromEnvironment : diagnosticLevelFromClientConfig;
  return diagnosticLevelFromEnvOrClient !== null && diagnosticLevelFromEnvOrClient !== void 0 ? diagnosticLevelFromEnvOrClient : DefaultDiagnosticLevelValue;
}

// node_modules/@azure/cosmos/dist-esm/src/globalEndpointManager.js
var GlobalEndpointManager = class _GlobalEndpointManager {
  /**
   * @param options - The document client instance.
   * @internal
   */
  constructor(options, readDatabaseAccount) {
    this.readDatabaseAccount = readDatabaseAccount;
    this.writeableLocations = [];
    this.readableLocations = [];
    this.unavailableReadableLocations = [];
    this.unavailableWriteableLocations = [];
    this.options = options;
    this.defaultEndpoint = options.endpoint;
    this.enableEndpointDiscovery = options.connectionPolicy.enableEndpointDiscovery;
    this.isRefreshing = false;
    this.preferredLocations = this.options.connectionPolicy.preferredLocations;
    this.preferredLocationsCount = this.preferredLocations ? this.preferredLocations.length : 0;
  }
  /**
   * Gets the current read endpoint from the endpoint cache.
   */
  async getReadEndpoint(diagnosticNode) {
    return this.resolveServiceEndpoint(diagnosticNode, ResourceType.item, OperationType.Read);
  }
  /**
   * Gets the current write endpoint from the endpoint cache.
   */
  async getWriteEndpoint(diagnosticNode) {
    return this.resolveServiceEndpoint(diagnosticNode, ResourceType.item, OperationType.Replace);
  }
  async getReadEndpoints() {
    return this.readableLocations.map((loc) => loc.databaseAccountEndpoint);
  }
  async getWriteEndpoints() {
    return this.writeableLocations.map((loc) => loc.databaseAccountEndpoint);
  }
  async markCurrentLocationUnavailableForRead(diagnosticNode, endpoint) {
    await this.refreshEndpointList(diagnosticNode);
    const location = this.readableLocations.find((loc) => loc.databaseAccountEndpoint === endpoint);
    if (location) {
      location.unavailable = true;
      location.lastUnavailabilityTimestampInMs = Date.now();
      this.unavailableReadableLocations.push(location);
    }
  }
  async markCurrentLocationUnavailableForWrite(diagnosticNode, endpoint) {
    await this.refreshEndpointList(diagnosticNode);
    const location = this.writeableLocations.find((loc) => loc.databaseAccountEndpoint === endpoint);
    if (location) {
      location.unavailable = true;
      location.lastUnavailabilityTimestampInMs = Date.now();
      this.unavailableWriteableLocations.push(location);
    }
  }
  canUseMultipleWriteLocations(resourceType, operationType) {
    let canUse = this.options.connectionPolicy.useMultipleWriteLocations;
    if (resourceType) {
      canUse = canUse && (resourceType === ResourceType.item || resourceType === ResourceType.sproc && operationType === OperationType.Execute);
    }
    return canUse;
  }
  async resolveServiceEndpoint(diagnosticNode, resourceType, operationType, startServiceEndpointIndex = 0) {
    if (!this.options.connectionPolicy.enableEndpointDiscovery) {
      diagnosticNode.addData({ readFromCache: true }, "default_endpoint");
      diagnosticNode.recordEndpointResolution(this.defaultEndpoint);
      return this.defaultEndpoint;
    }
    if (resourceType === ResourceType.none) {
      diagnosticNode.addData({ readFromCache: true }, "none_resource");
      diagnosticNode.recordEndpointResolution(this.defaultEndpoint);
      return this.defaultEndpoint;
    }
    if (this.readableLocations.length === 0 || this.writeableLocations.length === 0) {
      const resourceResponse = await withMetadataDiagnostics(async (metadataNode) => {
        return this.readDatabaseAccount(metadataNode, {
          urlConnection: this.defaultEndpoint
        });
      }, diagnosticNode, MetadataLookUpType.DatabaseAccountLookUp);
      this.writeableLocations = resourceResponse.resource.writableLocations;
      this.readableLocations = resourceResponse.resource.readableLocations;
    }
    const locations = isReadRequest(operationType) ? this.readableLocations : this.writeableLocations;
    let location;
    if (this.preferredLocations && this.preferredLocations.length > 0 && startServiceEndpointIndex < this.preferredLocations.length) {
      for (let i = startServiceEndpointIndex; i < this.preferredLocations.length; i++) {
        const preferredLocation = this.preferredLocations[i];
        location = locations.find((loc) => loc.unavailable !== true && normalizeEndpoint(loc.name) === normalizeEndpoint(preferredLocation));
        if (location) {
          break;
        }
      }
    }
    if (!location) {
      const startIndexValid = startServiceEndpointIndex >= 0 && startServiceEndpointIndex < locations.length;
      const locationsToSearch = startIndexValid ? locations.slice(startServiceEndpointIndex) : locations;
      location = locationsToSearch.find((loc) => {
        return loc.unavailable !== true;
      });
    }
    location = location ? location : { name: "", databaseAccountEndpoint: this.defaultEndpoint };
    diagnosticNode.recordEndpointResolution(location.databaseAccountEndpoint);
    return location.databaseAccountEndpoint;
  }
  /**
   * Refreshes the endpoint list by clearning stale unavailability and then
   *  retrieving the writable and readable locations from the geo-replicated database account
   *  and then updating the locations cache.
   *  We skip the refreshing if enableEndpointDiscovery is set to False
   */
  async refreshEndpointList(diagnosticNode) {
    if (!this.isRefreshing && this.enableEndpointDiscovery) {
      this.isRefreshing = true;
      const databaseAccount = await this.getDatabaseAccountFromAnyEndpoint(diagnosticNode);
      if (databaseAccount) {
        this.refreshStaleUnavailableLocations();
        this.refreshEndpoints(databaseAccount);
      }
      this.isRefreshing = false;
    }
  }
  refreshEndpoints(databaseAccount) {
    for (const location of databaseAccount.writableLocations) {
      const existingLocation = this.writeableLocations.find((loc) => loc.name === location.name);
      if (!existingLocation) {
        this.writeableLocations.push(location);
      }
    }
    for (const location of databaseAccount.readableLocations) {
      const existingLocation = this.readableLocations.find((loc) => loc.name === location.name);
      if (!existingLocation) {
        this.readableLocations.push(location);
      }
    }
  }
  refreshStaleUnavailableLocations() {
    const now = Date.now();
    this.updateLocation(now, this.unavailableReadableLocations, this.readableLocations);
    this.unavailableReadableLocations = this.cleanUnavailableLocationList(now, this.unavailableReadableLocations);
    this.updateLocation(now, this.unavailableWriteableLocations, this.writeableLocations);
    this.unavailableWriteableLocations = this.cleanUnavailableLocationList(now, this.unavailableWriteableLocations);
  }
  /**
   * update the locationUnavailability to undefined if the location is available again
   * @param now - current time
   * @param unavailableLocations - list of unavailable locations
   * @param allLocations - list of all locations
   */
  updateLocation(now, unavailableLocations, allLocations) {
    for (const location of unavailableLocations) {
      const unavaialableLocation = allLocations.find((loc) => loc.name === location.name);
      if (unavaialableLocation && now - unavaialableLocation.lastUnavailabilityTimestampInMs > Constants.LocationUnavailableExpirationTimeInMs) {
        unavaialableLocation.unavailable = false;
      }
    }
  }
  cleanUnavailableLocationList(now, unavailableLocations) {
    return unavailableLocations.filter((loc) => {
      if (loc && now - loc.lastUnavailabilityTimestampInMs >= Constants.LocationUnavailableExpirationTimeInMs) {
        return false;
      }
      return true;
    });
  }
  /**
   * Gets the database account first by using the default endpoint, and if that doesn't returns
   * use the endpoints for the preferred locations in the order they are specified to get
   * the database account.
   */
  async getDatabaseAccountFromAnyEndpoint(diagnosticNode) {
    try {
      const options = { urlConnection: this.defaultEndpoint };
      const { resource: databaseAccount } = await this.readDatabaseAccount(diagnosticNode, options);
      return databaseAccount;
    } catch (err) {
    }
    if (this.preferredLocations) {
      for (const location of this.preferredLocations) {
        try {
          const locationalEndpoint = _GlobalEndpointManager.getLocationalEndpoint(this.defaultEndpoint, location);
          const options = { urlConnection: locationalEndpoint };
          const { resource: databaseAccount } = await this.readDatabaseAccount(diagnosticNode, options);
          if (databaseAccount) {
            return databaseAccount;
          }
        } catch (err) {
        }
      }
    }
  }
  /**
   * Gets the locational endpoint using the location name passed to it using the default endpoint.
   *
   * @param defaultEndpoint - The default endpoint to use for the endpoint.
   * @param locationName    - The location name for the azure region like "East US".
   */
  static getLocationalEndpoint(defaultEndpoint, locationName) {
    const endpointUrl = new URL(defaultEndpoint);
    if (endpointUrl.hostname) {
      const hostnameParts = endpointUrl.hostname.toString().toLowerCase().split(".");
      if (hostnameParts) {
        const globalDatabaseAccountName = hostnameParts[0];
        const locationalDatabaseAccountName = globalDatabaseAccountName + "-" + locationName.replace(" ", "");
        const locationalEndpoint = defaultEndpoint.toLowerCase().replace(globalDatabaseAccountName, locationalDatabaseAccountName);
        return locationalEndpoint;
      }
    }
    return null;
  }
};
function normalizeEndpoint(endpoint) {
  return endpoint.split(" ").join("").toLowerCase();
}

// node_modules/@azure/cosmos/dist-esm/src/CosmosClient.js
var CosmosClient = class {
  constructor(optionsOrConnectionString) {
    var _a, _b;
    if (typeof optionsOrConnectionString === "string") {
      optionsOrConnectionString = parseConnectionString(optionsOrConnectionString);
    }
    const endpoint = checkURL(optionsOrConnectionString.endpoint);
    if (!endpoint) {
      throw new Error("Invalid endpoint specified");
    }
    const clientConfig = this.initializeClientConfigDiagnostic(optionsOrConnectionString);
    optionsOrConnectionString.connectionPolicy = Object.assign({}, defaultConnectionPolicy, optionsOrConnectionString.connectionPolicy);
    optionsOrConnectionString.defaultHeaders = optionsOrConnectionString.defaultHeaders || {};
    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.CacheControl] = "no-cache";
    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.Version] = Constants.CurrentVersion;
    if (optionsOrConnectionString.consistencyLevel !== void 0) {
      optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.ConsistencyLevel] = optionsOrConnectionString.consistencyLevel;
    }
    optionsOrConnectionString.defaultHeaders[Constants.HttpHeaders.UserAgent] = getUserAgent2(optionsOrConnectionString.userAgentSuffix);
    const globalEndpointManager = new GlobalEndpointManager(optionsOrConnectionString, async (diagnosticNode, opts) => this.getDatabaseAccountInternal(diagnosticNode, opts));
    this.clientContext = new ClientContext(optionsOrConnectionString, globalEndpointManager, clientConfig, determineDiagnosticLevel(optionsOrConnectionString.diagnosticLevel, getDiagnosticLevelFromEnvironment()));
    if (((_a = optionsOrConnectionString.connectionPolicy) === null || _a === void 0 ? void 0 : _a.enableEndpointDiscovery) && ((_b = optionsOrConnectionString.connectionPolicy) === null || _b === void 0 ? void 0 : _b.enableBackgroundEndpointRefreshing)) {
      this.backgroundRefreshEndpointList(globalEndpointManager, optionsOrConnectionString.connectionPolicy.endpointRefreshRateInMs || defaultConnectionPolicy.endpointRefreshRateInMs);
    }
    this.databases = new Databases(this, this.clientContext);
    this.offers = new Offers(this, this.clientContext);
  }
  initializeClientConfigDiagnostic(optionsOrConnectionString) {
    return {
      endpoint: optionsOrConnectionString.endpoint,
      resourceTokensConfigured: optionsOrConnectionString.resourceTokens !== void 0,
      tokenProviderConfigured: optionsOrConnectionString.tokenProvider !== void 0,
      aadCredentialsConfigured: optionsOrConnectionString.aadCredentials !== void 0,
      connectionPolicyConfigured: optionsOrConnectionString.connectionPolicy !== void 0,
      consistencyLevel: optionsOrConnectionString.consistencyLevel,
      defaultHeaders: optionsOrConnectionString.defaultHeaders,
      agentConfigured: optionsOrConnectionString.agent !== void 0,
      userAgentSuffix: optionsOrConnectionString.userAgentSuffix,
      diagnosticLevel: optionsOrConnectionString.diagnosticLevel,
      pluginsConfigured: optionsOrConnectionString.plugins !== void 0,
      sDKVersion: Constants.SDKVersion
    };
  }
  /**
   * Get information about the current {@link DatabaseAccount} (including which regions are supported, etc.)
   */
  async getDatabaseAccount(options) {
    return withDiagnostics(async (diagnosticNode) => {
      return this.getDatabaseAccountInternal(diagnosticNode, options);
    }, this.clientContext);
  }
  /**
   * @hidden
   */
  async getDatabaseAccountInternal(diagnosticNode, options) {
    const response = await this.clientContext.getDatabaseAccount(diagnosticNode, options);
    return new ResourceResponse(response.result, response.headers, response.code, getEmptyCosmosDiagnostics(), response.substatus);
  }
  /**
   * Gets the currently used write endpoint url. Useful for troubleshooting purposes.
   *
   * The url may contain a region suffix (e.g. "-eastus") if we're using location specific endpoints.
   */
  async getWriteEndpoint() {
    return withDiagnostics(async (diagnosticNode) => {
      return this.clientContext.getWriteEndpoint(diagnosticNode);
    }, this.clientContext);
  }
  /**
   * Gets the currently used read endpoint. Useful for troubleshooting purposes.
   *
   * The url may contain a region suffix (e.g. "-eastus") if we're using location specific endpoints.
   */
  async getReadEndpoint() {
    return withDiagnostics(async (diagnosticNode) => {
      return this.clientContext.getReadEndpoint(diagnosticNode);
    }, this.clientContext);
  }
  /**
   * Gets the known write endpoints. Useful for troubleshooting purposes.
   *
   * The urls may contain a region suffix (e.g. "-eastus") if we're using location specific endpoints.
   */
  getWriteEndpoints() {
    return this.clientContext.getWriteEndpoints();
  }
  /**
   * Gets the currently used read endpoint. Useful for troubleshooting purposes.
   *
   * The url may contain a region suffix (e.g. "-eastus") if we're using location specific endpoints.
   */
  getReadEndpoints() {
    return this.clientContext.getReadEndpoints();
  }
  /**
   * Used for reading, updating, or deleting a existing database by id or accessing containers belonging to that database.
   *
   * This does not make a network call. Use `.read` to get info about the database after getting the {@link Database} object.
   *
   * @param id - The id of the database.
   * @example Create a new container off of an existing database
   * ```typescript
   * const container = client.database("<database id>").containers.create("<container id>");
   * ```
   *
   * @example Delete an existing database
   * ```typescript
   * await client.database("<id here>").delete();
   * ```
   */
  database(id) {
    return new Database(this, id, this.clientContext);
  }
  /**
   * Used for reading, or updating a existing offer by id.
   * @param id - The id of the offer.
   */
  offer(id) {
    return new Offer(this, id, this.clientContext);
  }
  /**
   * Clears background endpoint refresher. Use client.dispose() when destroying the CosmosClient within another process.
   */
  dispose() {
    clearTimeout(this.endpointRefresher);
  }
  async backgroundRefreshEndpointList(globalEndpointManager, refreshRate) {
    this.endpointRefresher = setInterval(() => {
      try {
        return withDiagnostics(async (diagnosticNode) => {
          return globalEndpointManager.refreshEndpointList(diagnosticNode);
        }, this.clientContext, DiagnosticNodeType.BACKGROUND_REFRESH_THREAD);
      } catch (e) {
        console.warn("Failed to refresh endpoints", e);
      }
    }, refreshRate);
    if (this.endpointRefresher.unref && typeof this.endpointRefresher.unref === "function") {
      this.endpointRefresher.unref();
    }
  }
};

// node_modules/@azure/cosmos/dist-esm/src/client/SasToken/SasTokenProperties.js
var SasTokenProperties = class {
};

// node_modules/@azure/cosmos/dist-esm/src/utils/SasToken.js
async function createAuthorizationSasToken(masterKey, sasTokenProperties) {
  let resourcePrefixPath = "";
  if (typeof sasTokenProperties.databaseName === "string" && sasTokenProperties.databaseName !== "") {
    resourcePrefixPath += `/${Constants.Path.DatabasesPathSegment}/${sasTokenProperties.databaseName}`;
  }
  if (typeof sasTokenProperties.containerName === "string" && sasTokenProperties.containerName !== "") {
    if (sasTokenProperties.databaseName === "") {
      throw new Error(`illegalArgumentException : ${sasTokenProperties.databaseName}                           is an invalid database name`);
    }
    resourcePrefixPath += `/${Constants.Path.CollectionsPathSegment}/${sasTokenProperties.containerName}`;
  }
  if (typeof sasTokenProperties.resourceName === "string" && sasTokenProperties.resourceName !== "") {
    if (sasTokenProperties.containerName === "") {
      throw new Error(`illegalArgumentException : ${sasTokenProperties.containerName}                           is an invalid container name`);
    }
    switch (sasTokenProperties.resourceKind) {
      case "ITEM":
        resourcePrefixPath += `${Constants.Path.Root}${Constants.Path.DocumentsPathSegment}`;
        break;
      case "STORED_PROCEDURE":
        resourcePrefixPath += `${Constants.Path.Root}${Constants.Path.StoredProceduresPathSegment}`;
        break;
      case "USER_DEFINED_FUNCTION":
        resourcePrefixPath += `${Constants.Path.Root}${Constants.Path.UserDefinedFunctionsPathSegment}`;
        break;
      case "TRIGGER":
        resourcePrefixPath += `${Constants.Path.Root}${Constants.Path.TriggersPathSegment}`;
        break;
      default:
        throw new Error(`illegalArgumentException : ${sasTokenProperties.resourceKind}                           is an invalid resource kind`);
        break;
    }
    resourcePrefixPath += `${Constants.Path.Root}${sasTokenProperties.resourceName}${Constants.Path.Root}`;
  }
  sasTokenProperties.resourcePath = resourcePrefixPath.toString();
  let partitionRanges = "";
  if (sasTokenProperties.partitionKeyValueRanges !== void 0 && sasTokenProperties.partitionKeyValueRanges.length > 0) {
    if (typeof sasTokenProperties.resourceKind !== "string" && sasTokenProperties.resourceKind !== "ITEM") {
      throw new Error(`illegalArgumentException : ${sasTokenProperties.resourceKind}                           is an invalid partition key value range`);
    }
    sasTokenProperties.partitionKeyValueRanges.forEach((range) => {
      partitionRanges += `${encodeUTF8(range)},`;
    });
  }
  if (sasTokenProperties.controlPlaneReaderScope === 0) {
    sasTokenProperties.controlPlaneReaderScope += SasTokenPermissionKind.ContainerReadAny;
    sasTokenProperties.controlPlaneWriterScope += SasTokenPermissionKind.ContainerReadAny;
  }
  if (sasTokenProperties.dataPlaneReaderScope === 0 && sasTokenProperties.dataPlaneWriterScope === 0) {
    sasTokenProperties.dataPlaneReaderScope = SasTokenPermissionKind.ContainerFullAccess;
    sasTokenProperties.dataPlaneWriterScope = SasTokenPermissionKind.ContainerFullAccess;
  }
  if (typeof sasTokenProperties.keyType !== "number" || typeof sasTokenProperties.keyType === void 0) {
    switch (sasTokenProperties.keyType) {
      case CosmosKeyType.PrimaryMaster:
        sasTokenProperties.keyType = 1;
        break;
      case CosmosKeyType.SecondaryMaster:
        sasTokenProperties.keyType = 2;
        break;
      case CosmosKeyType.PrimaryReadOnly:
        sasTokenProperties.keyType = 3;
        break;
      case CosmosKeyType.SecondaryReadOnly:
        sasTokenProperties.keyType = 4;
        break;
      default:
        throw new Error(`illegalArgumentException : ${sasTokenProperties.keyType}                           is an invalid key type`);
        break;
    }
  }
  const payload = sasTokenProperties.user + "\n" + sasTokenProperties.userTag + "\n" + sasTokenProperties.resourcePath + "\n" + partitionRanges + "\n" + utcsecondsSinceEpoch(sasTokenProperties.startTime).toString(16) + "\n" + utcsecondsSinceEpoch(sasTokenProperties.expiryTime).toString(16) + "\n" + sasTokenProperties.keyType + "\n" + sasTokenProperties.controlPlaneReaderScope.toString(16) + "\n" + sasTokenProperties.controlPlaneWriterScope.toString(16) + "\n" + sasTokenProperties.dataPlaneReaderScope.toString(16) + "\n" + sasTokenProperties.dataPlaneWriterScope.toString(16) + "\n";
  const signedPayload = await hmac(masterKey, Buffer.from(payload).toString("base64"));
  return "type=sas&ver=1.0&sig=" + signedPayload + ";" + Buffer.from(payload).toString("base64");
}
function utcsecondsSinceEpoch(date) {
  return Math.round(date.getTime() / 1e3);
}
export {
  AbortError,
  BulkOperationType,
  ChangeFeedIterator,
  ChangeFeedIteratorResponse,
  ChangeFeedResponse,
  ChangeFeedStartFrom,
  ClientContext,
  ClientSideMetrics,
  Conflict,
  ConflictResolutionMode,
  ConflictResponse,
  Conflicts,
  ConnectionMode,
  ConsistencyLevel,
  Constants,
  Container,
  ContainerResponse,
  Containers,
  CosmosClient,
  CosmosDbDiagnosticLevel,
  CosmosDiagnostics,
  DEFAULT_PARTITION_KEY_PATH,
  DataType,
  Database,
  DatabaseAccount,
  DatabaseResponse,
  Databases,
  DiagnosticNodeInternal,
  DiagnosticNodeType,
  ErrorResponse,
  FeedRange,
  FeedResponse,
  GeospatialType,
  GlobalEndpointManager,
  HTTPMethod,
  IndexKind,
  IndexingMode,
  Item,
  ItemResponse,
  Items,
  MetadataLookUpType,
  Offer,
  OfferResponse,
  Offers,
  OperationType,
  PartitionKeyBuilder,
  PartitionKeyDefinitionVersion,
  PartitionKeyKind,
  PatchOperationType,
  Permission,
  PermissionMode,
  PermissionResponse,
  Permissions,
  PluginOn,
  PriorityLevel,
  QueryIterator,
  QueryMetrics,
  queryMetricsConstants_default as QueryMetricsConstants,
  QueryPreparationTimes,
  ResourceResponse,
  ResourceType,
  RestError,
  RuntimeExecutionTimes,
  SasTokenPermissionKind,
  SasTokenProperties,
  Scripts,
  SpatialType,
  StatusCodes,
  StoredProcedure,
  StoredProcedureResponse,
  StoredProcedures,
  TimeSpan,
  TimeoutError,
  Trigger,
  TriggerOperation,
  TriggerResponse,
  TriggerType,
  Triggers,
  User,
  UserDefinedFunction,
  UserDefinedFunctionResponse,
  UserDefinedFunctionType,
  UserDefinedFunctions,
  UserResponse,
  Users,
  createAuthorizationSasToken,
  setAuthorizationTokenHeaderUsingMasterKey
};
//# sourceMappingURL=@azure_cosmos.js.map
