{
  "version": 3,
  "sources": ["../../@azure/abort-controller/src/AbortController.ts", "../../@azure/core-util/src/random.ts", "../../@azure/core-util/src/object.ts", "../../@azure/core-util/src/error.ts", "../../@azure/core-util/src/bytesEncoding.browser.ts", "../../@azure/core-util/src/uuidUtils.native.ts", "../../@azure/core-util/src/uuidUtils.browser.ts", "../../@azure/core-util/src/checkEnvironment.ts", "../../@azure/core-rest-pipeline/src/util/inspect.browser.ts", "../../@azure/core-rest-pipeline/src/util/sanitizer.ts", "../../@azure/core-rest-pipeline/src/restError.ts", "../../@azure/core-rest-pipeline/src/pipeline.ts", "../../@azure/logger/src/log.browser.ts", "../../@azure/logger/src/debug.ts", "../../@azure/logger/src/index.ts", "../../@azure/core-rest-pipeline/src/log.ts", "../../@azure/core-rest-pipeline/src/policies/logPolicy.ts", "../../@azure/core-rest-pipeline/src/policies/redirectPolicy.ts", "../../@azure/core-rest-pipeline/src/util/userAgentPlatform.browser.ts", "../../@azure/core-rest-pipeline/src/constants.ts", "../../@azure/core-rest-pipeline/src/util/userAgent.ts", "../../@azure/core-rest-pipeline/src/policies/userAgentPolicy.ts", "../../@azure/core-rest-pipeline/src/util/typeGuards.ts", "../../@azure/core-rest-pipeline/src/util/file.ts", "../../@azure/core-rest-pipeline/src/util/concat.browser.ts", "../../@azure/core-rest-pipeline/src/policies/multipartPolicy.ts", "../../@azure/core-rest-pipeline/src/policies/decompressResponsePolicy.browser.ts", "../../@azure/core-rest-pipeline/node_modules/@azure/abort-controller/src/AbortError.ts", "../../@azure/core-rest-pipeline/src/util/helpers.ts", "../../@azure/core-rest-pipeline/src/retryStrategies/throttlingRetryStrategy.ts", "../../@azure/core-rest-pipeline/src/retryStrategies/exponentialRetryStrategy.ts", "../../@azure/core-rest-pipeline/src/policies/retryPolicy.ts", "../../@azure/core-rest-pipeline/src/policies/defaultRetryPolicy.ts", "../../@azure/core-rest-pipeline/src/policies/formDataPolicy.browser.ts", "../../@azure/core-rest-pipeline/src/policies/proxyPolicy.browser.ts", "../../@azure/core-rest-pipeline/src/policies/setClientRequestIdPolicy.ts", "../../@azure/core-rest-pipeline/src/policies/tlsPolicy.ts", "../../@azure/core-rest-pipeline/node_modules/@azure/core-tracing/src/tracingContext.ts", "../../@azure/core-rest-pipeline/node_modules/@azure/core-tracing/src/instrumenter.ts", "../../@azure/core-rest-pipeline/node_modules/@azure/core-tracing/src/tracingClient.ts", "../../@azure/core-rest-pipeline/src/policies/tracingPolicy.ts", "../../@azure/core-rest-pipeline/src/createPipelineFromOptions.ts", "../../@azure/core-rest-pipeline/src/httpHeaders.ts", "../../@azure/core-rest-pipeline/src/fetchHttpClient.ts", "../../@azure/core-rest-pipeline/src/defaultHttpClient.browser.ts", "../../@azure/core-rest-pipeline/src/pipelineRequest.ts", "../../@azure/core-rest-pipeline/src/util/tokenCycler.ts", "../../@azure/core-rest-pipeline/src/policies/bearerTokenAuthenticationPolicy.ts"],
  "sourcesContent": ["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortSignal, AbortSignalLike, abortSignal } from \"./AbortSignal\";\n\n/**\n * This error is thrown when an asynchronous operation has been aborted.\n * Check for this error by testing the `name` that the name property of the\n * error matches `\"AbortError\"`.\n *\n * @example\n * ```ts\n * const controller = new AbortController();\n * controller.abort();\n * try {\n *   doAsyncWork(controller.signal)\n * } catch (e) {\n *   if (e.name === 'AbortError') {\n *     // handle abort error here.\n *   }\n * }\n * ```\n */\nexport class AbortError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = \"AbortError\";\n  }\n}\n\n/**\n * An AbortController provides an AbortSignal and the associated controls to signal\n * that an asynchronous operation should be aborted.\n *\n * @example\n * Abort an operation when another event fires\n * ```ts\n * const controller = new AbortController();\n * const signal = controller.signal;\n * doAsyncWork(signal);\n * button.addEventListener('click', () => controller.abort());\n * ```\n *\n * @example\n * Share aborter cross multiple operations in 30s\n * ```ts\n * // Upload the same data to 2 different data centers at the same time,\n * // abort another when any of them is finished\n * const controller = AbortController.withTimeout(30 * 1000);\n * doAsyncWork(controller.signal).then(controller.abort);\n * doAsyncWork(controller.signal).then(controller.abort);\n *```\n *\n * @example\n * Cascaded aborting\n * ```ts\n * // All operations can't take more than 30 seconds\n * const aborter = Aborter.timeout(30 * 1000);\n *\n * // Following 2 operations can't take more than 25 seconds\n * await doAsyncWork(aborter.withTimeout(25 * 1000));\n * await doAsyncWork(aborter.withTimeout(25 * 1000));\n * ```\n */\nexport class AbortController {\n  private _signal: AbortSignal;\n\n  /**\n   * @param parentSignals - The AbortSignals that will signal aborted on the AbortSignal associated with this controller.\n   */\n  constructor(parentSignals?: AbortSignalLike[]);\n  /**\n   * @param parentSignals - The AbortSignals that will signal aborted on the AbortSignal associated with this controller.\n   */\n  constructor(...parentSignals: AbortSignalLike[]);\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(parentSignals?: any) {\n    this._signal = new AbortSignal();\n\n    if (!parentSignals) {\n      return;\n    }\n    // coerce parentSignals into an array\n    if (!Array.isArray(parentSignals)) {\n      // eslint-disable-next-line prefer-rest-params\n      parentSignals = arguments;\n    }\n    for (const parentSignal of parentSignals) {\n      // if the parent signal has already had abort() called,\n      // then call abort on this signal as well.\n      if (parentSignal.aborted) {\n        this.abort();\n      } else {\n        // when the parent signal aborts, this signal should as well.\n        parentSignal.addEventListener(\"abort\", () => {\n          this.abort();\n        });\n      }\n    }\n  }\n\n  /**\n   * The AbortSignal associated with this controller that will signal aborted\n   * when the abort method is called on this controller.\n   *\n   * @readonly\n   */\n  public get signal(): AbortSignal {\n    return this._signal;\n  }\n\n  /**\n   * Signal that any operations passed this controller's associated abort signal\n   * to cancel any remaining work and throw an `AbortError`.\n   */\n  abort(): void {\n    abortSignal(this._signal);\n  }\n\n  /**\n   * Creates a new AbortSignal instance that will abort after the provided ms.\n   * @param ms - Elapsed time in milliseconds to trigger an abort.\n   */\n  public static timeout(ms: number): AbortSignal {\n    const signal = new AbortSignal();\n    const timer = setTimeout(abortSignal, ms, signal);\n    // Prevent the active Timer from keeping the Node.js event loop active.\n    if (typeof timer.unref === \"function\") {\n      timer.unref();\n    }\n    return signal;\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * Returns a random integer value between a lower and upper bound,\n * inclusive of both bounds.\n * Note that this uses Math.random and isn't secure. If you need to use\n * this for any kind of security purpose, find a better source of random.\n * @param min - The smallest integer value allowed.\n * @param max - The largest integer value allowed.\n */\nexport function getRandomIntegerInclusive(min: number, max: number): number {\n  // Make sure inputs are integers.\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  // Pick a random offset from zero to the size of the range.\n  // Since Math.random() can never return 1, we have to make the range one larger\n  // in order to be inclusive of the maximum value after we take the floor.\n  const offset = Math.floor(Math.random() * (max - min + 1));\n  return offset + min;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * A generic shape for a plain JS object.\n */\nexport type UnknownObject = { [s: string]: unknown };\n\n/**\n * Helper to determine when an input is a generic JS object.\n * @returns true when input is an object type that is not null, Array, RegExp, or Date.\n */\nexport function isObject(input: unknown): input is UnknownObject {\n  return (\n    typeof input === \"object\" &&\n    input !== null &&\n    !Array.isArray(input) &&\n    !(input instanceof RegExp) &&\n    !(input instanceof Date)\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isObject } from \"./object\";\n\n/**\n * Typeguard for an error object shape (has name and message)\n * @param e - Something caught by a catch clause.\n */\nexport function isError(e: unknown): e is Error {\n  if (isObject(e)) {\n    const hasName = typeof e.name === \"string\";\n    const hasMessage = typeof e.message === \"string\";\n    return hasName && hasMessage;\n  }\n  return false;\n}\n\n/**\n * Given what is thought to be an error object, return the message if possible.\n * If the message is missing, returns a stringified version of the input.\n * @param e - Something thrown from a try block\n * @returns The error message or a string of the input\n */\nexport function getErrorMessage(e: unknown): string {\n  if (isError(e)) {\n    return e.message;\n  } else {\n    let stringified: string;\n    try {\n      if (typeof e === \"object\" && e) {\n        stringified = JSON.stringify(e);\n      } else {\n        stringified = String(e);\n      }\n    } catch (err: any) {\n      stringified = \"[unable to stringify input]\";\n    }\n    return `Unknown error ${stringified}`;\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\ndeclare global {\n  // stub these out for the browser\n  function btoa(input: string): string;\n  function atob(input: string): string;\n}\n\n/** The supported character encoding type */\nexport type EncodingType = \"utf-8\" | \"base64\" | \"base64url\" | \"hex\";\n\n/**\n * The helper that transforms bytes with specific character encoding into string\n * @param bytes - the uint8array bytes\n * @param format - the format we use to encode the byte\n * @returns a string of the encoded string\n */\nexport function uint8ArrayToString(bytes: Uint8Array, format: EncodingType): string {\n  switch (format) {\n    case \"utf-8\":\n      return uint8ArrayToUtf8String(bytes);\n    case \"base64\":\n      return uint8ArrayToBase64(bytes);\n    case \"base64url\":\n      return uint8ArrayToBase64Url(bytes);\n    case \"hex\":\n      return uint8ArrayToHexString(bytes);\n  }\n}\n\n/**\n * The helper that transforms string to specific character encoded bytes array.\n * @param value - the string to be converted\n * @param format - the format we use to decode the value\n * @returns a uint8array\n */\nexport function stringToUint8Array(value: string, format: EncodingType): Uint8Array {\n  switch (format) {\n    case \"utf-8\":\n      return utf8StringToUint8Array(value);\n    case \"base64\":\n      return base64ToUint8Array(value);\n    case \"base64url\":\n      return base64UrlToUint8Array(value);\n    case \"hex\":\n      return hexStringToUint8Array(value);\n  }\n}\n\n/**\n * Decodes a Uint8Array into a Base64 string.\n * @internal\n */\nexport function uint8ArrayToBase64(bytes: Uint8Array): string {\n  return btoa([...bytes].map((x) => String.fromCharCode(x)).join(\"\"));\n}\n\n/**\n * Decodes a Uint8Array into a Base64Url string.\n * @internal\n */\nexport function uint8ArrayToBase64Url(bytes: Uint8Array): string {\n  return uint8ArrayToBase64(bytes).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\n\n/**\n * Decodes a Uint8Array into a javascript string.\n * @internal\n */\nexport function uint8ArrayToUtf8String(bytes: Uint8Array): string {\n  const decoder = new TextDecoder();\n  const dataString = decoder.decode(bytes);\n  return dataString;\n}\n\n/**\n * Decodes a Uint8Array into a hex string\n * @internal\n */\nexport function uint8ArrayToHexString(bytes: Uint8Array): string {\n  return [...bytes].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\");\n}\n\n/**\n * Encodes a JavaScript string into a Uint8Array.\n * @internal\n */\nexport function utf8StringToUint8Array(value: string): Uint8Array {\n  return new TextEncoder().encode(value);\n}\n\n/**\n * Encodes a Base64 string into a Uint8Array.\n * @internal\n */\nexport function base64ToUint8Array(value: string): Uint8Array {\n  return new Uint8Array([...atob(value)].map((x) => x.charCodeAt(0)));\n}\n\n/**\n * Encodes a Base64Url string into a Uint8Array.\n * @internal\n */\nexport function base64UrlToUint8Array(value: string): Uint8Array {\n  const base64String = value.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  return base64ToUint8Array(base64String);\n}\n\nconst hexDigits = new Set(\"0123456789abcdefABCDEF\");\n\n/**\n * Encodes a hex string into a Uint8Array\n * @internal\n */\nexport function hexStringToUint8Array(value: string): Uint8Array {\n  // If value has odd length, the last character will be ignored, consistent with NodeJS Buffer behavior\n  const bytes = new Uint8Array(value.length / 2);\n  for (let i = 0; i < value.length / 2; ++i) {\n    const highNibble = value[2 * i];\n    const lowNibble = value[2 * i + 1];\n    if (!hexDigits.has(highNibble) || !hexDigits.has(lowNibble)) {\n      // Replicate Node Buffer behavior by exiting early when we encounter an invalid byte\n      return bytes.slice(0, i);\n    }\n\n    bytes[i] = parseInt(`${highNibble}${lowNibble}`, 16);\n  }\n\n  return bytes;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/*\n * NOTE: When moving this file, please update \"react-native\" section in package.json.\n */\n\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n */\nexport function generateUUID(): string {\n  let uuid = \"\";\n  for (let i = 0; i < 32; i++) {\n    // Generate a random number between 0 and 15\n    const randomNumber = Math.floor(Math.random() * 16);\n    // Set the UUID version to 4 in the 13th position\n    if (i === 12) {\n      uuid += \"4\";\n    } else if (i === 16) {\n      // Set the UUID variant to \"10\" in the 17th position\n      uuid += (randomNumber & 0x3) | 0x8;\n    } else {\n      // Add a random hexadecimal digit to the UUID string\n      uuid += randomNumber.toString(16);\n    }\n    // Add hyphens to the UUID string at the appropriate positions\n    if (i === 7 || i === 11 || i === 15 || i === 19) {\n      uuid += \"-\";\n    }\n  }\n  return uuid;\n}\n\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n */\nexport function randomUUID(): string {\n  return generateUUID();\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { generateUUID } from \"./uuidUtils.native\";\n\ninterface Crypto {\n  randomUUID(): string;\n}\n\ndeclare const globalThis: {\n  crypto: Crypto;\n};\n\n// NOTE: This could be undefined if not used in a secure context\nconst uuidFunction =\n  typeof globalThis?.crypto?.randomUUID === \"function\"\n    ? globalThis.crypto.randomUUID.bind(globalThis.crypto)\n    : generateUUID;\n\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n */\nexport function randomUUID(): string {\n  return uuidFunction();\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\ndeclare global {\n  interface Window {\n    document: unknown;\n  }\n\n  interface DedicatedWorkerGlobalScope {\n    constructor: {\n      name: string;\n    };\n\n    importScripts: (...paths: string[]) => void;\n  }\n\n  interface Navigator {\n    product: string;\n  }\n\n  interface DenoGlobal {\n    version: {\n      deno: string;\n    };\n  }\n\n  interface BunGlobal {\n    version: string;\n  }\n\n  // eslint-disable-next-line @azure/azure-sdk/ts-no-window\n  const window: Window;\n  const self: DedicatedWorkerGlobalScope;\n  const Deno: DenoGlobal;\n  const Bun: BunGlobal;\n  const navigator: Navigator;\n}\n\n/**\n * A constant that indicates whether the environment the code is running is a Web Browser.\n */\n// eslint-disable-next-line @azure/azure-sdk/ts-no-window\nexport const isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\";\n\n/**\n * A constant that indicates whether the environment the code is running is a Web Worker.\n */\nexport const isWebWorker =\n  typeof self === \"object\" &&\n  typeof self?.importScripts === \"function\" &&\n  (self.constructor?.name === \"DedicatedWorkerGlobalScope\" ||\n    self.constructor?.name === \"ServiceWorkerGlobalScope\" ||\n    self.constructor?.name === \"SharedWorkerGlobalScope\");\n\n/**\n * A constant that indicates whether the environment the code is running is Deno.\n */\nexport const isDeno =\n  typeof Deno !== \"undefined\" &&\n  typeof Deno.version !== \"undefined\" &&\n  typeof Deno.version.deno !== \"undefined\";\n\n/**\n * A constant that indicates whether the environment the code is running is Node.JS.\n */\nexport const isNode =\n  typeof process !== \"undefined\" &&\n  Boolean(process.version) &&\n  Boolean(process.versions?.node) &&\n  // Deno thought it was a good idea to spoof process.versions.node, see https://deno.land/std@0.177.0/node/process.ts?s=versions\n  !isDeno;\n\n/**\n * A constant that indicates whether the environment the code is running is Bun.sh.\n */\nexport const isBun = typeof Bun !== \"undefined\" && typeof Bun.version !== \"undefined\";\n\n/**\n * A constant that indicates whether the environment the code is running is in React-Native.\n */\n// https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js\nexport const isReactNative =\n  typeof navigator !== \"undefined\" && navigator?.product === \"ReactNative\";\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport const custom = {};\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { type UnknownObject, isObject } from \"@azure/core-util\";\n\n/**\n * @internal\n */\nexport interface SanitizerOptions {\n  /**\n   * Header names whose values will be logged when logging is enabled.\n   * Defaults include a list of well-known safe headers. Any headers\n   * specified in this field will be added to that list.  Any other values will\n   * be written to logs as \"REDACTED\".\n   */\n  additionalAllowedHeaderNames?: string[];\n\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  additionalAllowedQueryParameters?: string[];\n}\n\nconst RedactedString = \"REDACTED\";\n\n// Make sure this list is up-to-date with the one under core/logger/Readme#Keyconcepts\nconst defaultAllowedHeaderNames = [\n  \"x-ms-client-request-id\",\n  \"x-ms-return-client-request-id\",\n  \"x-ms-useragent\",\n  \"x-ms-correlation-request-id\",\n  \"x-ms-request-id\",\n  \"client-request-id\",\n  \"ms-cv\",\n  \"return-client-request-id\",\n  \"traceparent\",\n\n  \"Access-Control-Allow-Credentials\",\n  \"Access-Control-Allow-Headers\",\n  \"Access-Control-Allow-Methods\",\n  \"Access-Control-Allow-Origin\",\n  \"Access-Control-Expose-Headers\",\n  \"Access-Control-Max-Age\",\n  \"Access-Control-Request-Headers\",\n  \"Access-Control-Request-Method\",\n  \"Origin\",\n\n  \"Accept\",\n  \"Accept-Encoding\",\n  \"Cache-Control\",\n  \"Connection\",\n  \"Content-Length\",\n  \"Content-Type\",\n  \"Date\",\n  \"ETag\",\n  \"Expires\",\n  \"If-Match\",\n  \"If-Modified-Since\",\n  \"If-None-Match\",\n  \"If-Unmodified-Since\",\n  \"Last-Modified\",\n  \"Pragma\",\n  \"Request-Id\",\n  \"Retry-After\",\n  \"Server\",\n  \"Transfer-Encoding\",\n  \"User-Agent\",\n  \"WWW-Authenticate\",\n];\n\nconst defaultAllowedQueryParameters: string[] = [\"api-version\"];\n\n/**\n * @internal\n */\nexport class Sanitizer {\n  private allowedHeaderNames: Set<string>;\n  private allowedQueryParameters: Set<string>;\n\n  constructor({\n    additionalAllowedHeaderNames: allowedHeaderNames = [],\n    additionalAllowedQueryParameters: allowedQueryParameters = [],\n  }: SanitizerOptions = {}) {\n    allowedHeaderNames = defaultAllowedHeaderNames.concat(allowedHeaderNames);\n    allowedQueryParameters = defaultAllowedQueryParameters.concat(allowedQueryParameters);\n\n    this.allowedHeaderNames = new Set(allowedHeaderNames.map((n) => n.toLowerCase()));\n    this.allowedQueryParameters = new Set(allowedQueryParameters.map((p) => p.toLowerCase()));\n  }\n\n  public sanitize(obj: unknown): string {\n    const seen = new Set<unknown>();\n    return JSON.stringify(\n      obj,\n      (key: string, value: unknown) => {\n        // Ensure Errors include their interesting non-enumerable members\n        if (value instanceof Error) {\n          return {\n            ...value,\n            name: value.name,\n            message: value.message,\n          };\n        }\n\n        if (key === \"headers\") {\n          return this.sanitizeHeaders(value as UnknownObject);\n        } else if (key === \"url\") {\n          return this.sanitizeUrl(value as string);\n        } else if (key === \"query\") {\n          return this.sanitizeQuery(value as UnknownObject);\n        } else if (key === \"body\") {\n          // Don't log the request body\n          return undefined;\n        } else if (key === \"response\") {\n          // Don't log response again\n          return undefined;\n        } else if (key === \"operationSpec\") {\n          // When using sendOperationRequest, the request carries a massive\n          // field with the autorest spec. No need to log it.\n          return undefined;\n        } else if (Array.isArray(value) || isObject(value)) {\n          if (seen.has(value)) {\n            return \"[Circular]\";\n          }\n          seen.add(value);\n        }\n\n        return value;\n      },\n      2,\n    );\n  }\n\n  private sanitizeHeaders(obj: UnknownObject): UnknownObject {\n    const sanitized: UnknownObject = {};\n    for (const key of Object.keys(obj)) {\n      if (this.allowedHeaderNames.has(key.toLowerCase())) {\n        sanitized[key] = obj[key];\n      } else {\n        sanitized[key] = RedactedString;\n      }\n    }\n    return sanitized;\n  }\n\n  private sanitizeQuery(value: UnknownObject): UnknownObject {\n    if (typeof value !== \"object\" || value === null) {\n      return value;\n    }\n\n    const sanitized: UnknownObject = {};\n\n    for (const k of Object.keys(value)) {\n      if (this.allowedQueryParameters.has(k.toLowerCase())) {\n        sanitized[k] = value[k];\n      } else {\n        sanitized[k] = RedactedString;\n      }\n    }\n\n    return sanitized;\n  }\n\n  private sanitizeUrl(value: string): string {\n    if (typeof value !== \"string\" || value === null) {\n      return value;\n    }\n\n    const url = new URL(value);\n\n    if (!url.search) {\n      return value;\n    }\n\n    for (const [key] of url.searchParams) {\n      if (!this.allowedQueryParameters.has(key.toLowerCase())) {\n        url.searchParams.set(key, RedactedString);\n      }\n    }\n\n    return url.toString();\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isError } from \"@azure/core-util\";\nimport type { PipelineRequest, PipelineResponse } from \"./interfaces\";\nimport { custom } from \"./util/inspect\";\nimport { Sanitizer } from \"./util/sanitizer\";\n\nconst errorSanitizer = new Sanitizer();\n\n/**\n * The options supported by RestError.\n */\nexport interface RestErrorOptions {\n  /**\n   * The code of the error itself (use statics on RestError if possible.)\n   */\n  code?: string;\n  /**\n   * The HTTP status code of the request (if applicable.)\n   */\n  statusCode?: number;\n  /**\n   * The request that was made.\n   */\n  request?: PipelineRequest;\n  /**\n   * The response received (if any.)\n   */\n  response?: PipelineResponse;\n}\n\n/**\n * A custom error type for failed pipeline requests.\n */\nexport class RestError extends Error {\n  /**\n   * Something went wrong when making the request.\n   * This means the actual request failed for some reason,\n   * such as a DNS issue or the connection being lost.\n   */\n  static readonly REQUEST_SEND_ERROR: string = \"REQUEST_SEND_ERROR\";\n  /**\n   * This means that parsing the response from the server failed.\n   * It may have been malformed.\n   */\n  static readonly PARSE_ERROR: string = \"PARSE_ERROR\";\n\n  /**\n   * The code of the error itself (use statics on RestError if possible.)\n   */\n  public code?: string;\n  /**\n   * The HTTP status code of the request (if applicable.)\n   */\n  public statusCode?: number;\n  /**\n   * The request that was made.\n   */\n  public request?: PipelineRequest;\n  /**\n   * The response received (if any.)\n   */\n  public response?: PipelineResponse;\n  /**\n   * Bonus property set by the throw site.\n   */\n  public details?: unknown;\n\n  constructor(message: string, options: RestErrorOptions = {}) {\n    super(message);\n    this.name = \"RestError\";\n    this.code = options.code;\n    this.statusCode = options.statusCode;\n    this.request = options.request;\n    this.response = options.response;\n\n    Object.setPrototypeOf(this, RestError.prototype);\n  }\n\n  /**\n   * Logging method for util.inspect in Node\n   */\n  [custom](): string {\n    return `RestError: ${this.message} \\n ${errorSanitizer.sanitize(this)}`;\n  }\n}\n\n/**\n * Typeguard for RestError\n * @param e - Something caught by a catch clause.\n */\nexport function isRestError(e: unknown): e is RestError {\n  if (e instanceof RestError) {\n    return true;\n  }\n  return isError(e) && e.name === \"RestError\";\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { HttpClient, PipelineRequest, PipelineResponse, SendRequest } from \"./interfaces\";\n\n/**\n * Policies are executed in phases.\n * The execution order is:\n * 1. Serialize Phase\n * 2. Policies not in a phase\n * 3. Deserialize Phase\n * 4. Retry Phase\n * 5. Sign Phase\n */\nexport type PipelinePhase = \"Deserialize\" | \"Serialize\" | \"Retry\" | \"Sign\";\n\nconst ValidPhaseNames = new Set<PipelinePhase>([\"Deserialize\", \"Serialize\", \"Retry\", \"Sign\"]);\n\n/**\n * Options when adding a policy to the pipeline.\n * Used to express dependencies on other policies.\n */\nexport interface AddPolicyOptions {\n  /**\n   * Policies that this policy must come before.\n   */\n  beforePolicies?: string[];\n  /**\n   * Policies that this policy must come after.\n   */\n  afterPolicies?: string[];\n  /**\n   * The phase that this policy must come after.\n   */\n  afterPhase?: PipelinePhase;\n  /**\n   * The phase this policy belongs to.\n   */\n  phase?: PipelinePhase;\n}\n\n/**\n * A pipeline policy manipulates a request as it travels through the pipeline.\n * It is conceptually a middleware that is allowed to modify the request before\n * it is made as well as the response when it is received.\n */\nexport interface PipelinePolicy {\n  /**\n   * The policy name. Must be a unique string in the pipeline.\n   */\n  name: string;\n  /**\n   * The main method to implement that manipulates a request/response.\n   * @param request - The request being performed.\n   * @param next - The next policy in the pipeline. Must be called to continue the pipeline.\n   */\n  sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse>;\n}\n\n/**\n * Represents a pipeline for making a HTTP request to a URL.\n * Pipelines can have multiple policies to manage manipulating each request\n * before and after it is made to the server.\n */\nexport interface Pipeline {\n  /**\n   * Add a new policy to the pipeline.\n   * @param policy - A policy that manipulates a request.\n   * @param options - A set of options for when the policy should run.\n   */\n  addPolicy(policy: PipelinePolicy, options?: AddPolicyOptions): void;\n  /**\n   * Remove a policy from the pipeline.\n   * @param options - Options that let you specify which policies to remove.\n   */\n  removePolicy(options: { name?: string; phase?: PipelinePhase }): PipelinePolicy[];\n  /**\n   * Uses the pipeline to make a HTTP request.\n   * @param httpClient - The HttpClient that actually performs the request.\n   * @param request - The request to be made.\n   */\n  sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse>;\n  /**\n   * Returns the current set of policies in the pipeline in the order in which\n   * they will be applied to the request. Later in the list is closer to when\n   * the request is performed.\n   */\n  getOrderedPolicies(): PipelinePolicy[];\n  /**\n   * Duplicates this pipeline to allow for modifying an existing one without mutating it.\n   */\n  clone(): Pipeline;\n}\n\ninterface PipelineDescriptor {\n  policy: PipelinePolicy;\n  options: AddPolicyOptions;\n}\n\ninterface PolicyGraphNode {\n  policy: PipelinePolicy;\n  dependsOn: Set<PolicyGraphNode>;\n  dependants: Set<PolicyGraphNode>;\n  afterPhase?: Phase;\n}\n\ninterface Phase {\n  name: PipelinePhase | \"None\";\n  policies: Set<PolicyGraphNode>;\n  hasRun: boolean;\n  hasAfterPolicies: boolean;\n}\n\n/**\n * A private implementation of Pipeline.\n * Do not export this class from the package.\n * @internal\n */\nclass HttpPipeline implements Pipeline {\n  private _policies: PipelineDescriptor[] = [];\n  private _orderedPolicies?: PipelinePolicy[];\n\n  private constructor(policies?: PipelineDescriptor[]) {\n    this._policies = policies?.slice(0) ?? [];\n    this._orderedPolicies = undefined;\n  }\n\n  public addPolicy(policy: PipelinePolicy, options: AddPolicyOptions = {}): void {\n    if (options.phase && options.afterPhase) {\n      throw new Error(\"Policies inside a phase cannot specify afterPhase.\");\n    }\n    if (options.phase && !ValidPhaseNames.has(options.phase)) {\n      throw new Error(`Invalid phase name: ${options.phase}`);\n    }\n    if (options.afterPhase && !ValidPhaseNames.has(options.afterPhase)) {\n      throw new Error(`Invalid afterPhase name: ${options.afterPhase}`);\n    }\n    this._policies.push({\n      policy,\n      options,\n    });\n    this._orderedPolicies = undefined;\n  }\n\n  public removePolicy(options: { name?: string; phase?: string }): PipelinePolicy[] {\n    const removedPolicies: PipelinePolicy[] = [];\n\n    this._policies = this._policies.filter((policyDescriptor) => {\n      if (\n        (options.name && policyDescriptor.policy.name === options.name) ||\n        (options.phase && policyDescriptor.options.phase === options.phase)\n      ) {\n        removedPolicies.push(policyDescriptor.policy);\n        return false;\n      } else {\n        return true;\n      }\n    });\n    this._orderedPolicies = undefined;\n\n    return removedPolicies;\n  }\n\n  public sendRequest(httpClient: HttpClient, request: PipelineRequest): Promise<PipelineResponse> {\n    const policies = this.getOrderedPolicies();\n\n    const pipeline = policies.reduceRight<SendRequest>(\n      (next, policy) => {\n        return (req: PipelineRequest) => {\n          return policy.sendRequest(req, next);\n        };\n      },\n      (req: PipelineRequest) => httpClient.sendRequest(req),\n    );\n\n    return pipeline(request);\n  }\n\n  public getOrderedPolicies(): PipelinePolicy[] {\n    if (!this._orderedPolicies) {\n      this._orderedPolicies = this.orderPolicies();\n    }\n    return this._orderedPolicies;\n  }\n\n  public clone(): Pipeline {\n    return new HttpPipeline(this._policies);\n  }\n\n  public static create(): Pipeline {\n    return new HttpPipeline();\n  }\n\n  private orderPolicies(): PipelinePolicy[] {\n    /**\n     * The goal of this method is to reliably order pipeline policies\n     * based on their declared requirements when they were added.\n     *\n     * Order is first determined by phase:\n     *\n     * 1. Serialize Phase\n     * 2. Policies not in a phase\n     * 3. Deserialize Phase\n     * 4. Retry Phase\n     * 5. Sign Phase\n     *\n     * Within each phase, policies are executed in the order\n     * they were added unless they were specified to execute\n     * before/after other policies or after a particular phase.\n     *\n     * To determine the final order, we will walk the policy list\n     * in phase order multiple times until all dependencies are\n     * satisfied.\n     *\n     * `afterPolicies` are the set of policies that must be\n     * executed before a given policy. This requirement is\n     * considered satisfied when each of the listed policies\n     * have been scheduled.\n     *\n     * `beforePolicies` are the set of policies that must be\n     * executed after a given policy. Since this dependency\n     * can be expressed by converting it into a equivalent\n     * `afterPolicies` declarations, they are normalized\n     * into that form for simplicity.\n     *\n     * An `afterPhase` dependency is considered satisfied when all\n     * policies in that phase have scheduled.\n     *\n     */\n    const result: PipelinePolicy[] = [];\n\n    // Track all policies we know about.\n    const policyMap: Map<string, PolicyGraphNode> = new Map<string, PolicyGraphNode>();\n\n    function createPhase(name: PipelinePhase | \"None\"): Phase {\n      return {\n        name,\n        policies: new Set<PolicyGraphNode>(),\n        hasRun: false,\n        hasAfterPolicies: false,\n      };\n    }\n\n    // Track policies for each phase.\n    const serializePhase = createPhase(\"Serialize\");\n    const noPhase = createPhase(\"None\");\n    const deserializePhase = createPhase(\"Deserialize\");\n    const retryPhase = createPhase(\"Retry\");\n    const signPhase = createPhase(\"Sign\");\n\n    // a list of phases in order\n    const orderedPhases = [serializePhase, noPhase, deserializePhase, retryPhase, signPhase];\n\n    // Small helper function to map phase name to each Phase\n    function getPhase(phase: PipelinePhase | undefined): Phase {\n      if (phase === \"Retry\") {\n        return retryPhase;\n      } else if (phase === \"Serialize\") {\n        return serializePhase;\n      } else if (phase === \"Deserialize\") {\n        return deserializePhase;\n      } else if (phase === \"Sign\") {\n        return signPhase;\n      } else {\n        return noPhase;\n      }\n    }\n\n    // First walk each policy and create a node to track metadata.\n    for (const descriptor of this._policies) {\n      const policy = descriptor.policy;\n      const options = descriptor.options;\n      const policyName = policy.name;\n      if (policyMap.has(policyName)) {\n        throw new Error(\"Duplicate policy names not allowed in pipeline\");\n      }\n      const node: PolicyGraphNode = {\n        policy,\n        dependsOn: new Set<PolicyGraphNode>(),\n        dependants: new Set<PolicyGraphNode>(),\n      };\n      if (options.afterPhase) {\n        node.afterPhase = getPhase(options.afterPhase);\n        node.afterPhase.hasAfterPolicies = true;\n      }\n      policyMap.set(policyName, node);\n      const phase = getPhase(options.phase);\n      phase.policies.add(node);\n    }\n\n    // Now that each policy has a node, connect dependency references.\n    for (const descriptor of this._policies) {\n      const { policy, options } = descriptor;\n      const policyName = policy.name;\n      const node = policyMap.get(policyName);\n      if (!node) {\n        throw new Error(`Missing node for policy ${policyName}`);\n      }\n\n      if (options.afterPolicies) {\n        for (const afterPolicyName of options.afterPolicies) {\n          const afterNode = policyMap.get(afterPolicyName);\n          if (afterNode) {\n            // Linking in both directions helps later\n            // when we want to notify dependants.\n            node.dependsOn.add(afterNode);\n            afterNode.dependants.add(node);\n          }\n        }\n      }\n      if (options.beforePolicies) {\n        for (const beforePolicyName of options.beforePolicies) {\n          const beforeNode = policyMap.get(beforePolicyName);\n          if (beforeNode) {\n            // To execute before another node, make it\n            // depend on the current node.\n            beforeNode.dependsOn.add(node);\n            node.dependants.add(beforeNode);\n          }\n        }\n      }\n    }\n\n    function walkPhase(phase: Phase): void {\n      phase.hasRun = true;\n      // Sets iterate in insertion order\n      for (const node of phase.policies) {\n        if (node.afterPhase && (!node.afterPhase.hasRun || node.afterPhase.policies.size)) {\n          // If this node is waiting on a phase to complete,\n          // we need to skip it for now.\n          // Even if the phase is empty, we should wait for it\n          // to be walked to avoid re-ordering policies.\n          continue;\n        }\n        if (node.dependsOn.size === 0) {\n          // If there's nothing else we're waiting for, we can\n          // add this policy to the result list.\n          result.push(node.policy);\n          // Notify anything that depends on this policy that\n          // the policy has been scheduled.\n          for (const dependant of node.dependants) {\n            dependant.dependsOn.delete(node);\n          }\n          policyMap.delete(node.policy.name);\n          phase.policies.delete(node);\n        }\n      }\n    }\n\n    function walkPhases(): void {\n      for (const phase of orderedPhases) {\n        walkPhase(phase);\n        // if the phase isn't complete\n        if (phase.policies.size > 0 && phase !== noPhase) {\n          if (!noPhase.hasRun) {\n            // Try running noPhase to see if that unblocks this phase next tick.\n            // This can happen if a phase that happens before noPhase\n            // is waiting on a noPhase policy to complete.\n            walkPhase(noPhase);\n          }\n          // Don't proceed to the next phase until this phase finishes.\n          return;\n        }\n\n        if (phase.hasAfterPolicies) {\n          // Run any policies unblocked by this phase\n          walkPhase(noPhase);\n        }\n      }\n    }\n\n    // Iterate until we've put every node in the result list.\n    let iteration = 0;\n    while (policyMap.size > 0) {\n      iteration++;\n      const initialResultLength = result.length;\n      // Keep walking each phase in order until we can order every node.\n      walkPhases();\n      // The result list *should* get at least one larger each time\n      // after the first full pass.\n      // Otherwise, we're going to loop forever.\n      if (result.length <= initialResultLength && iteration > 1) {\n        throw new Error(\"Cannot satisfy policy dependencies due to requirements cycle.\");\n      }\n    }\n\n    return result;\n  }\n}\n\n/**\n * Creates a totally empty pipeline.\n * Useful for testing or creating a custom one.\n */\nexport function createEmptyPipeline(): Pipeline {\n  return HttpPipeline.create();\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport function log(...args: any[]): void {\n  if (args.length > 0) {\n    const firstArg = String(args[0]);\n    if (firstArg.includes(\":error\")) {\n      console.error(...args);\n    } else if (firstArg.includes(\":warning\")) {\n      console.warn(...args);\n    } else if (firstArg.includes(\":info\")) {\n      console.info(...args);\n    } else if (firstArg.includes(\":verbose\")) {\n      console.debug(...args);\n    } else {\n      console.debug(...args);\n    }\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { log } from \"./log\";\n\n/**\n * A simple mechanism for enabling logging.\n * Intended to mimic the publicly available `debug` package.\n */\nexport interface Debug {\n  /**\n   * Creates a new logger with the given namespace.\n   */\n  (namespace: string): Debugger;\n  /**\n   * The default log method (defaults to console)\n   */\n  log: (...args: any[]) => void;\n  /**\n   * Enables a particular set of namespaces.\n   * To enable multiple separate them with commas, e.g. \"info,debug\".\n   * Supports wildcards, e.g. \"azure:*\"\n   * Supports skip syntax, e.g. \"azure:*,-azure:storage:*\" will enable\n   * everything under azure except for things under azure:storage.\n   */\n  enable: (namespaces: string) => void;\n  /**\n   * Checks if a particular namespace is enabled.\n   */\n  enabled: (namespace: string) => boolean;\n  /**\n   * Disables all logging, returns what was previously enabled.\n   */\n  disable: () => string;\n}\n\n/**\n * A log function that can be dynamically enabled and redirected.\n */\nexport interface Debugger {\n  /**\n   * Logs the given arguments to the `log` method.\n   */\n  (...args: any[]): void;\n  /**\n   * True if this logger is active and logging.\n   */\n  enabled: boolean;\n  /**\n   * Used to cleanup/remove this logger.\n   */\n  destroy: () => boolean;\n  /**\n   * The current log method. Can be overridden to redirect output.\n   */\n  log: (...args: any[]) => void;\n  /**\n   * The namespace of this logger.\n   */\n  namespace: string;\n  /**\n   * Extends this logger with a child namespace.\n   * Namespaces are separated with a ':' character.\n   */\n  extend: (namespace: string) => Debugger;\n}\n\nconst debugEnvVariable =\n  (typeof process !== \"undefined\" && process.env && process.env.DEBUG) || undefined;\n\nlet enabledString: string | undefined;\nlet enabledNamespaces: RegExp[] = [];\nlet skippedNamespaces: RegExp[] = [];\nconst debuggers: Debugger[] = [];\n\nif (debugEnvVariable) {\n  enable(debugEnvVariable);\n}\n\nconst debugObj: Debug = Object.assign(\n  (namespace: string): Debugger => {\n    return createDebugger(namespace);\n  },\n  {\n    enable,\n    enabled,\n    disable,\n    log,\n  }\n);\n\nfunction enable(namespaces: string): void {\n  enabledString = namespaces;\n  enabledNamespaces = [];\n  skippedNamespaces = [];\n  const wildcard = /\\*/g;\n  const namespaceList = namespaces.split(\",\").map((ns) => ns.trim().replace(wildcard, \".*?\"));\n  for (const ns of namespaceList) {\n    if (ns.startsWith(\"-\")) {\n      skippedNamespaces.push(new RegExp(`^${ns.substr(1)}$`));\n    } else {\n      enabledNamespaces.push(new RegExp(`^${ns}$`));\n    }\n  }\n  for (const instance of debuggers) {\n    instance.enabled = enabled(instance.namespace);\n  }\n}\n\nfunction enabled(namespace: string): boolean {\n  if (namespace.endsWith(\"*\")) {\n    return true;\n  }\n\n  for (const skipped of skippedNamespaces) {\n    if (skipped.test(namespace)) {\n      return false;\n    }\n  }\n  for (const enabledNamespace of enabledNamespaces) {\n    if (enabledNamespace.test(namespace)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction disable(): string {\n  const result = enabledString || \"\";\n  enable(\"\");\n  return result;\n}\n\nfunction createDebugger(namespace: string): Debugger {\n  const newDebugger: Debugger = Object.assign(debug, {\n    enabled: enabled(namespace),\n    destroy,\n    log: debugObj.log,\n    namespace,\n    extend,\n  });\n\n  function debug(...args: any[]): void {\n    if (!newDebugger.enabled) {\n      return;\n    }\n    if (args.length > 0) {\n      args[0] = `${namespace} ${args[0]}`;\n    }\n    newDebugger.log(...args);\n  }\n\n  debuggers.push(newDebugger);\n\n  return newDebugger;\n}\n\nfunction destroy(this: Debugger): boolean {\n  const index = debuggers.indexOf(this);\n  if (index >= 0) {\n    debuggers.splice(index, 1);\n    return true;\n  }\n  return false;\n}\n\nfunction extend(this: Debugger, namespace: string): Debugger {\n  const newDebugger = createDebugger(`${this.namespace}:${namespace}`);\n  newDebugger.log = this.log;\n  return newDebugger;\n}\n\nexport default debugObj;\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport debug, { Debugger } from \"./debug\";\nexport { Debugger } from \"./debug\";\n\nconst registeredLoggers = new Set<AzureDebugger>();\nconst logLevelFromEnv =\n  (typeof process !== \"undefined\" && process.env && process.env.AZURE_LOG_LEVEL) || undefined;\n\nlet azureLogLevel: AzureLogLevel | undefined;\n\n/**\n * The AzureLogger provides a mechanism for overriding where logs are output to.\n * By default, logs are sent to stderr.\n * Override the `log` method to redirect logs to another location.\n */\nexport const AzureLogger: AzureClientLogger = debug(\"azure\");\nAzureLogger.log = (...args) => {\n  debug.log(...args);\n};\n\n/**\n * The log levels supported by the logger.\n * The log levels in order of most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport type AzureLogLevel = \"verbose\" | \"info\" | \"warning\" | \"error\";\nconst AZURE_LOG_LEVELS = [\"verbose\", \"info\", \"warning\", \"error\"];\n\ntype AzureDebugger = Debugger & { level: AzureLogLevel };\n\n/**\n * An AzureClientLogger is a function that can log to an appropriate severity level.\n */\nexport type AzureClientLogger = Debugger;\n\nif (logLevelFromEnv) {\n  // avoid calling setLogLevel because we don't want a mis-set environment variable to crash\n  if (isAzureLogLevel(logLevelFromEnv)) {\n    setLogLevel(logLevelFromEnv);\n  } else {\n    console.error(\n      `AZURE_LOG_LEVEL set to unknown log level '${logLevelFromEnv}'; logging is not enabled. Acceptable values: ${AZURE_LOG_LEVELS.join(\n        \", \"\n      )}.`\n    );\n  }\n}\n\n/**\n * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n * @param level - The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport function setLogLevel(level?: AzureLogLevel): void {\n  if (level && !isAzureLogLevel(level)) {\n    throw new Error(\n      `Unknown log level '${level}'. Acceptable values: ${AZURE_LOG_LEVELS.join(\",\")}`\n    );\n  }\n  azureLogLevel = level;\n\n  const enabledNamespaces = [];\n  for (const logger of registeredLoggers) {\n    if (shouldEnable(logger)) {\n      enabledNamespaces.push(logger.namespace);\n    }\n  }\n\n  debug.enable(enabledNamespaces.join(\",\"));\n}\n\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel(): AzureLogLevel | undefined {\n  return azureLogLevel;\n}\n\nconst levelMap = {\n  verbose: 400,\n  info: 300,\n  warning: 200,\n  error: 100,\n};\n\n/**\n * Defines the methods available on the SDK-facing logger.\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport interface AzureLogger {\n  /**\n   * Used for failures the program is unlikely to recover from,\n   * such as Out of Memory.\n   */\n  error: Debugger;\n  /**\n   * Used when a function fails to perform its intended task.\n   * Usually this means the function will throw an exception.\n   * Not used for self-healing events (e.g. automatic retry)\n   */\n  warning: Debugger;\n  /**\n   * Used when a function operates normally.\n   */\n  info: Debugger;\n  /**\n   * Used for detailed troubleshooting scenarios. This is\n   * intended for use by developers / system administrators\n   * for diagnosing specific failures.\n   */\n  verbose: Debugger;\n}\n\n/**\n * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.\n * @param namespace - The name of the SDK package.\n * @hidden\n */\nexport function createClientLogger(namespace: string): AzureLogger {\n  const clientRootLogger: AzureClientLogger = AzureLogger.extend(namespace);\n  patchLogMethod(AzureLogger, clientRootLogger);\n  return {\n    error: createLogger(clientRootLogger, \"error\"),\n    warning: createLogger(clientRootLogger, \"warning\"),\n    info: createLogger(clientRootLogger, \"info\"),\n    verbose: createLogger(clientRootLogger, \"verbose\"),\n  };\n}\n\nfunction patchLogMethod(parent: AzureClientLogger, child: AzureClientLogger | AzureDebugger): void {\n  child.log = (...args) => {\n    parent.log(...args);\n  };\n}\n\nfunction createLogger(parent: AzureClientLogger, level: AzureLogLevel): AzureDebugger {\n  const logger: AzureDebugger = Object.assign(parent.extend(level), {\n    level,\n  });\n\n  patchLogMethod(parent, logger);\n\n  if (shouldEnable(logger)) {\n    const enabledNamespaces = debug.disable();\n    debug.enable(enabledNamespaces + \",\" + logger.namespace);\n  }\n\n  registeredLoggers.add(logger);\n\n  return logger;\n}\n\nfunction shouldEnable(logger: AzureDebugger): boolean {\n  return Boolean(azureLogLevel && levelMap[logger.level] <= levelMap[azureLogLevel]);\n}\n\nfunction isAzureLogLevel(logLevel: string): logLevel is AzureLogLevel {\n  return AZURE_LOG_LEVELS.includes(logLevel as any);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-rest-pipeline\");\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { Debugger } from \"@azure/logger\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { logger as coreLogger } from \"../log\";\nimport { Sanitizer } from \"../util/sanitizer\";\n\n/**\n * The programmatic identifier of the logPolicy.\n */\nexport const logPolicyName = \"logPolicy\";\n\n/**\n * Options to configure the logPolicy.\n */\nexport interface LogPolicyOptions {\n  /**\n   * Header names whose values will be logged when logging is enabled.\n   * Defaults include a list of well-known safe headers. Any headers\n   * specified in this field will be added to that list.  Any other values will\n   * be written to logs as \"REDACTED\".\n   */\n  additionalAllowedHeaderNames?: string[];\n\n  /**\n   * Query string names whose values will be logged when logging is enabled. By default no\n   * query string values are logged.\n   */\n  additionalAllowedQueryParameters?: string[];\n\n  /**\n   * The log function to use for writing pipeline logs.\n   * Defaults to core-http's built-in logger.\n   * Compatible with the `debug` library.\n   */\n  logger?: Debugger;\n}\n\n/**\n * A policy that logs all requests and responses.\n * @param options - Options to configure logPolicy.\n */\nexport function logPolicy(options: LogPolicyOptions = {}): PipelinePolicy {\n  const logger = options.logger ?? coreLogger.info;\n  const sanitizer = new Sanitizer({\n    additionalAllowedHeaderNames: options.additionalAllowedHeaderNames,\n    additionalAllowedQueryParameters: options.additionalAllowedQueryParameters,\n  });\n  return {\n    name: logPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!logger.enabled) {\n        return next(request);\n      }\n\n      logger(`Request: ${sanitizer.sanitize(request)}`);\n\n      const response = await next(request);\n\n      logger(`Response status code: ${response.status}`);\n      logger(`Headers: ${sanitizer.sanitize(response.headers)}`);\n\n      return response;\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the redirectPolicy.\n */\nexport const redirectPolicyName = \"redirectPolicy\";\n\n/**\n * Methods that are allowed to follow redirects 301 and 302\n */\nconst allowedRedirect = [\"GET\", \"HEAD\"];\n\n/**\n * Options for how redirect responses are handled.\n */\nexport interface RedirectPolicyOptions {\n  /**\n   * The maximum number of times the redirect URL will be tried before\n   * failing.  Defaults to 20.\n   */\n  maxRetries?: number;\n}\n\n/**\n * A policy to follow Location headers from the server in order\n * to support server-side redirection.\n * In the browser, this policy is not used.\n * @param options - Options to control policy behavior.\n */\nexport function redirectPolicy(options: RedirectPolicyOptions = {}): PipelinePolicy {\n  const { maxRetries = 20 } = options;\n  return {\n    name: redirectPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      const response = await next(request);\n      return handleRedirect(next, response, maxRetries);\n    },\n  };\n}\n\nasync function handleRedirect(\n  next: SendRequest,\n  response: PipelineResponse,\n  maxRetries: number,\n  currentRetries: number = 0,\n): Promise<PipelineResponse> {\n  const { request, status, headers } = response;\n  const locationHeader = headers.get(\"location\");\n  if (\n    locationHeader &&\n    (status === 300 ||\n      (status === 301 && allowedRedirect.includes(request.method)) ||\n      (status === 302 && allowedRedirect.includes(request.method)) ||\n      (status === 303 && request.method === \"POST\") ||\n      status === 307) &&\n    currentRetries < maxRetries\n  ) {\n    const url = new URL(locationHeader, request.url);\n    request.url = url.toString();\n\n    // POST request with Status code 303 should be converted into a\n    // redirected GET request if the redirect url is present in the location header\n    if (status === 303) {\n      request.method = \"GET\";\n      request.headers.delete(\"Content-Length\");\n      delete request.body;\n    }\n\n    request.headers.delete(\"Authorization\");\n\n    const res = await next(request);\n    return handleRedirect(next, res, maxRetries, currentRetries + 1);\n  }\n\n  return response;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/*\n * NOTE: When moving this file, please update \"browser\" section in package.json.\n */\n\n/**\n * @internal\n */\nexport function getHeaderName(): string {\n  return \"x-ms-useragent\";\n}\n\ninterface NavigatorEx extends Navigator {\n  userAgentData?: {\n    platform?: string;\n  };\n}\n\n/**\n * @internal\n */\nexport function setPlatformSpecificData(map: Map<string, string>): void {\n  const localNavigator = globalThis.navigator as NavigatorEx;\n  map.set(\n    \"OS\",\n    (localNavigator?.userAgentData?.platform ?? localNavigator?.platform ?? \"unknown\").replace(\n      \" \",\n      \"\",\n    ),\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport const SDK_VERSION: string = \"1.14.0\";\n\nexport const DEFAULT_RETRY_POLICY_COUNT = 3;\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { getHeaderName, setPlatformSpecificData } from \"./userAgentPlatform\";\nimport { SDK_VERSION } from \"../constants\";\n\nfunction getUserAgentString(telemetryInfo: Map<string, string>): string {\n  const parts: string[] = [];\n  for (const [key, value] of telemetryInfo) {\n    const token = value ? `${key}/${value}` : key;\n    parts.push(token);\n  }\n  return parts.join(\" \");\n}\n\n/**\n * @internal\n */\nexport function getUserAgentHeaderName(): string {\n  return getHeaderName();\n}\n\n/**\n * @internal\n */\nexport function getUserAgentValue(prefix?: string): string {\n  const runtimeInfo = new Map<string, string>();\n  runtimeInfo.set(\"core-rest-pipeline\", SDK_VERSION);\n  setPlatformSpecificData(runtimeInfo);\n  const defaultAgent = getUserAgentString(runtimeInfo);\n  const userAgentValue = prefix ? `${prefix} ${defaultAgent}` : defaultAgent;\n  return userAgentValue;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { getUserAgentHeaderName, getUserAgentValue } from \"../util/userAgent\";\n\nconst UserAgentHeaderName = getUserAgentHeaderName();\n\n/**\n * The programmatic identifier of the userAgentPolicy.\n */\nexport const userAgentPolicyName = \"userAgentPolicy\";\n\n/**\n * Options for adding user agent details to outgoing requests.\n */\nexport interface UserAgentPolicyOptions {\n  /**\n   * String prefix to add to the user agent for outgoing requests.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\n/**\n * A policy that sets the User-Agent header (or equivalent) to reflect\n * the library version.\n * @param options - Options to customize the user agent value.\n */\nexport function userAgentPolicy(options: UserAgentPolicyOptions = {}): PipelinePolicy {\n  const userAgentValue = getUserAgentValue(options.userAgentPrefix);\n  return {\n    name: userAgentPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.headers.has(UserAgentHeaderName)) {\n        request.headers.set(UserAgentHeaderName, userAgentValue);\n      }\n      return next(request);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nexport function isNodeReadableStream(x: unknown): x is NodeJS.ReadableStream {\n  return Boolean(x && typeof (x as NodeJS.ReadableStream)[\"pipe\"] === \"function\");\n}\n\nexport function isWebReadableStream(x: unknown): x is ReadableStream {\n  return Boolean(\n    x &&\n      typeof (x as ReadableStream).getReader === \"function\" &&\n      typeof (x as ReadableStream).tee === \"function\",\n  );\n}\n\nexport function isReadableStream(x: unknown): x is ReadableStream | NodeJS.ReadableStream {\n  return isNodeReadableStream(x) || isWebReadableStream(x);\n}\n\nexport function isBlob(x: unknown): x is Blob {\n  return typeof (x as Blob).stream === \"function\";\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { isNode } from \"@azure/core-util\";\nimport { isNodeReadableStream } from \"./typeGuards\";\n\n/**\n * Options passed into createFile specifying metadata about the file.\n */\nexport interface CreateFileOptions {\n  /**\n   * The MIME type of the file.\n   */\n  type?: string;\n\n  /**\n   * Last modified time of the file as a UNIX timestamp.\n   * This will default to the current date.\n   */\n  lastModified?: number;\n\n  /**\n   * relative path of this file when uploading a directory.\n   */\n  webkitRelativePath?: string;\n}\n\n/**\n * Extra options for createFile when a stream is being passed in.\n */\nexport interface CreateFileFromStreamOptions extends CreateFileOptions {\n  /**\n   * Size of the file represented by the stream in bytes.\n   *\n   * This will be used by the pipeline when calculating the Content-Length header\n   * for the overall request.\n   */\n  size?: number;\n}\n\nconst unimplementedMethods = {\n  arrayBuffer: () => {\n    throw new Error(\"Not implemented\");\n  },\n  slice: () => {\n    throw new Error(\"Not implemented\");\n  },\n  text: () => {\n    throw new Error(\"Not implemented\");\n  },\n};\n\n/**\n * Private symbol used as key on objects created using createFile containing the\n * original source of the file object.\n *\n * This is used in Node to access the original Node stream without using Blob#stream, which\n * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and\n * Readable#to/fromWeb in Node versions we support:\n * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)\n * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)\n *\n * Once these versions are no longer supported, we may be able to stop doing this.\n *\n * @internal\n */\nconst rawContent: unique symbol = Symbol(\"rawContent\");\n\n/**\n * Type signature of a blob-like object with a raw content property.\n */\ninterface RawContent {\n  [rawContent](): Uint8Array | NodeJS.ReadableStream | ReadableStream<Uint8Array>;\n}\n\nfunction hasRawContent(x: unknown): x is RawContent {\n  return typeof (x as RawContent)[rawContent] === \"function\";\n}\n\n/**\n * Extract the raw content from a given blob-like object. If the input was created using createFile\n * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.\n * For true instances of Blob and File, returns the blob's content as a Web ReadableStream<Uint8Array>.\n *\n * @internal\n */\nexport function getRawContent(\n  blob: Blob,\n): NodeJS.ReadableStream | ReadableStream<Uint8Array> | Uint8Array {\n  if (hasRawContent(blob)) {\n    return blob[rawContent]();\n  } else {\n    return blob.stream();\n  }\n}\n\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function to:\n * - Create a File object for use in RequestBodyType.formData in environments where the\n *   global File object is unavailable.\n * - Create a File-like object from a readable stream without reading the stream into memory.\n *\n * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is\n *                  passed in a request's form data map, the stream will not be read into memory\n *                  and instead will be streamed when the request is made. In the event of a retry, the\n *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFileFromStream(\n  stream: () => ReadableStream<Uint8Array> | NodeJS.ReadableStream,\n  name: string,\n  options: CreateFileFromStreamOptions = {},\n): File {\n  return {\n    ...unimplementedMethods,\n    type: options.type ?? \"\",\n    lastModified: options.lastModified ?? new Date().getTime(),\n    webkitRelativePath: options.webkitRelativePath ?? \"\",\n    size: options.size ?? -1,\n    name,\n    stream: () => {\n      const s = stream();\n      if (isNodeReadableStream(s)) {\n        throw new Error(\n          \"Not supported: a Node stream was provided as input to createFileFromStream.\",\n        );\n      }\n\n      return s;\n    },\n    [rawContent]: stream,\n  } as File & RawContent;\n}\n\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.\n *\n * @param content - the content of the file as a Uint8Array in memory.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFile(\n  content: Uint8Array,\n  name: string,\n  options: CreateFileOptions = {},\n): File {\n  if (isNode) {\n    return {\n      ...unimplementedMethods,\n      type: options.type ?? \"\",\n      lastModified: options.lastModified ?? new Date().getTime(),\n      webkitRelativePath: options.webkitRelativePath ?? \"\",\n      size: content.byteLength,\n      name,\n      arrayBuffer: async () => content.buffer,\n      stream: () => new Blob([content]).stream(),\n      [rawContent]: () => content,\n    } as File & RawContent;\n  } else {\n    return new File([content], name, options);\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { getRawContent } from \"./file\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./typeGuards\";\n\n/**\n * Drain the content of the given ReadableStream into a Blob.\n * The blob's content may end up in memory or on disk dependent on size.\n */\nfunction drain(stream: ReadableStream<Uint8Array>): Promise<Blob> {\n  return new Response(stream).blob();\n}\n\nasync function toBlobPart(\n  source: ReadableStream<Uint8Array> | Blob | Uint8Array,\n): Promise<BlobPart> {\n  if (source instanceof Blob || source instanceof Uint8Array) {\n    return source;\n  }\n\n  if (isWebReadableStream(source)) {\n    return drain(source);\n  }\n\n  // If it's not a true Blob, and it's not a Uint8Array, we can assume the source\n  // is a fake File created by createFileFromStream and we can get the original stream\n  // using getRawContent.\n  const rawContent = getRawContent(source);\n\n  // Shouldn't happen but guard for it anyway\n  if (isNodeReadableStream(rawContent)) {\n    throw new Error(\n      \"Encountered unexpected type. In the browser, `concat` supports Web ReadableStream, Blob, Uint8Array, and files created using `createFile` only.\",\n    );\n  }\n\n  return toBlobPart(rawContent);\n}\n\n/**\n * Accepted binary data types for concat\n *\n * @internal\n */\ntype ConcatSource = ReadableStream<Uint8Array> | Blob | Uint8Array;\n\n/**\n * Utility function that concatenates a set of binary inputs into one combined output.\n *\n * @param sources - array of sources for the concatenation\n * @returns - in Node, a (() =\\> NodeJS.ReadableStream) which, when read, produces a concatenation of all the inputs.\n *           In browser, returns a `Blob` representing all the concatenated inputs.\n *\n * @internal\n */\nexport async function concat(\n  sources: (ConcatSource | (() => ConcatSource))[],\n): Promise<(() => NodeJS.ReadableStream) | Blob> {\n  const parts = [];\n  for (const source of sources) {\n    parts.push(await toBlobPart(typeof source === \"function\" ? source() : source));\n  }\n\n  return new Blob(parts);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { randomUUID, stringToUint8Array } from \"@azure/core-util\";\nimport type { BodyPart, HttpHeaders, PipelineRequest, PipelineResponse } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { concat } from \"../util/concat\";\nimport { isBlob } from \"../util/typeGuards\";\n\nfunction generateBoundary(): string {\n  return `----AzSDKFormBoundary${randomUUID()}`;\n}\n\nfunction encodeHeaders(headers: HttpHeaders): string {\n  let result = \"\";\n  for (const [key, value] of headers) {\n    result += `${key}: ${value}\\r\\n`;\n  }\n  return result;\n}\n\nfunction getLength(\n  source:\n    | (() => ReadableStream<Uint8Array>)\n    | (() => NodeJS.ReadableStream)\n    | Uint8Array\n    | Blob\n    | ReadableStream\n    | NodeJS.ReadableStream,\n): number | undefined {\n  if (source instanceof Uint8Array) {\n    return source.byteLength;\n  } else if (isBlob(source)) {\n    // if was created using createFile then -1 means we have an unknown size\n    return source.size === -1 ? undefined : source.size;\n  } else {\n    return undefined;\n  }\n}\n\nfunction getTotalLength(\n  sources: (\n    | (() => ReadableStream<Uint8Array>)\n    | (() => NodeJS.ReadableStream)\n    | Uint8Array\n    | Blob\n    | ReadableStream\n    | NodeJS.ReadableStream\n  )[],\n): number | undefined {\n  let total = 0;\n  for (const source of sources) {\n    const partLength = getLength(source);\n    if (partLength === undefined) {\n      return undefined;\n    } else {\n      total += partLength;\n    }\n  }\n  return total;\n}\n\nasync function buildRequestBody(\n  request: PipelineRequest,\n  parts: BodyPart[],\n  boundary: string,\n): Promise<void> {\n  const sources = [\n    stringToUint8Array(`--${boundary}`, \"utf-8\"),\n    ...parts.flatMap((part) => [\n      stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n      stringToUint8Array(encodeHeaders(part.headers), \"utf-8\"),\n      stringToUint8Array(\"\\r\\n\", \"utf-8\"),\n      part.body,\n      stringToUint8Array(`\\r\\n--${boundary}`, \"utf-8\"),\n    ]),\n    stringToUint8Array(\"--\\r\\n\\r\\n\", \"utf-8\"),\n  ];\n\n  const contentLength = getTotalLength(sources);\n  if (contentLength) {\n    request.headers.set(\"Content-Length\", contentLength);\n  }\n\n  request.body = await concat(sources);\n}\n\n/**\n * Name of multipart policy\n */\nexport const multipartPolicyName = \"multipartPolicy\";\n\nconst maxBoundaryLength = 70;\nconst validBoundaryCharacters = new Set(\n  `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?`,\n);\n\nfunction assertValidBoundary(boundary: string): void {\n  if (boundary.length > maxBoundaryLength) {\n    throw new Error(`Multipart boundary \"${boundary}\" exceeds maximum length of 70 characters`);\n  }\n\n  if (Array.from(boundary).some((x) => !validBoundaryCharacters.has(x))) {\n    throw new Error(`Multipart boundary \"${boundary}\" contains invalid characters`);\n  }\n}\n\n/**\n * Pipeline policy for multipart requests\n */\nexport function multipartPolicy(): PipelinePolicy {\n  return {\n    name: multipartPolicyName,\n    async sendRequest(request, next): Promise<PipelineResponse> {\n      if (!request.multipartBody) {\n        return next(request);\n      }\n\n      if (request.body) {\n        throw new Error(\"multipartBody and regular body cannot be set at the same time\");\n      }\n\n      let boundary = request.multipartBody.boundary;\n\n      const contentTypeHeader = request.headers.get(\"Content-Type\") ?? \"multipart/mixed\";\n      const parsedHeader = contentTypeHeader.match(/^(multipart\\/[^ ;]+)(?:; *boundary=(.+))?$/);\n      if (!parsedHeader) {\n        throw new Error(\n          `Got multipart request body, but content-type header was not multipart: ${contentTypeHeader}`,\n        );\n      }\n\n      const [, contentType, parsedBoundary] = parsedHeader;\n      if (parsedBoundary && boundary && parsedBoundary !== boundary) {\n        throw new Error(\n          `Multipart boundary was specified as ${parsedBoundary} in the header, but got ${boundary} in the request body`,\n        );\n      }\n\n      boundary ??= parsedBoundary;\n      if (boundary) {\n        assertValidBoundary(boundary);\n      } else {\n        boundary = generateBoundary();\n      }\n      request.headers.set(\"Content-Type\", `${contentType}; boundary=${boundary}`);\n      await buildRequestBody(request, request.multipartBody.parts, boundary);\n\n      request.multipartBody = undefined;\n\n      return next(request);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/*\n * NOTE: When moving this file, please update \"browser\" section in package.json\n */\n\nexport const decompressResponsePolicyName = \"decompressResponsePolicy\";\n\n/**\n * decompressResponsePolicy is not supported in the browser and attempting\n * to use it will raise an error.\n */\nexport function decompressResponsePolicy(): never {\n  throw new Error(\"decompressResponsePolicy is not supported in browser environment\");\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/**\n * This error is thrown when an asynchronous operation has been aborted.\n * Check for this error by testing the `name` that the name property of the\n * error matches `\"AbortError\"`.\n *\n * @example\n * ```ts\n * const controller = new AbortController();\n * controller.abort();\n * try {\n *   doAsyncWork(controller.signal)\n * } catch (e) {\n *   if (e.name === 'AbortError') {\n *     // handle abort error here.\n *   }\n * }\n * ```\n */\nexport class AbortError extends Error {\n  constructor(message?: string) {\n    super(message);\n    this.name = \"AbortError\";\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortError, type AbortSignalLike } from \"@azure/abort-controller\";\nimport type { PipelineResponse } from \"../interfaces\";\n\nconst StandardAbortMessage = \"The operation was aborted.\";\n\n/**\n * A wrapper for setTimeout that resolves a promise after delayInMs milliseconds.\n * @param delayInMs - The number of milliseconds to be delayed.\n * @param value - The value to be resolved with after a timeout of t milliseconds.\n * @param options - The options for delay - currently abort options\n *                  - abortSignal - The abortSignal associated with containing operation.\n *                  - abortErrorMsg - The abort error message associated with containing operation.\n * @returns Resolved promise\n */\nexport function delay<T>(\n  delayInMs: number,\n  value?: T,\n  options?: {\n    abortSignal?: AbortSignalLike;\n    abortErrorMsg?: string;\n  },\n): Promise<T | void> {\n  return new Promise((resolve, reject) => {\n    let timer: ReturnType<typeof setTimeout> | undefined = undefined;\n    let onAborted: (() => void) | undefined = undefined;\n\n    const rejectOnAbort = (): void => {\n      return reject(\n        new AbortError(options?.abortErrorMsg ? options?.abortErrorMsg : StandardAbortMessage),\n      );\n    };\n\n    const removeListeners = (): void => {\n      if (options?.abortSignal && onAborted) {\n        options.abortSignal.removeEventListener(\"abort\", onAborted);\n      }\n    };\n\n    onAborted = (): void => {\n      if (timer) {\n        clearTimeout(timer);\n      }\n      removeListeners();\n      return rejectOnAbort();\n    };\n\n    if (options?.abortSignal && options.abortSignal.aborted) {\n      return rejectOnAbort();\n    }\n\n    timer = setTimeout(() => {\n      removeListeners();\n      resolve(value);\n    }, delayInMs);\n\n    if (options?.abortSignal) {\n      options.abortSignal.addEventListener(\"abort\", onAborted);\n    }\n  });\n}\n\n/**\n * @internal\n * @returns the parsed value or undefined if the parsed value is invalid.\n */\nexport function parseHeaderValueAsNumber(\n  response: PipelineResponse,\n  headerName: string,\n): number | undefined {\n  const value = response.headers.get(headerName);\n  if (!value) return;\n  const valueAsNum = Number(value);\n  if (Number.isNaN(valueAsNum)) return;\n  return valueAsNum;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineResponse } from \"..\";\nimport { parseHeaderValueAsNumber } from \"../util/helpers\";\nimport type { RetryStrategy } from \"./retryStrategy\";\n\n/**\n * The header that comes back from Azure services representing\n * the amount of time (minimum) to wait to retry (in seconds or timestamp after which we can retry).\n */\nconst RetryAfterHeader = \"Retry-After\";\n/**\n * The headers that come back from Azure services representing\n * the amount of time (minimum) to wait to retry.\n *\n * \"retry-after-ms\", \"x-ms-retry-after-ms\" : milliseconds\n * \"Retry-After\" : seconds or timestamp\n */\nconst AllRetryAfterHeaders: string[] = [\"retry-after-ms\", \"x-ms-retry-after-ms\", RetryAfterHeader];\n\n/**\n * A response is a throttling retry response if it has a throttling status code (429 or 503),\n * as long as one of the [ \"Retry-After\" or \"retry-after-ms\" or \"x-ms-retry-after-ms\" ] headers has a valid value.\n *\n * Returns the `retryAfterInMs` value if the response is a throttling retry response.\n * If not throttling retry response, returns `undefined`.\n *\n * @internal\n */\nfunction getRetryAfterInMs(response?: PipelineResponse): number | undefined {\n  if (!(response && [429, 503].includes(response.status))) return undefined;\n  try {\n    // Headers: \"retry-after-ms\", \"x-ms-retry-after-ms\", \"Retry-After\"\n    for (const header of AllRetryAfterHeaders) {\n      const retryAfterValue = parseHeaderValueAsNumber(response, header);\n      if (retryAfterValue === 0 || retryAfterValue) {\n        // \"Retry-After\" header ==> seconds\n        // \"retry-after-ms\", \"x-ms-retry-after-ms\" headers ==> milli-seconds\n        const multiplyingFactor = header === RetryAfterHeader ? 1000 : 1;\n        return retryAfterValue * multiplyingFactor; // in milli-seconds\n      }\n    }\n\n    // RetryAfterHeader (\"Retry-After\") has a special case where it might be formatted as a date instead of a number of seconds\n    const retryAfterHeader = response.headers.get(RetryAfterHeader);\n    if (!retryAfterHeader) return;\n\n    const date = Date.parse(retryAfterHeader);\n    const diff = date - Date.now();\n    // negative diff would mean a date in the past, so retry asap with 0 milliseconds\n    return Number.isFinite(diff) ? Math.max(0, diff) : undefined;\n  } catch (e: any) {\n    return undefined;\n  }\n}\n\n/**\n * A response is a retry response if it has a throttling status code (429 or 503),\n * as long as one of the [ \"Retry-After\" or \"retry-after-ms\" or \"x-ms-retry-after-ms\" ] headers has a valid value.\n */\nexport function isThrottlingRetryResponse(response?: PipelineResponse): boolean {\n  return Number.isFinite(getRetryAfterInMs(response));\n}\n\nexport function throttlingRetryStrategy(): RetryStrategy {\n  return {\n    name: \"throttlingRetryStrategy\",\n    retry({ response }) {\n      const retryAfterInMs = getRetryAfterInMs(response);\n      if (!Number.isFinite(retryAfterInMs)) {\n        return { skipStrategy: true };\n      }\n      return {\n        retryAfterInMs,\n      };\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineResponse } from \"../interfaces\";\nimport type { RestError } from \"../restError\";\nimport { getRandomIntegerInclusive } from \"@azure/core-util\";\nimport type { RetryStrategy } from \"./retryStrategy\";\nimport { isThrottlingRetryResponse } from \"./throttlingRetryStrategy\";\n\n// intervals are in milliseconds\nconst DEFAULT_CLIENT_RETRY_INTERVAL = 1000;\nconst DEFAULT_CLIENT_MAX_RETRY_INTERVAL = 1000 * 64;\n\n/**\n * A retry strategy that retries with an exponentially increasing delay in these two cases:\n * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).\n * - Or otherwise if the outgoing request fails (408, greater or equal than 500, except for 501 and 505).\n */\nexport function exponentialRetryStrategy(\n  options: {\n    /**\n     * The amount of delay in milliseconds between retry attempts. Defaults to 1000\n     * (1 second.) The delay increases exponentially with each retry up to a maximum\n     * specified by maxRetryDelayInMs.\n     */\n    retryDelayInMs?: number;\n\n    /**\n     * The maximum delay in milliseconds allowed before retrying an operation. Defaults\n     * to 64000 (64 seconds).\n     */\n    maxRetryDelayInMs?: number;\n\n    /**\n     * If true it won't retry if it received a system error.\n     */\n    ignoreSystemErrors?: boolean;\n\n    /**\n     * If true it won't retry if it received a non-fatal HTTP status code.\n     */\n    ignoreHttpStatusCodes?: boolean;\n  } = {},\n): RetryStrategy {\n  const retryInterval = options.retryDelayInMs ?? DEFAULT_CLIENT_RETRY_INTERVAL;\n  const maxRetryInterval = options.maxRetryDelayInMs ?? DEFAULT_CLIENT_MAX_RETRY_INTERVAL;\n\n  let retryAfterInMs = retryInterval;\n\n  return {\n    name: \"exponentialRetryStrategy\",\n    retry({ retryCount, response, responseError }) {\n      const matchedSystemError = isSystemError(responseError);\n      const ignoreSystemErrors = matchedSystemError && options.ignoreSystemErrors;\n\n      const isExponential = isExponentialRetryResponse(response);\n      const ignoreExponentialResponse = isExponential && options.ignoreHttpStatusCodes;\n      const unknownResponse = response && (isThrottlingRetryResponse(response) || !isExponential);\n\n      if (unknownResponse || ignoreExponentialResponse || ignoreSystemErrors) {\n        return { skipStrategy: true };\n      }\n\n      if (responseError && !matchedSystemError && !isExponential) {\n        return { errorToThrow: responseError };\n      }\n\n      // Exponentially increase the delay each time\n      const exponentialDelay = retryAfterInMs * Math.pow(2, retryCount);\n      // Don't let the delay exceed the maximum\n      const clampedExponentialDelay = Math.min(maxRetryInterval, exponentialDelay);\n      // Allow the final value to have some \"jitter\" (within 50% of the delay size) so\n      // that retries across multiple clients don't occur simultaneously.\n      retryAfterInMs =\n        clampedExponentialDelay / 2 + getRandomIntegerInclusive(0, clampedExponentialDelay / 2);\n      return { retryAfterInMs };\n    },\n  };\n}\n\n/**\n * A response is a retry response if it has status codes:\n * - 408, or\n * - Greater or equal than 500, except for 501 and 505.\n */\nexport function isExponentialRetryResponse(response?: PipelineResponse): boolean {\n  return Boolean(\n    response &&\n      response.status !== undefined &&\n      (response.status >= 500 || response.status === 408) &&\n      response.status !== 501 &&\n      response.status !== 505,\n  );\n}\n\n/**\n * Determines whether an error from a pipeline response was triggered in the network layer.\n */\nexport function isSystemError(err?: RestError): boolean {\n  if (!err) {\n    return false;\n  }\n  return (\n    err.code === \"ETIMEDOUT\" ||\n    err.code === \"ESOCKETTIMEDOUT\" ||\n    err.code === \"ECONNREFUSED\" ||\n    err.code === \"ECONNRESET\" ||\n    err.code === \"ENOENT\" ||\n    err.code === \"ENOTFOUND\"\n  );\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { delay } from \"../util/helpers\";\nimport { createClientLogger } from \"@azure/logger\";\nimport type { RetryStrategy } from \"../retryStrategies/retryStrategy\";\nimport type { RestError } from \"../restError\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\n\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n\n/**\n * The programmatic identifier of the retryPolicy.\n */\nconst retryPolicyName = \"retryPolicy\";\n\n/**\n * Options to the {@link retryPolicy}\n */\nexport interface RetryPolicyOptions {\n  /**\n   * Maximum number of retries. If not specified, it will limit to 3 retries.\n   */\n  maxRetries?: number;\n  /**\n   * Logger. If it's not provided, a default logger is used.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(\n  strategies: RetryStrategy[],\n  options: RetryPolicyOptions = { maxRetries: DEFAULT_RETRY_POLICY_COUNT },\n): PipelinePolicy {\n  const logger = options.logger || retryPolicyLogger;\n  return {\n    name: retryPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      let response: PipelineResponse | undefined;\n      let responseError: RestError | undefined;\n      let retryCount = -1;\n\n      // eslint-disable-next-line no-constant-condition\n      retryRequest: while (true) {\n        retryCount += 1;\n        response = undefined;\n        responseError = undefined;\n\n        try {\n          logger.info(`Retry ${retryCount}: Attempting to send request`, request.requestId);\n          response = await next(request);\n          logger.info(`Retry ${retryCount}: Received a response from request`, request.requestId);\n        } catch (e: any) {\n          logger.error(`Retry ${retryCount}: Received an error from request`, request.requestId);\n\n          // RestErrors are valid targets for the retry strategies.\n          // If none of the retry strategies can work with them, they will be thrown later in this policy.\n          // If the received error is not a RestError, it is immediately thrown.\n          responseError = e as RestError;\n          if (!e || responseError.name !== \"RestError\") {\n            throw e;\n          }\n\n          response = responseError.response;\n        }\n\n        if (request.abortSignal?.aborted) {\n          logger.error(`Retry ${retryCount}: Request aborted.`);\n          const abortError = new AbortError();\n          throw abortError;\n        }\n\n        if (retryCount >= (options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT)) {\n          logger.info(\n            `Retry ${retryCount}: Maximum retries reached. Returning the last received response, or throwing the last received error.`,\n          );\n          if (responseError) {\n            throw responseError;\n          } else if (response) {\n            return response;\n          } else {\n            throw new Error(\"Maximum retries reached with no response or error to throw\");\n          }\n        }\n\n        logger.info(`Retry ${retryCount}: Processing ${strategies.length} retry strategies.`);\n\n        strategiesLoop: for (const strategy of strategies) {\n          const strategyLogger = strategy.logger || retryPolicyLogger;\n          strategyLogger.info(`Retry ${retryCount}: Processing retry strategy ${strategy.name}.`);\n\n          const modifiers = strategy.retry({\n            retryCount,\n            response,\n            responseError,\n          });\n\n          if (modifiers.skipStrategy) {\n            strategyLogger.info(`Retry ${retryCount}: Skipped.`);\n            continue strategiesLoop;\n          }\n\n          const { errorToThrow, retryAfterInMs, redirectTo } = modifiers;\n\n          if (errorToThrow) {\n            strategyLogger.error(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} throws error:`,\n              errorToThrow,\n            );\n            throw errorToThrow;\n          }\n\n          if (retryAfterInMs || retryAfterInMs === 0) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} retries after ${retryAfterInMs}`,\n            );\n            await delay(retryAfterInMs, undefined, { abortSignal: request.abortSignal });\n            continue retryRequest;\n          }\n\n          if (redirectTo) {\n            strategyLogger.info(\n              `Retry ${retryCount}: Retry strategy ${strategy.name} redirects to ${redirectTo}`,\n            );\n            request.url = redirectTo;\n            continue retryRequest;\n          }\n        }\n\n        if (responseError) {\n          logger.info(\n            `None of the retry strategies could work with the received error. Throwing it.`,\n          );\n          throw responseError;\n        }\n        if (response) {\n          logger.info(\n            `None of the retry strategies could work with the received response. Returning it.`,\n          );\n          return response;\n        }\n\n        // If all the retries skip and there's no response,\n        // we're still in the retry loop, so a new request will be sent\n        // until `maxRetries` is reached.\n      }\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRetryOptions } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { exponentialRetryStrategy } from \"../retryStrategies/exponentialRetryStrategy\";\nimport { throttlingRetryStrategy } from \"../retryStrategies/throttlingRetryStrategy\";\nimport { retryPolicy } from \"./retryPolicy\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants\";\n\n/**\n * Name of the {@link defaultRetryPolicy}\n */\nexport const defaultRetryPolicyName = \"defaultRetryPolicy\";\n\n/**\n * Options that control how to retry failed requests.\n */\nexport interface DefaultRetryPolicyOptions extends PipelineRetryOptions {}\n\n/**\n * A policy that retries according to three strategies:\n * - When the server sends a 429 response with a Retry-After header.\n * - When there are errors in the underlying transport layer (e.g. DNS lookup failures).\n * - Or otherwise if the outgoing request fails, it will retry with an exponentially increasing delay.\n */\nexport function defaultRetryPolicy(options: DefaultRetryPolicyOptions = {}): PipelinePolicy {\n  return {\n    name: defaultRetryPolicyName,\n    sendRequest: retryPolicy([throttlingRetryStrategy(), exponentialRetryStrategy(options)], {\n      maxRetries: options.maxRetries ?? DEFAULT_RETRY_POLICY_COUNT,\n    }).sendRequest,\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the formDataPolicy.\n */\nexport const formDataPolicyName = \"formDataPolicy\";\n\n/**\n * A policy that encodes FormData on the request into the body.\n */\nexport function formDataPolicy(): PipelinePolicy {\n  return {\n    name: formDataPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (request.formData) {\n        const formData = request.formData;\n        const requestForm = new FormData();\n        for (const formKey of Object.keys(formData)) {\n          const formValue = formData[formKey];\n          if (Array.isArray(formValue)) {\n            for (const subValue of formValue) {\n              requestForm.append(formKey, subValue);\n            }\n          } else {\n            requestForm.append(formKey, formValue);\n          }\n        }\n\n        request.body = requestForm;\n        request.formData = undefined;\n        const contentType = request.headers.get(\"Content-Type\");\n        if (contentType && contentType.indexOf(\"application/x-www-form-urlencoded\") !== -1) {\n          request.body = new URLSearchParams(requestForm as any).toString();\n        } else if (contentType && contentType.indexOf(\"multipart/form-data\") !== -1) {\n          // browser will automatically apply a suitable content-type header\n          request.headers.delete(\"Content-Type\");\n        }\n      }\n      return next(request);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\n/*\n * NOTE: When moving this file, please update \"browser\" section in package.json\n */\n\nexport const proxyPolicyName = \"proxyPolicy\";\nconst errorMessage = \"proxyPolicy is not supported in browser environment\";\n\nexport function getDefaultProxySettings(): never {\n  throw new Error(errorMessage);\n}\n\n/**\n * proxyPolicy is not supported in the browser and attempting\n * to use it will raise an error.\n */\nexport function proxyPolicy(): never {\n  throw new Error(errorMessage);\n}\n\n/**\n * A function to reset the cached agents.\n * proxyPolicy is not supported in the browser and attempting\n * to use it will raise an error.\n * @internal\n */\nexport function resetCachedProxyAgents(): never {\n  throw new Error(errorMessage);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\n\n/**\n * The programmatic identifier of the setClientRequestIdPolicy.\n */\nexport const setClientRequestIdPolicyName = \"setClientRequestIdPolicy\";\n\n/**\n * Each PipelineRequest gets a unique id upon creation.\n * This policy passes that unique id along via an HTTP header to enable better\n * telemetry and tracing.\n * @param requestIdHeaderName - The name of the header to pass the request ID to.\n */\nexport function setClientRequestIdPolicy(\n  requestIdHeaderName = \"x-ms-client-request-id\",\n): PipelinePolicy {\n  return {\n    name: setClientRequestIdPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.headers.has(requestIdHeaderName)) {\n        request.headers.set(requestIdHeaderName, request.requestId);\n      }\n      return next(request);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { PipelinePolicy } from \"../pipeline\";\nimport type { TlsSettings } from \"../interfaces\";\n\n/**\n * Name of the TLS Policy\n */\nexport const tlsPolicyName = \"tlsPolicy\";\n\n/**\n * Gets a pipeline policy that adds the client certificate to the HttpClient agent for authentication.\n */\nexport function tlsPolicy(tlsSettings?: TlsSettings): PipelinePolicy {\n  return {\n    name: tlsPolicyName,\n    sendRequest: async (req, next) => {\n      // Users may define a request tlsSettings, honor those over the client level one\n      if (!req.tlsSettings) {\n        req.tlsSettings = tlsSettings;\n      }\n      return next(req);\n    },\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TracingContext, TracingSpan } from \"./interfaces\";\n\n/** @internal */\nexport const knownContextKeys = {\n  span: Symbol.for(\"@azure/core-tracing span\"),\n  namespace: Symbol.for(\"@azure/core-tracing namespace\"),\n};\n\n/**\n * Creates a new {@link TracingContext} with the given options.\n * @param options - A set of known keys that may be set on the context.\n * @returns A new {@link TracingContext} with the given options.\n *\n * @internal\n */\nexport function createTracingContext(options: CreateTracingContextOptions = {}): TracingContext {\n  let context: TracingContext = new TracingContextImpl(options.parentContext);\n  if (options.span) {\n    context = context.setValue(knownContextKeys.span, options.span);\n  }\n  if (options.namespace) {\n    context = context.setValue(knownContextKeys.namespace, options.namespace);\n  }\n  return context;\n}\n\n/** @internal */\nexport class TracingContextImpl implements TracingContext {\n  private _contextMap: Map<symbol, unknown>;\n  constructor(initialContext?: TracingContext) {\n    this._contextMap =\n      initialContext instanceof TracingContextImpl\n        ? new Map<symbol, unknown>(initialContext._contextMap)\n        : new Map();\n  }\n\n  setValue(key: symbol, value: unknown): TracingContext {\n    const newContext = new TracingContextImpl(this);\n    newContext._contextMap.set(key, value);\n    return newContext;\n  }\n\n  getValue(key: symbol): unknown {\n    return this._contextMap.get(key);\n  }\n\n  deleteValue(key: symbol): TracingContext {\n    const newContext = new TracingContextImpl(this);\n    newContext._contextMap.delete(key);\n    return newContext;\n  }\n}\n\n/**\n * Represents a set of items that can be set when creating a new {@link TracingContext}.\n */\nexport interface CreateTracingContextOptions {\n  /** The {@link parentContext} - the newly created context will contain all the values of the parent context unless overridden. */\n  parentContext?: TracingContext;\n  /** An initial span to set on the context. */\n  span?: TracingSpan;\n  /** The namespace to set on any child spans. */\n  namespace?: string;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { Instrumenter, InstrumenterSpanOptions, TracingContext, TracingSpan } from \"./interfaces\";\nimport { createTracingContext } from \"./tracingContext\";\n\nexport function createDefaultTracingSpan(): TracingSpan {\n  return {\n    end: () => {\n      // noop\n    },\n    isRecording: () => false,\n    recordException: () => {\n      // noop\n    },\n    setAttribute: () => {\n      // noop\n    },\n    setStatus: () => {\n      // noop\n    },\n  };\n}\n\nexport function createDefaultInstrumenter(): Instrumenter {\n  return {\n    createRequestHeaders: (): Record<string, string> => {\n      return {};\n    },\n    parseTraceparentHeader: (): TracingContext | undefined => {\n      return undefined;\n    },\n    startSpan: (\n      _name: string,\n      spanOptions: InstrumenterSpanOptions\n    ): { span: TracingSpan; tracingContext: TracingContext } => {\n      return {\n        span: createDefaultTracingSpan(),\n        tracingContext: createTracingContext({ parentContext: spanOptions.tracingContext }),\n      };\n    },\n    withContext<\n      CallbackArgs extends unknown[],\n      Callback extends (...args: CallbackArgs) => ReturnType<Callback>\n    >(\n      _context: TracingContext,\n      callback: Callback,\n      ...callbackArgs: CallbackArgs\n    ): ReturnType<Callback> {\n      return callback(...callbackArgs);\n    },\n  };\n}\n\n/** @internal */\nlet instrumenterImplementation: Instrumenter | undefined;\n\n/**\n * Extends the Azure SDK with support for a given instrumenter implementation.\n *\n * @param instrumenter - The instrumenter implementation to use.\n */\nexport function useInstrumenter(instrumenter: Instrumenter): void {\n  instrumenterImplementation = instrumenter;\n}\n\n/**\n * Gets the currently set instrumenter, a No-Op instrumenter by default.\n *\n * @returns The currently set instrumenter\n */\nexport function getInstrumenter(): Instrumenter {\n  if (!instrumenterImplementation) {\n    instrumenterImplementation = createDefaultInstrumenter();\n  }\n  return instrumenterImplementation;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  OperationTracingOptions,\n  OptionsWithTracingContext,\n  Resolved,\n  TracingClient,\n  TracingClientOptions,\n  TracingContext,\n  TracingSpan,\n  TracingSpanOptions,\n} from \"./interfaces\";\nimport { getInstrumenter } from \"./instrumenter\";\nimport { knownContextKeys } from \"./tracingContext\";\n\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\nexport function createTracingClient(options: TracingClientOptions): TracingClient {\n  const { namespace, packageName, packageVersion } = options;\n\n  function startSpan<Options extends { tracingOptions?: OperationTracingOptions }>(\n    name: string,\n    operationOptions?: Options,\n    spanOptions?: TracingSpanOptions\n  ): {\n    span: TracingSpan;\n    updatedOptions: OptionsWithTracingContext<Options>;\n  } {\n    const startSpanResult = getInstrumenter().startSpan(name, {\n      ...spanOptions,\n      packageName: packageName,\n      packageVersion: packageVersion,\n      tracingContext: operationOptions?.tracingOptions?.tracingContext,\n    });\n    let tracingContext = startSpanResult.tracingContext;\n    const span = startSpanResult.span;\n    if (!tracingContext.getValue(knownContextKeys.namespace)) {\n      tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n    }\n    span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n    const updatedOptions: OptionsWithTracingContext<Options> = Object.assign({}, operationOptions, {\n      tracingOptions: { ...operationOptions?.tracingOptions, tracingContext },\n    });\n\n    return {\n      span,\n      updatedOptions,\n    };\n  }\n\n  async function withSpan<\n    Options extends { tracingOptions?: OperationTracingOptions },\n    Callback extends (\n      updatedOptions: Options,\n      span: Omit<TracingSpan, \"end\">\n    ) => ReturnType<Callback>\n  >(\n    name: string,\n    operationOptions: Options,\n    callback: Callback,\n    spanOptions?: TracingSpanOptions\n  ): Promise<Resolved<ReturnType<Callback>>> {\n    const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);\n    try {\n      const result = await withContext(updatedOptions.tracingOptions.tracingContext, () =>\n        Promise.resolve(callback(updatedOptions, span))\n      );\n      span.setStatus({ status: \"success\" });\n      return result as ReturnType<typeof withSpan>;\n    } catch (err: any) {\n      span.setStatus({ status: \"error\", error: err });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n\n  function withContext<\n    CallbackArgs extends unknown[],\n    Callback extends (...args: CallbackArgs) => ReturnType<Callback>\n  >(\n    context: TracingContext,\n    callback: Callback,\n    ...callbackArgs: CallbackArgs\n  ): ReturnType<Callback> {\n    return getInstrumenter().withContext(context, callback, ...callbackArgs);\n  }\n\n  /**\n   * Parses a traceparent header value into a span identifier.\n   *\n   * @param traceparentHeader - The traceparent header to parse.\n   * @returns An implementation-specific identifier for the span.\n   */\n  function parseTraceparentHeader(traceparentHeader: string): TracingContext | undefined {\n    return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n  }\n\n  /**\n   * Creates a set of request headers to propagate tracing information to a backend.\n   *\n   * @param tracingContext - The context containing the span to serialize.\n   * @returns The set of headers to add to a request.\n   */\n  function createRequestHeaders(tracingContext?: TracingContext): Record<string, string> {\n    return getInstrumenter().createRequestHeaders(tracingContext);\n  }\n\n  return {\n    startSpan,\n    withSpan,\n    withContext,\n    parseTraceparentHeader,\n    createRequestHeaders,\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport {\n  type TracingClient,\n  type TracingContext,\n  type TracingSpan,\n  createTracingClient,\n} from \"@azure/core-tracing\";\nimport { SDK_VERSION } from \"../constants\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { getUserAgentValue } from \"../util/userAgent\";\nimport { logger } from \"../log\";\nimport { getErrorMessage, isError } from \"@azure/core-util\";\nimport { isRestError } from \"../restError\";\n\n/**\n * The programmatic identifier of the tracingPolicy.\n */\nexport const tracingPolicyName = \"tracingPolicy\";\n\n/**\n * Options to configure the tracing policy.\n */\nexport interface TracingPolicyOptions {\n  /**\n   * String prefix to add to the user agent logged as metadata\n   * on the generated Span.\n   * Defaults to an empty string.\n   */\n  userAgentPrefix?: string;\n}\n\n/**\n * A simple policy to create OpenTelemetry Spans for each request made by the pipeline\n * that has SpanOptions with a parent.\n * Requests made without a parent Span will not be recorded.\n * @param options - Options to configure the telemetry logged by the tracing policy.\n */\nexport function tracingPolicy(options: TracingPolicyOptions = {}): PipelinePolicy {\n  const userAgent = getUserAgentValue(options.userAgentPrefix);\n  const tracingClient = tryCreateTracingClient();\n\n  return {\n    name: tracingPolicyName,\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!tracingClient || !request.tracingOptions?.tracingContext) {\n        return next(request);\n      }\n\n      const { span, tracingContext } = tryCreateSpan(tracingClient, request, userAgent) ?? {};\n\n      if (!span || !tracingContext) {\n        return next(request);\n      }\n\n      try {\n        const response = await tracingClient.withContext(tracingContext, next, request);\n        tryProcessResponse(span, response);\n        return response;\n      } catch (err: any) {\n        tryProcessError(span, err);\n        throw err;\n      }\n    },\n  };\n}\n\nfunction tryCreateTracingClient(): TracingClient | undefined {\n  try {\n    return createTracingClient({\n      namespace: \"\",\n      packageName: \"@azure/core-rest-pipeline\",\n      packageVersion: SDK_VERSION,\n    });\n  } catch (e: unknown) {\n    logger.warning(`Error when creating the TracingClient: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryCreateSpan(\n  tracingClient: TracingClient,\n  request: PipelineRequest,\n  userAgent?: string,\n): { span: TracingSpan; tracingContext: TracingContext } | undefined {\n  try {\n    // As per spec, we do not need to differentiate between HTTP and HTTPS in span name.\n    const { span, updatedOptions } = tracingClient.startSpan(\n      `HTTP ${request.method}`,\n      { tracingOptions: request.tracingOptions },\n      {\n        spanKind: \"client\",\n        spanAttributes: {\n          \"http.method\": request.method,\n          \"http.url\": request.url,\n          requestId: request.requestId,\n        },\n      },\n    );\n\n    // If the span is not recording, don't do any more work.\n    if (!span.isRecording()) {\n      span.end();\n      return undefined;\n    }\n\n    if (userAgent) {\n      span.setAttribute(\"http.user_agent\", userAgent);\n    }\n\n    // set headers\n    const headers = tracingClient.createRequestHeaders(\n      updatedOptions.tracingOptions.tracingContext,\n    );\n    for (const [key, value] of Object.entries(headers)) {\n      request.headers.set(key, value);\n    }\n    return { span, tracingContext: updatedOptions.tracingOptions.tracingContext };\n  } catch (e: any) {\n    logger.warning(`Skipping creating a tracing span due to an error: ${getErrorMessage(e)}`);\n    return undefined;\n  }\n}\n\nfunction tryProcessError(span: TracingSpan, error: unknown): void {\n  try {\n    span.setStatus({\n      status: \"error\",\n      error: isError(error) ? error : undefined,\n    });\n    if (isRestError(error) && error.statusCode) {\n      span.setAttribute(\"http.status_code\", error.statusCode);\n    }\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n\nfunction tryProcessResponse(span: TracingSpan, response: PipelineResponse): void {\n  try {\n    span.setAttribute(\"http.status_code\", response.status);\n    const serviceRequestId = response.headers.get(\"x-ms-request-id\");\n    if (serviceRequestId) {\n      span.setAttribute(\"serviceRequestId\", serviceRequestId);\n    }\n    span.setStatus({\n      status: \"success\",\n    });\n    span.end();\n  } catch (e: any) {\n    logger.warning(`Skipping tracing span processing due to an error: ${getErrorMessage(e)}`);\n  }\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { type LogPolicyOptions, logPolicy } from \"./policies/logPolicy\";\nimport { type Pipeline, createEmptyPipeline } from \"./pipeline\";\nimport type { PipelineRetryOptions, TlsSettings, ProxySettings } from \"./interfaces\";\nimport { type RedirectPolicyOptions, redirectPolicy } from \"./policies/redirectPolicy\";\nimport { type UserAgentPolicyOptions, userAgentPolicy } from \"./policies/userAgentPolicy\";\nimport { multipartPolicy, multipartPolicyName } from \"./policies/multipartPolicy\";\nimport { decompressResponsePolicy } from \"./policies/decompressResponsePolicy\";\nimport { defaultRetryPolicy } from \"./policies/defaultRetryPolicy\";\nimport { formDataPolicy } from \"./policies/formDataPolicy\";\nimport { isNode } from \"@azure/core-util\";\nimport { proxyPolicy } from \"./policies/proxyPolicy\";\nimport { setClientRequestIdPolicy } from \"./policies/setClientRequestIdPolicy\";\nimport { tlsPolicy } from \"./policies/tlsPolicy\";\nimport { tracingPolicy } from \"./policies/tracingPolicy\";\n\n/**\n * Defines options that are used to configure the HTTP pipeline for\n * an SDK client.\n */\nexport interface PipelineOptions {\n  /**\n   * Options that control how to retry failed requests.\n   */\n  retryOptions?: PipelineRetryOptions;\n\n  /**\n   * Options to configure a proxy for outgoing requests.\n   */\n  proxyOptions?: ProxySettings;\n\n  /** Options for configuring TLS authentication */\n  tlsOptions?: TlsSettings;\n\n  /**\n   * Options for how redirect responses are handled.\n   */\n  redirectOptions?: RedirectPolicyOptions;\n\n  /**\n   * Options for adding user agent details to outgoing requests.\n   */\n  userAgentOptions?: UserAgentPolicyOptions;\n\n  /**\n   * Options for setting common telemetry and tracing info to outgoing requests.\n   */\n  telemetryOptions?: TelemetryOptions;\n}\n\n/**\n * Defines options that are used to configure common telemetry and tracing info\n */\nexport interface TelemetryOptions {\n  /**\n   * The name of the header to pass the request ID to.\n   */\n  clientRequestIdHeaderName?: string;\n}\n\n/**\n * Defines options that are used to configure internal options of\n * the HTTP pipeline for an SDK client.\n */\nexport interface InternalPipelineOptions extends PipelineOptions {\n  /**\n   * Options to configure request/response logging.\n   */\n  loggingOptions?: LogPolicyOptions;\n}\n\n/**\n * Create a new pipeline with a default set of customizable policies.\n * @param options - Options to configure a custom pipeline.\n */\nexport function createPipelineFromOptions(options: InternalPipelineOptions): Pipeline {\n  const pipeline = createEmptyPipeline();\n\n  if (isNode) {\n    if (options.tlsOptions) {\n      pipeline.addPolicy(tlsPolicy(options.tlsOptions));\n    }\n    pipeline.addPolicy(proxyPolicy(options.proxyOptions));\n    pipeline.addPolicy(decompressResponsePolicy());\n  }\n\n  pipeline.addPolicy(formDataPolicy(), { beforePolicies: [multipartPolicyName] });\n  pipeline.addPolicy(userAgentPolicy(options.userAgentOptions));\n  pipeline.addPolicy(setClientRequestIdPolicy(options.telemetryOptions?.clientRequestIdHeaderName));\n  // The multipart policy is added after policies with no phase, so that\n  // policies can be added between it and formDataPolicy to modify\n  // properties (e.g., making the boundary constant in recorded tests).\n  pipeline.addPolicy(multipartPolicy(), { afterPhase: \"Deserialize\" });\n  pipeline.addPolicy(defaultRetryPolicy(options.retryOptions), { phase: \"Retry\" });\n  pipeline.addPolicy(tracingPolicy(options.userAgentOptions), { afterPhase: \"Retry\" });\n  if (isNode) {\n    // Both XHR and Fetch expect to handle redirects automatically,\n    // so only include this policy when we're in Node.\n    pipeline.addPolicy(redirectPolicy(options.redirectOptions), { afterPhase: \"Retry\" });\n  }\n  pipeline.addPolicy(logPolicy(options.loggingOptions), { afterPhase: \"Sign\" });\n\n  return pipeline;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { HttpHeaders, RawHttpHeaders, RawHttpHeadersInput } from \"./interfaces\";\n\ninterface HeaderEntry {\n  name: string;\n  value: string;\n}\n\nfunction normalizeName(name: string): string {\n  return name.toLowerCase();\n}\n\nfunction* headerIterator(map: Map<string, HeaderEntry>): IterableIterator<[string, string]> {\n  for (const entry of map.values()) {\n    yield [entry.name, entry.value];\n  }\n}\n\nclass HttpHeadersImpl implements HttpHeaders {\n  private readonly _headersMap: Map<string, HeaderEntry>;\n\n  constructor(rawHeaders?: RawHttpHeaders | RawHttpHeadersInput) {\n    this._headersMap = new Map<string, HeaderEntry>();\n    if (rawHeaders) {\n      for (const headerName of Object.keys(rawHeaders)) {\n        this.set(headerName, rawHeaders[headerName]);\n      }\n    }\n  }\n\n  /**\n   * Set a header in this collection with the provided name and value. The name is\n   * case-insensitive.\n   * @param name - The name of the header to set. This value is case-insensitive.\n   * @param value - The value of the header to set.\n   */\n  public set(name: string, value: string | number | boolean): void {\n    this._headersMap.set(normalizeName(name), { name, value: String(value).trim() });\n  }\n\n  /**\n   * Get the header value for the provided header name, or undefined if no header exists in this\n   * collection with the provided name.\n   * @param name - The name of the header. This value is case-insensitive.\n   */\n  public get(name: string): string | undefined {\n    return this._headersMap.get(normalizeName(name))?.value;\n  }\n\n  /**\n   * Get whether or not this header collection contains a header entry for the provided header name.\n   * @param name - The name of the header to set. This value is case-insensitive.\n   */\n  public has(name: string): boolean {\n    return this._headersMap.has(normalizeName(name));\n  }\n\n  /**\n   * Remove the header with the provided headerName.\n   * @param name - The name of the header to remove.\n   */\n  public delete(name: string): void {\n    this._headersMap.delete(normalizeName(name));\n  }\n\n  /**\n   * Get the JSON object representation of this HTTP header collection.\n   */\n  public toJSON(options: { preserveCase?: boolean } = {}): RawHttpHeaders {\n    const result: RawHttpHeaders = {};\n    if (options.preserveCase) {\n      for (const entry of this._headersMap.values()) {\n        result[entry.name] = entry.value;\n      }\n    } else {\n      for (const [normalizedName, entry] of this._headersMap) {\n        result[normalizedName] = entry.value;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the string representation of this HTTP header collection.\n   */\n  public toString(): string {\n    return JSON.stringify(this.toJSON({ preserveCase: true }));\n  }\n\n  /**\n   * Iterate over tuples of header [name, value] pairs.\n   */\n  [Symbol.iterator](): Iterator<[string, string]> {\n    return headerIterator(this._headersMap);\n  }\n}\n\n/**\n * Creates an object that satisfies the `HttpHeaders` interface.\n * @param rawHeaders - A simple object representing initial headers\n */\nexport function createHttpHeaders(rawHeaders?: RawHttpHeadersInput): HttpHeaders {\n  return new HttpHeadersImpl(rawHeaders);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { AbortError } from \"@azure/abort-controller\";\nimport type {\n  HttpClient,\n  HttpHeaders as PipelineHeaders,\n  PipelineRequest,\n  PipelineResponse,\n  TransferProgressEvent,\n} from \"./interfaces\";\nimport { RestError } from \"./restError\";\nimport { createHttpHeaders } from \"./httpHeaders\";\nimport { isNodeReadableStream, isWebReadableStream } from \"./util/typeGuards\";\n\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body: unknown): body is Blob {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient implements HttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  public async sendRequest(request: PipelineRequest): Promise<PipelineResponse> {\n    const url = new URL(request.url);\n    const isInsecure = url.protocol !== \"https:\";\n\n    if (isInsecure && !request.allowInsecureConnection) {\n      throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n    }\n\n    if (request.proxySettings) {\n      throw new Error(\"HTTP proxy is not supported in browser environment\");\n    }\n\n    try {\n      return await makeRequest(request);\n    } catch (e: any) {\n      throw getError(e, request);\n    }\n  }\n}\n\n/**\n * Sends a request\n */\nasync function makeRequest(request: PipelineRequest): Promise<PipelineResponse> {\n  const { abortController, abortControllerCleanup } = setupAbortSignal(request);\n  try {\n    const headers = buildFetchHeaders(request.headers);\n    const { streaming, body: requestBody } = buildRequestBody(request);\n    const requestInit: RequestInit = {\n      body: requestBody,\n      method: request.method,\n      headers: headers,\n      signal: abortController.signal,\n      // Cloudflare doesn't implement the full Fetch API spec\n      // because of some of it doesn't make sense in the edge.\n      // See https://github.com/cloudflare/workerd/issues/902\n      ...(\"credentials\" in Request.prototype\n        ? { credentials: request.withCredentials ? \"include\" : \"same-origin\" }\n        : {}),\n      ...(\"cache\" in Request.prototype ? { cache: \"no-store\" } : {}),\n    };\n\n    // According to https://fetch.spec.whatwg.org/#fetch-method,\n    // init.duplex must be set when body is a ReadableStream object.\n    // currently \"half\" is the only valid value.\n    if (streaming) {\n      (requestInit as any).duplex = \"half\";\n    }\n    /**\n     * Developers of the future:\n     * Do not set redirect: \"manual\" as part\n     * of request options.\n     * It will not work as you expect.\n     */\n    const response = await fetch(request.url, requestInit);\n    // If we're uploading a blob, we need to fire the progress event manually\n    if (isBlob(request.body) && request.onUploadProgress) {\n      request.onUploadProgress({ loadedBytes: request.body.size });\n    }\n    return buildPipelineResponse(response, request, abortControllerCleanup);\n  } catch (e) {\n    abortControllerCleanup?.();\n    throw e;\n  }\n}\n\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(\n  httpResponse: Response,\n  request: PipelineRequest,\n  abortControllerCleanup?: () => void,\n) {\n  const headers = buildPipelineHeaders(httpResponse);\n  const response: PipelineResponse = {\n    request,\n    headers,\n    status: httpResponse.status,\n  };\n\n  const bodyStream = isWebReadableStream(httpResponse.body)\n    ? buildBodyStream(httpResponse.body, {\n        onProgress: request.onDownloadProgress,\n        onEnd: abortControllerCleanup,\n      })\n    : httpResponse.body;\n\n  if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    request.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||\n    request.streamResponseStatusCodes?.has(response.status)\n  ) {\n    if (request.enableBrowserStreams) {\n      response.browserStreamBody = bodyStream ?? undefined;\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.blobBody = responseStream.blob();\n      abortControllerCleanup?.();\n    }\n  } else {\n    const responseStream = new Response(bodyStream);\n\n    response.bodyAsText = await responseStream.text();\n    abortControllerCleanup?.();\n  }\n\n  return response;\n}\n\nfunction setupAbortSignal(request: PipelineRequest): {\n  abortController: AbortController;\n  abortControllerCleanup: (() => void) | undefined;\n} {\n  const abortController = new AbortController();\n\n  // Cleanup function\n  let abortControllerCleanup: (() => void) | undefined;\n\n  /**\n   * Attach an abort listener to the request\n   */\n  let abortListener: ((event: any) => void) | undefined;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted.\");\n    }\n\n    abortListener = (event: Event) => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = () => {\n      if (abortListener) {\n        request.abortSignal?.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n\n  return { abortController, abortControllerCleanup };\n}\n\n/**\n * Gets the specific error\n */\nfunction getError(e: RestError, request: PipelineRequest): RestError {\n  if (e && e?.name === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: e?.code ?? RestError.REQUEST_SEND_ERROR,\n      request,\n    });\n  }\n}\n\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders: PipelineHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n\n  return headers;\n}\n\nfunction buildPipelineHeaders(httpResponse: Response): PipelineHeaders {\n  const responseHeaders = createHttpHeaders();\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n\n  return responseHeaders;\n}\n\nfunction buildRequestBody(request: PipelineRequest) {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n\n  return isWebReadableStream(body)\n    ? { streaming: true, body: buildBodyStream(body, { onProgress: request.onUploadProgress }) }\n    : { streaming: false, body };\n}\n\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(\n  readableStream: ReadableStream<Uint8Array>,\n  options: { onProgress?: (progress: TransferProgressEvent) => void; onEnd?: () => void } = {},\n): ReadableStream<Uint8Array> {\n  let loadedBytes = 0;\n  const { onProgress, onEnd } = options;\n\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(\n      new TransformStream({\n        transform(chunk, controller) {\n          if (chunk === null) {\n            controller.terminate();\n            return;\n          }\n\n          controller.enqueue(chunk);\n          loadedBytes += chunk.length;\n          if (onProgress) {\n            onProgress({ loadedBytes });\n          }\n        },\n        flush() {\n          onEnd?.();\n        },\n      }),\n    );\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      async pull(controller) {\n        const { done, value } = await reader.read();\n        // When no more data needs to be consumed, break the reading\n        if (done || !value) {\n          onEnd?.();\n          // Close the stream\n          controller.close();\n          reader.releaseLock();\n          return;\n        }\n\n        loadedBytes += value?.length ?? 0;\n\n        // Enqueue the next data chunk into our target stream\n        controller.enqueue(value);\n\n        if (onProgress) {\n          onProgress({ loadedBytes });\n        }\n      },\n      cancel(reason?: string) {\n        onEnd?.();\n        return reader.cancel(reason);\n      },\n    });\n  }\n}\n\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient(): HttpClient {\n  return new FetchHttpClient();\n}\n\nfunction isTransformStreamSupported(readableStream: ReadableStream): boolean {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { HttpClient } from \"./interfaces\";\nimport { createFetchHttpClient } from \"./fetchHttpClient\";\n\n/**\n * Create the correct HttpClient for the current environment.\n */\nexport function createDefaultHttpClient(): HttpClient {\n  return createFetchHttpClient();\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type {\n  FormDataMap,\n  HttpHeaders,\n  HttpMethods,\n  MultipartRequestBody,\n  PipelineRequest,\n  ProxySettings,\n  RequestBodyType,\n  TransferProgressEvent,\n} from \"./interfaces\";\nimport { createHttpHeaders } from \"./httpHeaders\";\nimport type { AbortSignalLike } from \"@azure/abort-controller\";\nimport { randomUUID } from \"@azure/core-util\";\nimport type { OperationTracingOptions } from \"@azure/core-tracing\";\n\n/**\n * Settings to initialize a request.\n * Almost equivalent to Partial<PipelineRequest>, but url is mandatory.\n */\nexport interface PipelineRequestOptions {\n  /**\n   * The URL to make the request to.\n   */\n  url: string;\n\n  /**\n   * The HTTP method to use when making the request.\n   */\n  method?: HttpMethods;\n\n  /**\n   * The HTTP headers to use when making the request.\n   */\n  headers?: HttpHeaders;\n\n  /**\n   * The number of milliseconds a request can take before automatically being terminated.\n   * If the request is terminated, an `AbortError` is thrown.\n   * Defaults to 0, which disables the timeout.\n   */\n  timeout?: number;\n\n  /**\n   * If credentials (cookies) should be sent along during an XHR.\n   * Defaults to false.\n   */\n  withCredentials?: boolean;\n\n  /**\n   * A unique identifier for the request. Used for logging and tracing.\n   */\n  requestId?: string;\n\n  /**\n   * The HTTP body content (if any)\n   */\n  body?: RequestBodyType;\n\n  /**\n   * Body for a multipart request.\n   */\n  multipartBody?: MultipartRequestBody;\n\n  /**\n   * To simulate a browser form post\n   */\n  formData?: FormDataMap;\n\n  /**\n   * A list of response status codes whose corresponding PipelineResponse body should be treated as a stream.\n   */\n  streamResponseStatusCodes?: Set<number>;\n\n  /**\n   * BROWSER ONLY\n   *\n   * A browser only option to enable use of the Streams API. If this option is set and streaming is used\n   * (see `streamResponseStatusCodes`), the response will have a property `browserStream` instead of\n   * `blobBody` which will be undefined.\n   *\n   * Default value is false\n   */\n  enableBrowserStreams?: boolean;\n\n  /**\n   * Proxy configuration.\n   */\n  proxySettings?: ProxySettings;\n\n  /**\n   * If the connection should not be reused.\n   */\n  disableKeepAlive?: boolean;\n\n  /**\n   * Used to abort the request later.\n   */\n  abortSignal?: AbortSignalLike;\n\n  /**\n   * Options used to create a span when tracing is enabled.\n   */\n  tracingOptions?: OperationTracingOptions;\n\n  /**\n   * Callback which fires upon upload progress.\n   */\n  onUploadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Callback which fires upon download progress. */\n  onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  /** Set to true if the request is sent over HTTP instead of HTTPS */\n  allowInsecureConnection?: boolean;\n}\n\nclass PipelineRequestImpl implements PipelineRequest {\n  public url: string;\n  public method: HttpMethods;\n  public headers: HttpHeaders;\n  public timeout: number;\n  public withCredentials: boolean;\n  public body?: RequestBodyType;\n  public multipartBody?: MultipartRequestBody;\n  public formData?: FormDataMap;\n  public streamResponseStatusCodes?: Set<number>;\n  public enableBrowserStreams: boolean;\n\n  public proxySettings?: ProxySettings;\n  public disableKeepAlive: boolean;\n  public abortSignal?: AbortSignalLike;\n  public requestId: string;\n  public tracingOptions?: OperationTracingOptions;\n  public allowInsecureConnection?: boolean;\n  public onUploadProgress?: (progress: TransferProgressEvent) => void;\n  public onDownloadProgress?: (progress: TransferProgressEvent) => void;\n\n  constructor(options: PipelineRequestOptions) {\n    this.url = options.url;\n    this.body = options.body;\n    this.headers = options.headers ?? createHttpHeaders();\n    this.method = options.method ?? \"GET\";\n    this.timeout = options.timeout ?? 0;\n    this.multipartBody = options.multipartBody;\n    this.formData = options.formData;\n    this.disableKeepAlive = options.disableKeepAlive ?? false;\n    this.proxySettings = options.proxySettings;\n    this.streamResponseStatusCodes = options.streamResponseStatusCodes;\n    this.withCredentials = options.withCredentials ?? false;\n    this.abortSignal = options.abortSignal;\n    this.tracingOptions = options.tracingOptions;\n    this.onUploadProgress = options.onUploadProgress;\n    this.onDownloadProgress = options.onDownloadProgress;\n    this.requestId = options.requestId || randomUUID();\n    this.allowInsecureConnection = options.allowInsecureConnection ?? false;\n    this.enableBrowserStreams = options.enableBrowserStreams ?? false;\n  }\n}\n\n/**\n * Creates a new pipeline request with the given options.\n * This method is to allow for the easy setting of default values and not required.\n * @param options - The options to create the request with.\n */\nexport function createPipelineRequest(options: PipelineRequestOptions): PipelineRequest {\n  return new PipelineRequestImpl(options);\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport { delay } from \"./helpers\";\n\n/**\n * A function that gets a promise of an access token and allows providing\n * options.\n *\n * @param options - the options to pass to the underlying token provider\n */\nexport type AccessTokenGetter = (\n  scopes: string | string[],\n  options: GetTokenOptions,\n) => Promise<AccessToken>;\n\nexport interface TokenCyclerOptions {\n  /**\n   * The window of time before token expiration during which the token will be\n   * considered unusable due to risk of the token expiring before sending the\n   * request.\n   *\n   * This will only become meaningful if the refresh fails for over\n   * (refreshWindow - forcedRefreshWindow) milliseconds.\n   */\n  forcedRefreshWindowInMs: number;\n  /**\n   * Interval in milliseconds to retry failed token refreshes.\n   */\n  retryIntervalInMs: number;\n  /**\n   * The window of time before token expiration during which\n   * we will attempt to refresh the token.\n   */\n  refreshWindowInMs: number;\n}\n\n// Default options for the cycler if none are provided\nexport const DEFAULT_CYCLER_OPTIONS: TokenCyclerOptions = {\n  forcedRefreshWindowInMs: 1000, // Force waiting for a refresh 1s before the token expires\n  retryIntervalInMs: 3000, // Allow refresh attempts every 3s\n  refreshWindowInMs: 1000 * 60 * 2, // Start refreshing 2m before expiry\n};\n\n/**\n * Converts an an unreliable access token getter (which may resolve with null)\n * into an AccessTokenGetter by retrying the unreliable getter in a regular\n * interval.\n *\n * @param getAccessToken - A function that produces a promise of an access token that may fail by returning null.\n * @param retryIntervalInMs - The time (in milliseconds) to wait between retry attempts.\n * @param refreshTimeout - The timestamp after which the refresh attempt will fail, throwing an exception.\n * @returns - A promise that, if it resolves, will resolve with an access token.\n */\nasync function beginRefresh(\n  getAccessToken: () => Promise<AccessToken | null>,\n  retryIntervalInMs: number,\n  refreshTimeout: number,\n): Promise<AccessToken> {\n  // This wrapper handles exceptions gracefully as long as we haven't exceeded\n  // the timeout.\n  async function tryGetAccessToken(): Promise<AccessToken | null> {\n    if (Date.now() < refreshTimeout) {\n      try {\n        return await getAccessToken();\n      } catch {\n        return null;\n      }\n    } else {\n      const finalToken = await getAccessToken();\n\n      // Timeout is up, so throw if it's still null\n      if (finalToken === null) {\n        throw new Error(\"Failed to refresh access token.\");\n      }\n\n      return finalToken;\n    }\n  }\n\n  let token: AccessToken | null = await tryGetAccessToken();\n\n  while (token === null) {\n    await delay(retryIntervalInMs);\n\n    token = await tryGetAccessToken();\n  }\n\n  return token;\n}\n\n/**\n * Creates a token cycler from a credential, scopes, and optional settings.\n *\n * A token cycler represents a way to reliably retrieve a valid access token\n * from a TokenCredential. It will handle initializing the token, refreshing it\n * when it nears expiration, and synchronizes refresh attempts to avoid\n * concurrency hazards.\n *\n * @param credential - the underlying TokenCredential that provides the access\n * token\n * @param tokenCyclerOptions - optionally override default settings for the cycler\n *\n * @returns - a function that reliably produces a valid access token\n */\nexport function createTokenCycler(\n  credential: TokenCredential,\n  tokenCyclerOptions?: Partial<TokenCyclerOptions>,\n): AccessTokenGetter {\n  let refreshWorker: Promise<AccessToken> | null = null;\n  let token: AccessToken | null = null;\n  let tenantId: string | undefined;\n\n  const options = {\n    ...DEFAULT_CYCLER_OPTIONS,\n    ...tokenCyclerOptions,\n  };\n\n  /**\n   * This little holder defines several predicates that we use to construct\n   * the rules of refreshing the token.\n   */\n  const cycler = {\n    /**\n     * Produces true if a refresh job is currently in progress.\n     */\n    get isRefreshing(): boolean {\n      return refreshWorker !== null;\n    },\n    /**\n     * Produces true if the cycler SHOULD refresh (we are within the refresh\n     * window and not already refreshing)\n     */\n    get shouldRefresh(): boolean {\n      return (\n        !cycler.isRefreshing &&\n        (token?.expiresOnTimestamp ?? 0) - options.refreshWindowInMs < Date.now()\n      );\n    },\n    /**\n     * Produces true if the cycler MUST refresh (null or nearly-expired\n     * token).\n     */\n    get mustRefresh(): boolean {\n      return (\n        token === null || token.expiresOnTimestamp - options.forcedRefreshWindowInMs < Date.now()\n      );\n    },\n  };\n\n  /**\n   * Starts a refresh job or returns the existing job if one is already\n   * running.\n   */\n  function refresh(\n    scopes: string | string[],\n    getTokenOptions: GetTokenOptions,\n  ): Promise<AccessToken> {\n    if (!cycler.isRefreshing) {\n      // We bind `scopes` here to avoid passing it around a lot\n      const tryGetAccessToken = (): Promise<AccessToken | null> =>\n        credential.getToken(scopes, getTokenOptions);\n\n      // Take advantage of promise chaining to insert an assignment to `token`\n      // before the refresh can be considered done.\n      refreshWorker = beginRefresh(\n        tryGetAccessToken,\n        options.retryIntervalInMs,\n        // If we don't have a token, then we should timeout immediately\n        token?.expiresOnTimestamp ?? Date.now(),\n      )\n        .then((_token) => {\n          refreshWorker = null;\n          token = _token;\n          tenantId = getTokenOptions.tenantId;\n          return token;\n        })\n        .catch((reason) => {\n          // We also should reset the refresher if we enter a failed state.  All\n          // existing awaiters will throw, but subsequent requests will start a\n          // new retry chain.\n          refreshWorker = null;\n          token = null;\n          tenantId = undefined;\n          throw reason;\n        });\n    }\n\n    return refreshWorker as Promise<AccessToken>;\n  }\n\n  return async (scopes: string | string[], tokenOptions: GetTokenOptions): Promise<AccessToken> => {\n    //\n    // Simple rules:\n    // - If we MUST refresh, then return the refresh task, blocking\n    //   the pipeline until a token is available.\n    // - If we SHOULD refresh, then run refresh but don't return it\n    //   (we can still use the cached token).\n    // - Return the token, since it's fine if we didn't return in\n    //   step 1.\n    //\n\n    // If the tenantId passed in token options is different to the one we have\n    // Or if we are in claim challenge and the token was rejected and a new access token need to be issued, we need to\n    // refresh the token with the new tenantId or token.\n    const mustRefresh =\n      tenantId !== tokenOptions.tenantId || Boolean(tokenOptions.claims) || cycler.mustRefresh;\n\n    if (mustRefresh) return refresh(scopes, tokenOptions);\n\n    if (cycler.shouldRefresh) {\n      refresh(scopes, tokenOptions);\n    }\n\n    return token as AccessToken;\n  };\n}\n", "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport type { AccessToken, GetTokenOptions, TokenCredential } from \"@azure/core-auth\";\nimport type { AzureLogger } from \"@azure/logger\";\nimport type { PipelineRequest, PipelineResponse, SendRequest } from \"../interfaces\";\nimport type { PipelinePolicy } from \"../pipeline\";\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n\n/**\n * Options sent to the authorizeRequest callback\n */\nexport interface AuthorizeRequestOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options sent to the authorizeRequestOnChallenge callback\n */\nexport interface AuthorizeRequestOnChallengeOptions {\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string[];\n  /**\n   * Function that retrieves either a cached access token or a new access token.\n   */\n  getAccessToken: (scopes: string[], options: GetTokenOptions) => Promise<AccessToken | null>;\n  /**\n   * Request that the policy is trying to fulfill.\n   */\n  request: PipelineRequest;\n  /**\n   * Response containing the challenge.\n   */\n  response: PipelineResponse;\n  /**\n   * A logger, if one was sent through the HTTP pipeline.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Options to override the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n */\nexport interface ChallengeCallbacks {\n  /**\n   * Allows for the authorization of the main request of this policy before it's sent.\n   */\n  authorizeRequest?(options: AuthorizeRequestOptions): Promise<void>;\n  /**\n   * Allows to handle authentication challenges and to re-authorize the request.\n   * The response containing the challenge is `options.response`.\n   * If this method returns true, the underlying request will be sent once again.\n   * The request may be modified before being sent.\n   */\n  authorizeRequestOnChallenge?(options: AuthorizeRequestOnChallengeOptions): Promise<boolean>;\n}\n\n/**\n * Options to configure the bearerTokenAuthenticationPolicy\n */\nexport interface BearerTokenAuthenticationPolicyOptions {\n  /**\n   * The TokenCredential implementation that can supply the bearer token.\n   */\n  credential?: TokenCredential;\n  /**\n   * The scopes for which the bearer token applies.\n   */\n  scopes: string | string[];\n  /**\n   * Allows for the processing of [Continuous Access Evaluation](https://docs.microsoft.com/azure/active-directory/conditional-access/concept-continuous-access-evaluation) challenges.\n   * If provided, it must contain at least the `authorizeRequestOnChallenge` method.\n   * If provided, after a request is sent, if it has a challenge, it can be processed to re-send the original request with the relevant challenge information.\n   */\n  challengeCallbacks?: ChallengeCallbacks;\n  /**\n   * A logger can be sent for debugging purposes.\n   */\n  logger?: AzureLogger;\n}\n\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options: AuthorizeRequestOptions): Promise<void> {\n  const { scopes, getAccessToken, request } = options;\n  const getTokenOptions: GetTokenOptions = {\n    abortSignal: request.abortSignal,\n    tracingOptions: request.tracingOptions,\n  };\n  const accessToken = await getAccessToken(scopes, getTokenOptions);\n\n  if (accessToken) {\n    options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n  }\n}\n\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response: PipelineResponse): string | undefined {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(\n  options: BearerTokenAuthenticationPolicyOptions,\n): PipelinePolicy {\n  const { credential, scopes, challengeCallbacks } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = {\n    authorizeRequest: challengeCallbacks?.authorizeRequest ?? defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: challengeCallbacks?.authorizeRequestOnChallenge,\n    // keep all other properties\n    ...challengeCallbacks,\n  };\n\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential\n    ? createTokenCycler(credential /* , options */)\n    : () => Promise.resolve(null);\n\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    async sendRequest(request: PipelineRequest, next: SendRequest): Promise<PipelineResponse> {\n      if (!request.url.toLowerCase().startsWith(\"https://\")) {\n        throw new Error(\n          \"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\",\n        );\n      }\n\n      await callbacks.authorizeRequest({\n        scopes: Array.isArray(scopes) ? scopes : [scopes],\n        request,\n        getAccessToken,\n        logger,\n      });\n\n      let response: PipelineResponse;\n      let error: Error | undefined;\n      try {\n        response = await next(request);\n      } catch (err: any) {\n        error = err;\n        response = err.response;\n      }\n\n      if (\n        callbacks.authorizeRequestOnChallenge &&\n        response?.status === 401 &&\n        getChallenge(response)\n      ) {\n        // processes challenge\n        const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          response,\n          getAccessToken,\n          logger,\n        });\n\n        if (shouldSendRequest) {\n          return next(request);\n        }\n      }\n\n      if (error) {\n        throw error;\n      } else {\n        return response;\n      }\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": ["_a", "_a", "enabledNamespaces", "logger", "logger", "enabledNamespaces", "logger", "_a", "_c", "_b", "_a", "rawContent", "_a", "AbortError", "delay", "AbortError", "_a", "_b", "logger", "_a", "AbortError", "_b", "delay", "_a", "_a", "_a", "_b", "_a", "_a", "isBlob", "buildRequestBody", "_a", "_b", "AbortError", "_a", "_b", "_c", "_d", "_a", "delay", "logger", "_a"]
}
